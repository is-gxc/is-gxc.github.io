---
title: MySQL锁
date: 2024-07-01 22:55:26
categories: MySQL
tags: [MySQL,数据库]
---

# MySQL锁的分类

根据加锁的范围，可以分为：

- 全局锁
- 表级锁
- 行级锁

其中表锁种又有：

- 表锁
- 元数据锁
- 意向锁
- AUTO-INC锁

行锁有：

- 记录锁（Record Lock）
- 间隙锁（Gap Lock）
- 临键锁（Next Key Lock）

# 全局锁

加上全局锁，整个数据库就都是只读状态了。当会话断开后，全局锁会被自动释放。

一般用于全库逻辑备份。

加锁：

```sql
flush tables with read lock
```

释放锁：

```sql
unlock tables
```

慎用！加上全局锁后，整个数据库就都是只读状态，此时业务只能读数据，不能更新数据，可能会造成业务停滞。

在可重复读的隔离级别下，如果在备份数据库前开启事务，就会创建Read View，在MVCC下，备份期间依然可以对数据进行更新操作，不影响其他事务。在使用mysqldump 进行备份时，加上 `–single-transaction`就可以开启事务。但是这种方法仅适用于 可重复读隔离级别的事务 的存储引擎。

# 表级锁

## 表锁

表锁有两种：共享锁（读锁）、独占锁（写锁）

示例：对表T加表锁

```sql
//共享锁
lock tables T read;
//独占锁
lock tables T write;
```

表锁不但会限制别的线程的读写，还会限制本线程的读写。

例如，对表T加了 共享锁 ，那么本线程和其他线程接下来的写操作也会被阻塞。

释放表锁：

```sql
unlock tables;
```

## 元数据锁

我们不需要显示的使用元数据锁（MDL），因为当我们在对数据库进行操作时，会自动给这个表加上元数据锁（MDL）：

- 对一张表进行CURD的操作时，加的是MDL读锁

- 对一张表结构进行变更操作的时候，加的是MDL写锁

元数据锁是为了保证一个线程对表进行CURD操作时，另一个线程对表结构进行了变更。

当我们开启一个事务的时候，就会默认加上元数据锁，当事务提交或者回滚之后，锁才会释放。

下面看这样一个场景：

- 线程a开启了一个事务，一直没有结束，执行的是CURD操作，所以对表加上了MDL读锁
- 线程b也开启一个事务，执行CURD操作，此时不会阻塞，因为「读读共享」
- 线程c修改表结构，但是由于线程a一直没有提交，线程a的MDL读锁没有释放，就会导致线程c阻塞

在线程c阻塞之后，后续所有对该表进行CURD的操作都会阻塞。

因为申请MDL锁会形成一个队列，**写锁优先级高于读锁**，当写锁等待，就会阻塞后续所有的CURD操作。

所以在对表结构进行变更前，先检查下有没有长事务，若有长事务，考虑kill掉或是等待执行完毕。

## 意向锁

意向锁（Intention Locks）主要目的是为了支持在不同粒度级别上并发控制的需求，即表级锁和行级锁的混合使用。意向锁包括以下几种类型：

1. **意向共享锁（Intention Shared Lock，IS）**：表示事务想要在表中的某些行上加共享锁。在使用 InnoDB 引擎的表里对某些记录加上「共享锁」之前，需要先在表级别加上一个「意向共享锁」
2. **意向独占锁（Intention Exclusive Lock，IX）**：表示事务想要在表中的某些行上加独占锁。在使用 InnoDB 引擎的表里对某些纪录加上「独占锁」之前，需要先在表级别加上一个「意向独占锁」

意向锁的作用是提前在表级别上标记一个事务将要在某些行上进行锁操作，从而避免在表级和行级锁之间产生冲突。具体来说，当一个事务在某行上加锁时，它会首先在表级别上加一个意向锁，以表明它在表中的某些行上持有或计划持有某种锁，当其他事务要加表锁的时候，就可以快速判断是否可以加锁，而不需要扫描整个表的锁信息来确保没有冲突的存在。

加锁方式

```sql
//先在表上加上意向共享锁，然后对读取的记录加共享锁
select ... lock in share mode;

//先表上加上意向独占锁，然后对读取的记录加独占锁
select ... for update;
```

意向锁是表级锁，不会和行级别的共享锁和独占锁发生冲突，但是会和共享表锁、独占表锁发生冲突，具体兼容性如下表：

|      | IS   | IX   | S    | X    |
| ---- | ---- | ---- | ---- | ---- |
| IS   | Y    | Y    | Y    | N    |
| IX   | Y    | Y    | N    | N    |
| S    | Y    | N    | Y    | N    |
| X    | N    | N    | N    | N    |

举个例子：

假设有一个表 `orders`，其中有若干行记录。现在有三个事务同时操作该表：

- **事务1** 要读取行1和行2的数据。
- **事务2** 要更新行3的数据。
- **事务3** 要对整个表进行备份。

具体的锁操作如下：

1. 事务1：
   - 在表 `orders` 上加 IS 锁。
   - 在行1和行2上加 S 锁。
2. 事务2：
   - 在表 `orders` 上加 IX 锁。
   - 在行3上加 X 锁。
3. 事务3：
   - 在表 `orders` 上加 S 锁（对整个表进行共享访问，可能是备份操作）。

**冲突检查过程**

- **事务1** 和 **事务2** 在表级别加的 IS 锁和 IX 锁是兼容的，可以同时存在。
- 当 **事务3** 尝试在表 `orders` 上加 S 锁时，数据库系统会检查当前表上的锁状态，发现表上已经有 IX 锁（由事务2 持有）。由于 S 锁和 IX 锁是不兼容的，**事务3** 必须等待 **事务2** 释放 IX 锁。

## AUTO-INC锁

AUTO-INC锁（自动递增锁）是MySQL在使用`AUTO_INCREMENT`列时为了确保自增值唯一性和顺序性而使用的一种特殊锁。它主要用于控制并发插入操作，以保证每个插入操作都能获得唯一且递增的自增值。

表里的主键通常都会设置成自增的，这是通过对主键字段声明 `AUTO_INCREMENT` 属性实现的。之后可以在插入数据时，可以不指定主键的值，数据库会自动给主键赋值递增的值，这主要是通过 **AUTO-INC 锁**实现的。

### AUTO-INC锁的工作原理

当一个表包含一个`AUTO_INCREMENT`列时，MySQL在执行插入操作时会申请一个AUTO-INC锁。这个锁的作用是确保在并发插入操作中，每个插入操作获得的自增值都是唯一且按顺序递增的。具体过程如下：

1. **申请AUTO-INC锁**：
   - 当事务要向包含AUTO_INCREMENT列的表插入一行时，首先需要获取AUTO-INC锁。
2. **分配自增值**：
   - 获得AUTO-INC锁后，MySQL从当前的自增值计数器中分配一个新的自增值给该插入操作。
3. **释放AUTO-INC锁**：
   - 插入操作完成后，事务释放AUTO-INC锁，允许其他事务继续进行插入操作。

### AUTO-INC锁的类型和范围

- **表级锁**：AUTO-INC锁是表级锁，而不是行级锁。这意味着当一个事务持有AUTO-INC锁时，其他事务不能向同一个表插入数据，直到该锁被释放。
- **短期锁**：AUTO-INC锁是短期锁，**仅在分配自增值的过程中持有**。这使得插入操作不会因为等待自增值分配而长期阻塞。

### AUTO-INC锁的并发控制

AUTO-INC锁通过以下机制控制并发插入操作：

1. **串行化插入操作**：
   - 由于AUTO-INC锁是表级锁，所有向包含AUTO_INCREMENT列的表插入数据的操作在分配自增值时都是串行化的。这确保了自增值的唯一性和顺序性。
2. **减少锁竞争**：
   - AUTO-INC锁是短期锁，仅在分配自增值时持有，插入数据时立即释放。这减少了锁竞争的机会，提高了并发插入操作的效率。

# 行级锁

InnoDB引擎是支持行级锁的，MyISAM引擎不支持行级锁。

由于InnoDB支持行级锁，粒度更细，所以尽量使用行级锁而不是表锁。

在InnoDB中，由于默认的隔离级别是可重复读，所以支持Read View，读数据属于快照读，不需要加锁，但是也可以使用如下语句进行加锁：

```sql
//对读取的记录加共享锁
select ... lock in share mode;

//对读取的记录加独占锁
select ... for update;
```

先说行级锁之间的兼容情况

|      | X    | S    |
| ---- | ---- | ---- |
| X    | N    | N    |
| S    | N    | Y    |

- 当一个事务对一条记录加了 S 型记录锁后，其他事务也可以继续对该记录加 S 型记录锁（S 型与 S 锁兼容），但是不可以对该记录加 X 型记录锁（S 型与 X 锁不兼容）;
- 当一个事务对一条记录加了 X 型记录锁后，其他事务既不可以对该记录加 S 型记录锁（S 型与 X 锁不兼容），也不可以对该记录加 X 型记录锁（X 型与 X 锁不兼容）。

在 MySQL 的 InnoDB 存储引擎中，行级锁主要包括记录锁（Record Lock）、间隙锁（Gap Lock）和临键锁（Next-Key Lock）。

## 记录锁（Record Lock）

记录锁锁定的是索引记录本身，而不是间隙或范围。记录锁通常用于精确锁定某一行数据，以防止其他事务对该行进行并发修改。

示例：

```sql
START TRANSACTION;
SELECT * FROM orders WHERE id = 1 FOR UPDATE;
```

上述查询会对 `id = 1` 的记录加一个排他锁（X锁），防止其他事务对该行进行修改。

## 间隙锁（Gap Lock）

间隙锁锁定的是索引记录之间的间隙，而不是实际的索引记录。间隙锁用于防止其他事务在锁定间隙中插入新的行，以避免幻读现象。

**使用场景：**

间隙锁主要在可重复读（REPEATABLE READ）隔离级别下使用，当执行范围查询并加锁时，InnoDB 会使用间隙锁来锁定查询范围内的间隙。

示例：

```sql
START TRANSACTION;
SELECT * FROM orders WHERE id > 5 AND id < 10 FOR UPDATE;
```

上述查询将锁定 `id` 为 5 和 10 之间的所有间隙，防止其他事务在这些间隙中插入新的行。

间隙锁的目的是防止间隙中插入新的行，所以是可以有多个事务，对同一个间隙加锁的，都是为了保证间隙中不会插入新行

## 临键锁（Next-Key Lock）

临键锁是记录锁和间隙锁的组合，用于锁定一个索引记录以及它前面的间隙。这种锁用于防止幻读现象，确保一致性读取。

**使用场景：**

临键锁在范围查询和单行查询中都可以使用，以确保查询范围内的所有记录和间隙都被锁定。

示例：

```sql
START TRANSACTION;
SELECT * FROM orders WHERE id = 7 FOR UPDATE;
```

上述查询将锁定 `id = 7` 的记录及其前面的间隙。这意味着 `id = 7` 的记录和从 `id = 6` 到 `id = 7` 的间隙都被锁定，防止其他事务对这些区域进行插入、更新或删除操作。

虽然相同范围的间隙锁是多个事务相互兼容的，但对于记录锁，我们是要考虑 X 型与 S 型关系，X 型的记录锁与 X 型的记录锁是冲突的。

## 插入意向锁（Insert Intention Lock）

一个事务在插入一条记录的时候，需要判断插入位置是否已被其他事务加了间隙锁（next-key lock 也包含间隙锁）。

如果有的话，插入操作就会发生**阻塞**，直到拥有间隙锁的那个事务提交为止（释放间隙锁的时刻），在此期间会生成一个**插入意向锁**，表明有事务想在某个区间插入新记录，但是现在处于等待状态。

插入意向锁名字虽然有意向锁，但是它并**不是意向锁，它是一种特殊的间隙锁，属于行级别锁**。

### 插入意向锁的工作原理

1. **获取间隙锁**：当一个事务尝试在某个索引间隙中插入一条新记录时，它首先会获取一个插入意向锁。这是一个特殊类型的间隙锁，用于表示该事务计划在这个间隙中插入一条记录。
2. **允许并发插入**：插入意向锁是互相兼容的，这意味着多个事务可以同时在同一个索引间隙中获取插入意向锁。这允许多个插入操作并发进行，而不会互相阻塞。
3. **实际插入**：当事务实际插入记录时，插入意向锁会升级为插入操作所需的具体锁（如记录锁）。如果插入的位置已经被其他事务锁定（例如，被一个排他锁锁定），插入操作将等待直到锁被释放。

# MySQL是怎样加锁的

行锁加锁的对象是索引，加锁的基本单位是 next-key lock，它是由记录锁和间隙锁组合而成的，next-key lock是前开后闭区间，而间隙锁是前开后开区间。

但是在记录锁或者间隙锁就能避免幻读时， next-key lock就会退化成记录锁或者间隙锁。

加锁位置实在主键索引上的，如果是用二级索引（不管是不是非唯一索引，还是唯一索引）进行锁定读查询的时候，除了会对二级索引项加行级锁（如果是唯一索引的二级索引，加锁规则和主键索引的案例相同），而且还会对查询到的记录的主键索引项上加「记录锁」。

具体如何退化，以如下四个场景来介绍

## 唯一索引等值查询

如果查询条件是基于唯一索引的等值查询，并且只锁定一行，临键锁会退化为记录锁。

当查询记录不存在时，在索引树找到第一条大于该查询记录的记录后，该记录的索引中的next-key lock，就会退化成间隙锁。

## 唯一索引范围查询

对于使用唯一索引的范围查询，临键锁可能会退化为记录锁和间隙锁的组合，这取决于查询的具体范围和数据的分布。

情况一：针对「大于等于」的范围查询，因为存在等值查询的条件，那么如果等值查询的记录是存在于表中，那么该记录的索引中的 next-key 锁会退化成记录锁。

比如以下语句

```sql
select * from users where user_id >= 12;
```

当12存在的时候，对于该记录的临建锁就会退化成记录锁，当12不存在，就会给第一个大于12的值，假如说是13加上临键锁



情况二：针对「小于或者小于等于」的范围查询，要看条件值的记录是否存在于表中：

当条件值的记录不在表中，那么不管是「小于」还是「小于等于」条件的范围查询，扫描到终止范围查询的记录时，该记录的索引的 next-key 锁会退化成间隙锁，其他扫描到的记录，都是在这些记录的索引上加 next-key 锁。

当条件值的记录在表中，如果是「小于」条件的范围查询，扫描到终止范围查询的记录时，该记录的索引的 next-key 锁会退化成间隙锁，其他扫描到的记录，都是在这些记录的索引上加 next-key 锁；如果「小于等于」条件的范围查询，扫描到终止范围查询的记录时，该记录的索引 next-key 锁不会退化成间隙锁。其他扫描到的记录，都是在这些记录的索引上加 next-key 锁

## 非唯一索引等值查询

当查询条件是基于非唯一索引的查询时，InnoDB 通常会使用间隙锁来锁定索引记录之间的间隙，以防止幻读现象。非唯一索引无法精确锁定单个记录，因此需要锁定范围。

假如现在有表如下

```sql
CREATE TABLE orders (
    id INT AUTO_INCREMENT,
    product_name VARCHAR(255),
    quantity INT,
    PRIMARY KEY (id),
    INDEX (product_name)
);
```

现在我们进行非唯一索引查询：

```sql
START TRANSACTION;
SELECT * FROM orders WHERE product_name = 'Product A' FOR UPDATE;
```

在这个查询中：

- 查询条件使用了非唯一索引 `product_name`。
- InnoDB 需要锁定 `product_name = 'Product A'` 的所有记录及其前后的间隙，防止其他事务插入新的 `product_name = 'Product A'` 记录。
- 临键锁会退化为间隙锁（Gap Lock），以确保查询范围内的所有间隙都被锁定，防止幻读。

当Porduct A不存在时，扫描到第一条不符合条件的二级索引记录，该二级索引的 next-key 锁会退化成间隙锁。

## 非唯一索引的范围查询

非唯一索引范围查询，索引的 next-key lock 不会有退化为间隙锁和记录锁的情况
