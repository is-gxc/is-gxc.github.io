<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>MySQL三大日志(binlog、redo log、undo log)</title>
    <link href="/2024/07/10/MySQL%E4%B8%89%E5%A4%A7%E6%97%A5%E5%BF%97(binlog%E3%80%81redo%20log%E3%80%81undo%20log)/"/>
    <url>/2024/07/10/MySQL%E4%B8%89%E5%A4%A7%E6%97%A5%E5%BF%97(binlog%E3%80%81redo%20log%E3%80%81undo%20log)/</url>
    
    <content type="html"><![CDATA[<p>MySQL的日志有错误日志（Error Log）、查询日志（General Log）、慢查询日志（Slow Query Log）、二进制日志（Binary Log）、中继日志（Relay Log）、重做日志（Redo Log）、撤销日志（Undo Log）等，比较重要的是二进制日志（Binary Log）、重做日志（Redo Log）、撤销日志（Undo Log）。</p><p>需要注意的是，重做日志（Redo Log）和撤销日志（Undo Log）是InnoDB的日志，如果使用的存储引擎不是InnoDB，就不会有这两个日志。</p><h1 id="buffer-pool"><a href="#buffer-pool" class="headerlink" title="buffer pool"></a>buffer pool</h1><p>在介绍日志之前先简单介绍一下buffer pool。</p><p>MySQL的数据是存储在磁盘上的，我们在访问数据时，需要从磁盘读取数据，这个过程是比较慢的，如果在内存上有缓存，访问数据时是从内存读取而不是从磁盘读取，就会快很多。</p><p>buffer pool就是在内存上的缓存。</p><p>buffer pool具有以下特点：</p><ul><li>buffer pool通常以 <strong>页(page)</strong> 为单位缓存数据，其中的页是数据库页面的副本，页的大小通常是固定的（如 InnoDB 的默认页大小为 16KB）</li><li><strong>磁盘读写，并不是按需读取，而是按页读取</strong>，一次至少读一页数据（，如果未来要读取的数据就在页中，就能够省去后续的磁盘IO，提高效率。</li><li>使用特定的页面替换算法（如 LRU，最近最少使用）来决定哪些页应从内存中移出，为新的页腾出空间</li><li>其大小和相关参数可以通过数据库配置进行调整，以适应不同的工作负载和硬件资源。例如，InnoDB 的 buffer pool 大小可以通过参数 <code>innodb_buffer_pool_size</code> 进行配置。</li></ul><p>buffer pool的结构如下：</p><p><img src="https://gxc-hexo-blog.oss-cn-beijing.aliyuncs.com/blog/mysql_buffer_pool.png"></p><ol><li>索引页（Index Pages）</li></ol><p>索引页存储了InnoDB表的索引结构，包括主键索引（聚集索引）和辅助索引（非聚集索引）。这些索引页被加载到缓冲池中，以加速对表中数据的查找和访问。当执行查询操作时，InnoDB会首先检查所需的索引页是否已经在缓冲池中，如果在，则直接从缓冲池中读取，这称为缓冲池命中；如果不在，则需要从磁盘加载到缓冲池中，这称为缓冲池未命中。</p><ol start="2"><li>数据页（Data Pages）</li></ol><p>数据页存储了InnoDB表的实际数据行。在InnoDB中，数据是按页存储的，每个数据页通常包含多行数据。当需要读取或修改表中的数据时，相关的数据页会被加载到缓冲池中。通过将数据页缓存在内存中，InnoDB可以快速地读取和修改数据，而无需每次都从磁盘加载。</p><ol start="3"><li>Undo页（Undo Pages）</li></ol><p>Undo页存储了旧版本的数据，用于支持事务的ACID属性中的隔离性（Isolation）和持久性（Durability）。当执行一个事务时，对数据的修改不会立即生效，而是先记录在Undo页中。如果其他事务需要读取被修改的数据，它可以通过Undo页来获取数据修改前的版本，从而实现多版本并发控制（MVCC）。此外，如果事务失败或回滚，Undo页中的数据可以用于恢复数据到事务开始前的状态。</p><ol start="4"><li>插入缓存（Insert Buffer）</li></ol><p>插入缓存是InnoDB中用于优化非聚集索引插入操作的一种机制。当向一个包含非聚集索引的表中插入数据时，如果相关的索引页不在缓冲池中，InnoDB不会立即将索引键插入到索引页中，而是将其存储在插入缓存中。当相关的索引页被加载到缓冲池时，插入缓存中的索引键会被合并并插入到索引页中。这样可以减少磁盘I&#x2F;O操作，并提高插入操作的性能。</p><p>需要注意的是，插入缓存只适用于非唯一索引的插入操作，并且在某些情况下，如缓冲池足够大或表很小，插入缓存可能不会被使用。</p><ol start="5"><li>自适应哈希索引（Adaptive Hash Index）</li></ol><p>自适应哈希索引是InnoDB存储引擎的一个特性，用于自动根据访问模式创建哈希索引。当某些索引值被频繁访问时，InnoDB会将这些索引值存储在自适应哈希索引中，以加速对这些值的查找。自适应哈希索引是完全自动的，不需要用户手动创建或维护。当哈希索引不再被频繁使用时，InnoDB会自动删除它们以释放内存。</p><ol start="6"><li>InnoDB的锁信息（Lock Information）</li></ol><p>InnoDB存储引擎使用锁来确保并发访问时的数据一致性和完整性。在缓冲池中，InnoDB会维护锁信息，以跟踪哪些数据页或行被锁定，以及锁的类型（如共享锁或排他锁）。这些锁信息对于实现事务的隔离性和并发控制至关重要。当事务尝试访问被其他事务锁定的数据时，它会根据锁的类型和事务的隔离级别来决定是等待锁释放还是立即返回错误。</p><h1 id="redo-log"><a href="#redo-log" class="headerlink" title="redo log"></a>redo log</h1><h2 id="什么是WAL技术"><a href="#什么是WAL技术" class="headerlink" title="什么是WAL技术"></a>什么是WAL技术</h2><p>WAL（Write-Ahead Logging，预写日志）是一种确保数据一致性和可靠性的重要技术，广泛应用于数据库管理系统中。WAL 技术的核心思想是，在将数据更新写入数据库之前，先将这些更新记录到日志文件中。</p><p>具体步骤如下：</p><ol><li><strong>写日志</strong>：在执行数据修改操作之前，首先将这些修改操作记录到 WAL 日志文件中。这些日志条目通常包括事务 ID、修改的表、被修改的行、修改的具体内容等信息。</li><li><strong>写数据</strong>：将实际的数据修改操作应用到数据库中（写入内存中的缓冲区或磁盘上的数据文件）。</li><li><strong>持久化日志</strong>：确保日志文件中的记录被安全地写入磁盘，以防止在系统崩溃时丢失。</li><li><strong>持久化数据</strong>：在适当的时机，将缓冲区中的数据持久化到磁盘上的数据文件中。</li></ol><p>通过先记录日志再执行数据修改，WAL 技术确保了系统在崩溃后能够通过日志进行恢复，保证数据一致性。即使系统在数据写入过程中崩溃，也可以通过重放 WAL 日志中的记录来恢复未完成的事务。</p><h2 id="什么是redo-log"><a href="#什么是redo-log" class="headerlink" title="什么是redo log"></a>什么是redo log</h2><p>上述说明了什么是WAL技术，对应MySQL来说，就是写操作不是立刻写到磁盘上，而是先写日志，然后在合适的时间写到磁盘上。</p><p>redo log 用于记录对数据库的修改操作，确保在系统崩溃后可以通过这些日志进行恢复，使数据库恢复到崩溃前的一致状态。为了防止崩溃、或者断电导致的数据丢失，当有一条记录更新时，InnoDB引擎就会先更新内存（同时标记为脏页），然后将本次对这个页的修改以 redo log的形式记录下来，这时就算更新完成，后续InnoDB引擎会在适当的时候，由后台线程将缓存在buffer poll的脏页刷新到磁盘（这就是WAL技术）。</p><p>redo log是物理日志，记录的是数据页的物理变化。例如，某个事务将某一页中的某个偏移量处的数据从旧值改为新值。</p><p>在事务提交时，只要先将 redo log 持久化到磁盘即可，可以不需要等到将缓存在 Buffer Pool 里的脏页数据持久化到磁盘。</p><p>当系统崩溃时，虽然脏页数据没有持久化，但是 redo log 已经持久化，接着 MySQL 重启后，可以根据 redo log 的内容，将所有数据恢复到最新的状态。</p><h2 id="Redo-Log-的作用"><a href="#Redo-Log-的作用" class="headerlink" title="Redo Log 的作用"></a>Redo Log 的作用</h2><ol><li><strong>数据恢复</strong>：在系统崩溃或硬件故障后，使用 redo log 可以恢复所有已经提交的事务，将数据库恢复到最新的一致状态。</li><li><strong>崩溃恢复</strong>：通过重放 redo log 中的记录，可以将数据库恢复到崩溃前的状态，确保数据的完整性和一致性。</li><li><strong>持久性保证</strong>：redo log 确保事务的持久性（即事务的 ACID 特性中的 Durability），即使在系统崩溃后，已经提交的事务不会丢失。</li></ol><h2 id="redo-log什么时候写入磁盘"><a href="#redo-log什么时候写入磁盘" class="headerlink" title="redo log什么时候写入磁盘"></a>redo log什么时候写入磁盘</h2><p>redo log也有缓存，不是直接写入磁盘，而是写入redo log的缓存——redo log buffer，那redo log什么时候写入磁盘呢？</p><ol><li>MySQL正常关闭时</li><li>checkpoint机制，InnoDB 通过 checkpoint 机制管理 redo log 的使用和重用。当 redo log 文件接近写满时，系统会触发 checkpoint，将内存中的脏页（已修改但未写入磁盘的数据页）写入数据文件，并更新 checkpoint 位置。这使 redo log 文件能够循环重用，并确保系统在崩溃恢复时可以从 checkpoint 开始重做操作。</li><li>每次事务提交时</li></ol><p>在每次事务提交时，会将redo log写入磁盘，但是写入磁盘有三种方式，InnoDB提供了一个关键参数 <code>innodb_flush_log_at_trx_commit</code> 来控制redo log的写入和刷新策略。这个参数有三种设置，每种设置决定了redo log何时写入磁盘：</p><ul><li><p><strong><code>innodb_flush_log_at_trx_commit = 1</code></strong> （默认值）：</p></li><li><p>每次事务提交时，InnoDB 会将 redo log buffer 中的日志条目写入到 redo log 文件，并立即刷新到磁盘。</p></li><li><p>这种设置保证了每个提交的事务都持久化到磁盘，即使系统崩溃，已提交的事务也不会丢失。</p></li><li><p><strong><code>innodb_flush_log_at_trx_commit = 0</code></strong> ：</p></li><li><p>每次事务提交时，redo log buffer 中的日志条目不会立即写入磁盘，而是由后台线程每秒将 redo log buffer 刷新到 redo log 文件。</p></li><li><p>这种设置在系统崩溃时可能会丢失最近一秒内的事务，但可以提高性能，因为减少了磁盘 I&#x2F;O 操作。</p></li><li><p><strong><code>innodb_flush_log_at_trx_commit = 2</code></strong> ：</p></li><li><p>每次事务提交时，InnoDB 会将 redo log buffer 中的日志条目写入到 redo log 文件，但不会立即刷新到磁盘，而是依赖于操作系统的文件系统缓存刷新机制（通常每秒一次）。</p></li><li><p>这种设置在系统崩溃时可能会丢失最近一秒内的事务，但性能介于 <code>innodb_flush_log_at_trx_commit=0</code> 和 <code>innodb_flush_log_at_trx_commit=1</code> 之间。</p></li></ul><p>解释一下<code>innodb_flush_log_at_trx_commit = 2</code>的场景。在计算机操作系统中，用户空间(user space)下的缓冲区数据一般情况下是无法直接写入磁盘的，中间必须经过操作系统内核空间(kernel space)缓冲区(OS Buffer)。因此，redo log buffer &#x2F; undo log buffer写入redo log file &#x2F; undo log file实际上是先写入OS Buffer，然后再通过系统调用fsync()将其刷到redo log file &#x2F; undo log file中。所以在参数等于2的时候，是将日志写入文件，但是不会立刻刷新到磁盘：</p><p><img src="https://gxc-hexo-blog.oss-cn-beijing.aliyuncs.com/blog/mysql_log_fsync.png"></p><h2 id="redo-log组"><a href="#redo-log组" class="headerlink" title="redo log组"></a>redo log组</h2><p><img src="https://gxc-hexo-blog.oss-cn-beijing.aliyuncs.com/blog/redo_log_group.png"></p><p>redo log日志文件不止一个，而是以一个日志文件组出现的，每个redo log日志文件大小都是一样的，比如上图一组有4个文件，每个文件大小1GB，整个redo log日志文件组容量就有4GB。</p><p>日志的文件名字是<code>ib_logfile+编号</code>，比如上图就是<code>ib_logfile0、ib_logfile1……</code></p><p>redo log日志是环形数组的形式，从头开始写，写到末尾就又回到开头。</p><p>日志文件组中有两个重要的属性，分别是：</p><ul><li><code>write pos</code>是当前记录的位置，一边写一遍后移</li><li><code>check point</code>是当前要擦除的位置，也是向后移动</li></ul><p>redo log是为了防止buffer pool中的脏页丢失而设计的，随着系统运行，buffer pool中的脏页刷新到了磁盘上，对应redo log的记录就没用了，这时就可以擦除旧记录，腾出新空间。</p><p>当write pos追上了checkpoint，说明redo log文件满了，这时，MySQL就不能再执行新的更新操作，MySQL就会阻塞（针对并发量大时，适当设置redo log文件大小），此时要停下来将buffer pool中的脏页刷新到磁盘中，然后标记redo log哪些记录可以被擦除，接着要对旧的redo log记录进行擦除，腾出新的空间，checkpoint向后移动，MySQL恢复正常，继续执行更新操作</p><h2 id="redo-log也要写入磁盘，岂不是多余？"><a href="#redo-log也要写入磁盘，岂不是多余？" class="headerlink" title="redo log也要写入磁盘，岂不是多余？"></a>redo log也要写入磁盘，岂不是多余？</h2><p>redo log在写的时候是追加操作，磁盘是<strong>顺序写</strong>，而直接写数据，要先找到数据的位置，然后再写磁盘，是<strong>随机写</strong>。</p><p>所以这是WAL技术的一个有点：将随机写变更顺序写提高性能</p><h1 id="undo-log"><a href="#undo-log" class="headerlink" title="undo log"></a>undo log</h1><p>undo log是回滚日志，用来回滚行记录到某个版本，undo log一般是逻辑日志，根据行的数据变化进行记录，可以简单的理解为：当insert一条记录时，undo log会记录一条对应的delete语句；当update一条语句时，undo log记录的是一条与之操作相反的语句。它保证了事务ACID特性中的原子性(Atomicty)</p><p>undo log跟redo log一样也是在SQL操作数据之前记录的，也就是SQL操作先记录日志，再进行操作数据</p><p>当事务需要回滚时，可以从undo log中找到相应的内容进行回滚操作，回滚后数据恢复到操作之前的状态</p><p>一条记录的每次更新操作产生的undo log都有一个roll_pointer指针和一个trx_id事务id</p><ul><li>通过trx_id可以知道该记录是被那个事务修改的</li><li>roll_pointer指针将这些undo log串成一个链表，这个链表就被成为版本链</li><li>undo log是MVCC实现的关键，通过ReadView + undo log实现MVCC(多版本并发控制)</li></ul><p><img src="https://gxc-hexo-blog.oss-cn-beijing.aliyuncs.com/blog/undo_log_%E7%89%88%E6%9C%AC%E9%93%BE.png"></p><h1 id="binlog"><a href="#binlog" class="headerlink" title="binlog"></a>binlog</h1><p>binlog用于记录所有对数据库进行更改的额操作（例如，数据的插入、更新和删除，不包含查询操作），以及这些操作的顺序。主要用于数据恢复、复制和审计。在事务提交时，将该事务执行过程中产生的所有binlog统一写进binlog文件。</p><p>redo log和binlog都记录了数据库的修改操作，为什么还需要binlog？</p><p>首先看看redo log和binlog的区别</p><table><thead><tr><th></th><th>redo log</th><th>binlog</th></tr></thead><tbody><tr><td>日志种类</td><td>redo log是物理日志，记录的是数据页的物理变化。例如，某个事务将某一页中的某个偏移量处的数据从旧值改为新值</td><td>binlog是逻辑日志，它记录的是对数据库进行的高层次的逻辑操作，例如 SQL 语句的执行，而不是底层数据页的物理变化。</td></tr><tr><td>所处位置</td><td>redo log是InnoDB引擎实现的，是在存储引擎层的，只有使用InnoDB存储引擎时，才会有这个日志</td><td>binglog是server层实现的，所有的存储引擎都会有这个日志</td></tr><tr><td>作用</td><td>redo是物理日志，具有crash-safe能力，用户掉电或者故障恢复</td><td>binlog是逻辑日志，记录的所有逻辑操作，用于备份、主从复制</td></tr><tr><td>写入方式</td><td>循环写，日志大小固定，写满后需要刷脏页腾出空间再能再写</td><td>追加写，写满一个文件就会创建新的文件，保存全量日志</td></tr></tbody></table><h2 id="binlog日志格式"><a href="#binlog日志格式" class="headerlink" title="binlog日志格式"></a>binlog日志格式</h2><p>Binlog 支持三种日志格式，用户可以根据需要进行配置：</p><ul><li><strong>STATEMENT</strong>：记录 SQL 语句。这种方式体积小，但在某些情况下（如含有不确定因素的函数）可能无法精确重放。（STATEMENT 有动态函数的问题，比如你用了 uuid 或者 now 这些函数，你在主库上执行的结果并不是你在从库执行的结果，这种随时在变的函数会导致复制的数据不一致）</li><li><strong>ROW</strong>：记录行级别的变化。每次修改记录的具体行的变化，更加精确，但日志体积较大。比如执行批量 update 语句，更新多少行数据就会产生多少条记录，使 binlog 文件过大，而在 STATEMENT 格式下只会记录一个 update 语句而已</li><li><strong>MIXED</strong>：结合了 STATEMENT 和 ROW 的优点，根据具体情况自动选择日志格式。</li></ul><h2 id="主从复制"><a href="#主从复制" class="headerlink" title="主从复制"></a>主从复制</h2><p><img src="https://gxc-hexo-blog.oss-cn-beijing.aliyuncs.com/blog/mysql_master_slave_copy.png"></p><p>MySQL主从复制依赖binlog。master服务器将数据的改变记录二进制日志，当master上的数据发生改变时，则将其改变写入二进制日志中，salve服务器会在一定时间间隔内对master二进制日志进行探测其是否发生改变，如果发生改变，则开始一个I&#x2F;OThread请求master二进制事件，同时主节点为每个I&#x2F;O线程启动一个dump线程，用于向其发送二进制事件，并保存至从节点本地的中继日志中，从节点将启动SQL线程从中继日志中读取二进制日志，在本地重放，使得其数据和主节点的保持一致，最后I&#x2F;OThread和SQLThread将进入睡眠状态，等待下一次被唤醒。</p><h2 id="binlog刷盘时机"><a href="#binlog刷盘时机" class="headerlink" title="binlog刷盘时机"></a>binlog刷盘时机</h2><img src="https://gxc-hexo-blog.oss-cn-beijing.aliyuncs.com/blog/binlog_cache.png" style="zoom:20%;" /><p>在每次事务执行过程中，会把日志写到缓存（binlog cache）中，提交时，MySQL会根据<code>sync_binlog</code>参数决定是否立刻刷盘。</p><table><thead><tr><th>值</th><th>刷盘频率</th></tr></thead><tbody><tr><td>0</td><td>每次提交事务，只会调用write将日志写入文件，没有经过 fsync()，后续由操作系统决定数据什么时候写入磁盘</td></tr><tr><td>1</td><td>每次事务提交时，MySQL 都会将 Binlog 从缓存中写入到磁盘，并调用 <code>fsync()</code> 确保数据被持久化到磁盘。</td></tr><tr><td>N(N &gt; 1)</td><td>每提交 <code>sync_binlog</code> 次事务才将 Binlog 刷盘一次。</td></tr></tbody></table><p>MySQL中默认是0，这时候性能比较好，但是风险也比较大。一旦机器宕机或者服务崩溃，还没刷到磁盘的数据就没了。</p><p>如果在MySQL出现了性能瓶颈，且瓶颈在IO上，可以将 sync_binlog 设置为大于 1 的值（比较常见是 100~1000）。这样做的风险是，主机掉电时会丢 binlog 日志。</p><h1 id="两阶段提交"><a href="#两阶段提交" class="headerlink" title="两阶段提交"></a>两阶段提交</h1><h2 id="什么是两阶段提交"><a href="#什么是两阶段提交" class="headerlink" title="什么是两阶段提交"></a>什么是两阶段提交</h2><p><strong>两阶段提交（Two-Phase Commit，2PC）</strong> 是一种分布式事务协议，用于确保分布式系统中的多个节点能够一致地执行事务。它通过两个阶段的操作（准备阶段和提交阶段）来确保所有参与节点都能达成一致，要么全部提交事务，要么全部回滚事务。以下是对两阶段提交的详细解释：</p><p>两阶段提交的步骤：</p><p>阶段一：准备阶段（Prepare Phase）</p><ol><li><strong>事务协调者（Transaction Coordinator）</strong> 向所有参与者（Participants）发送准备请求（Prepare Request），询问它们是否可以执行并准备提交事务。</li><li><strong>参与者</strong> 在接收到准备请求后，执行本地事务的预处理操作，但不提交（只是准备好提交）。然后，参与者将预处理的结果（准备好或失败）反馈给事务协调者。</li></ol><p>阶段二：提交阶段（Commit Phase）</p><ol><li><strong>事务协调者</strong> 收集所有参与者的反馈：<ul><li>如果所有参与者都准备好了，事务协调者向所有参与者发送提交请求（Commit Request），要求它们正式提交事务。</li><li>如果任何一个参与者反馈失败，事务协调者向所有参与者发送回滚请求（Rollback Request），要求它们回滚之前的预处理操作。</li></ul></li><li><strong>参与者</strong> 在接收到提交请求后，正式提交事务；在接收到回滚请求后，回滚事务。</li></ol><h2 id="两阶段提交在-MySQL-中的应用"><a href="#两阶段提交在-MySQL-中的应用" class="headerlink" title="两阶段提交在 MySQL 中的应用"></a>两阶段提交在 MySQL 中的应用</h2><p>在 MySQL 中，两阶段提交用于确保 Binlog 和 InnoDB 的事务日志（redo log）的一致性。这种机制确保了在 MySQL 主从复制中，即使在崩溃恢复的情况下，主从服务器的数据也能保持一致。</p><p>MySQL 两阶段提交的具体过程</p><ol><li><p><strong>准备阶段</strong>：</p><ul><li>InnoDB 存储引擎将事务的变更记录写入 redo log，并标记为准备提交（prepare）。</li></ul></li><li><p><strong>提交阶段</strong>：</p><ul><li><p>MySQL 服务器将事务的变更写入 Binlog，如果 Binlog 写入成功，InnoDB 将 redo log 标记为已提交。</p></li><li><p>如果 Binlog 写入失败，InnoDB 将 redo log 回滚。</p></li></ul></li></ol><h2 id="为什么需要两阶段提交"><a href="#为什么需要两阶段提交" class="headerlink" title="为什么需要两阶段提交"></a>为什么需要两阶段提交</h2><p>事务提交后，redo log和binlog都需要持久化到磁盘，但这是两个独立的逻辑，可能出现半成功的状态，造成两份日志的不一致。而redo log影响主库的数据，binlog影响从库的数据，所以redo log和binlog必须保持一致，才能保证主从数据一致。</p>]]></content>
    
    
    <categories>
      
      <category>MySQL</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MySQL</tag>
      
      <tag>数据库</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MySQL锁</title>
    <link href="/2024/07/01/MySQL%E9%94%81/"/>
    <url>/2024/07/01/MySQL%E9%94%81/</url>
    
    <content type="html"><![CDATA[<h1 id="MySQL锁的分类"><a href="#MySQL锁的分类" class="headerlink" title="MySQL锁的分类"></a>MySQL锁的分类</h1><p>根据加锁的范围，可以分为：</p><ul><li>全局锁</li><li>表级锁</li><li>行级锁</li></ul><p>其中表锁种又有：</p><ul><li>表锁</li><li>元数据锁</li><li>意向锁</li><li>AUTO-INC锁</li></ul><p>行锁有：</p><ul><li>记录锁（Record Lock）</li><li>间隙锁（Gap Lock）</li><li>临键锁（Next Key Lock）</li></ul><h1 id="全局锁"><a href="#全局锁" class="headerlink" title="全局锁"></a>全局锁</h1><p>加上全局锁，整个数据库就都是只读状态了。当会话断开后，全局锁会被自动释放。</p><p>一般用于全库逻辑备份。</p><p>加锁：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">flush tables <span class="hljs-keyword">with</span> read lock<br></code></pre></td></tr></table></figure><p>释放锁：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">unlock tables<br></code></pre></td></tr></table></figure><p>慎用！加上全局锁后，整个数据库就都是只读状态，此时业务只能读数据，不能更新数据，可能会造成业务停滞。</p><p>在可重复读的隔离级别下，如果在备份数据库前开启事务，就会创建Read View，在MVCC下，备份期间依然可以对数据进行更新操作，不影响其他事务。在使用mysqldump 进行备份时，加上 <code>–single-transaction</code>就可以开启事务。但是这种方法仅适用于 可重复读隔离级别的事务 的存储引擎。</p><h1 id="表级锁"><a href="#表级锁" class="headerlink" title="表级锁"></a>表级锁</h1><h2 id="表锁"><a href="#表锁" class="headerlink" title="表锁"></a>表锁</h2><p>表锁有两种：共享锁（读锁）、独占锁（写锁）</p><p>示例：对表T加表锁</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">/</span><span class="hljs-operator">/</span>共享锁<br>lock tables T read;<br><span class="hljs-operator">/</span><span class="hljs-operator">/</span>独占锁<br>lock tables T write;<br></code></pre></td></tr></table></figure><p>表锁不但会限制别的线程的读写，还会限制本线程的读写。</p><p>例如，对表T加了 共享锁 ，那么本线程和其他线程接下来的写操作也会被阻塞。</p><p>释放表锁：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">unlock tables;<br></code></pre></td></tr></table></figure><h2 id="元数据锁"><a href="#元数据锁" class="headerlink" title="元数据锁"></a>元数据锁</h2><p>我们不需要显示的使用元数据锁（MDL），因为当我们在对数据库进行操作时，会自动给这个表加上元数据锁（MDL）：</p><ul><li><p>对一张表进行CURD的操作时，加的是MDL读锁</p></li><li><p>对一张表结构进行变更操作的时候，加的是MDL写锁</p></li></ul><p>元数据锁是为了保证一个线程对表进行CURD操作时，另一个线程对表结构进行了变更。</p><p>当我们开启一个事务的时候，就会默认加上元数据锁，当事务提交或者回滚之后，锁才会释放。</p><p>下面看这样一个场景：</p><ul><li>线程a开启了一个事务，一直没有结束，执行的是CURD操作，所以对表加上了MDL读锁</li><li>线程b也开启一个事务，执行CURD操作，此时不会阻塞，因为「读读共享」</li><li>线程c修改表结构，但是由于线程a一直没有提交，线程a的MDL读锁没有释放，就会导致线程c阻塞</li></ul><p>在线程c阻塞之后，后续所有对该表进行CURD的操作都会阻塞。</p><p>因为申请MDL锁会形成一个队列，<strong>写锁优先级高于读锁</strong>，当写锁等待，就会阻塞后续所有的CURD操作。</p><p>所以在对表结构进行变更前，先检查下有没有长事务，若有长事务，考虑kill掉或是等待执行完毕。</p><h2 id="意向锁"><a href="#意向锁" class="headerlink" title="意向锁"></a>意向锁</h2><p>意向锁（Intention Locks）主要目的是为了支持在不同粒度级别上并发控制的需求，即表级锁和行级锁的混合使用。意向锁包括以下几种类型：</p><ol><li><strong>意向共享锁（Intention Shared Lock，IS）</strong>：表示事务想要在表中的某些行上加共享锁。在使用 InnoDB 引擎的表里对某些记录加上「共享锁」之前，需要先在表级别加上一个「意向共享锁」</li><li><strong>意向独占锁（Intention Exclusive Lock，IX）</strong>：表示事务想要在表中的某些行上加独占锁。在使用 InnoDB 引擎的表里对某些纪录加上「独占锁」之前，需要先在表级别加上一个「意向独占锁」</li></ol><p>意向锁的作用是提前在表级别上标记一个事务将要在某些行上进行锁操作，从而避免在表级和行级锁之间产生冲突。具体来说，当一个事务在某行上加锁时，它会首先在表级别上加一个意向锁，以表明它在表中的某些行上持有或计划持有某种锁，当其他事务要加表锁的时候，就可以快速判断是否可以加锁，而不需要扫描整个表的锁信息来确保没有冲突的存在。</p><p>加锁方式</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">/</span><span class="hljs-operator">/</span>先在表上加上意向共享锁，然后对读取的记录加共享锁<br><span class="hljs-keyword">select</span> ... lock <span class="hljs-keyword">in</span> share mode;<br><br><span class="hljs-operator">/</span><span class="hljs-operator">/</span>先表上加上意向独占锁，然后对读取的记录加独占锁<br><span class="hljs-keyword">select</span> ... <span class="hljs-keyword">for</span> <span class="hljs-keyword">update</span>;<br></code></pre></td></tr></table></figure><p>意向锁是表级锁，不会和行级别的共享锁和独占锁发生冲突，但是会和共享表锁、独占表锁发生冲突，具体兼容性如下表：</p><table><thead><tr><th></th><th>IS</th><th>IX</th><th>S</th><th>X</th></tr></thead><tbody><tr><td>IS</td><td>Y</td><td>Y</td><td>Y</td><td>N</td></tr><tr><td>IX</td><td>Y</td><td>Y</td><td>N</td><td>N</td></tr><tr><td>S</td><td>Y</td><td>N</td><td>Y</td><td>N</td></tr><tr><td>X</td><td>N</td><td>N</td><td>N</td><td>N</td></tr></tbody></table><p>举个例子：</p><p>假设有一个表 <code>orders</code>，其中有若干行记录。现在有三个事务同时操作该表：</p><ul><li><strong>事务1</strong> 要读取行1和行2的数据。</li><li><strong>事务2</strong> 要更新行3的数据。</li><li><strong>事务3</strong> 要对整个表进行备份。</li></ul><p>具体的锁操作如下：</p><ol><li>事务1：<ul><li>在表 <code>orders</code> 上加 IS 锁。</li><li>在行1和行2上加 S 锁。</li></ul></li><li>事务2：<ul><li>在表 <code>orders</code> 上加 IX 锁。</li><li>在行3上加 X 锁。</li></ul></li><li>事务3：<ul><li>在表 <code>orders</code> 上加 S 锁（对整个表进行共享访问，可能是备份操作）。</li></ul></li></ol><p><strong>冲突检查过程</strong></p><ul><li><strong>事务1</strong> 和 <strong>事务2</strong> 在表级别加的 IS 锁和 IX 锁是兼容的，可以同时存在。</li><li>当 <strong>事务3</strong> 尝试在表 <code>orders</code> 上加 S 锁时，数据库系统会检查当前表上的锁状态，发现表上已经有 IX 锁（由事务2 持有）。由于 S 锁和 IX 锁是不兼容的，<strong>事务3</strong> 必须等待 <strong>事务2</strong> 释放 IX 锁。</li></ul><h2 id="AUTO-INC锁"><a href="#AUTO-INC锁" class="headerlink" title="AUTO-INC锁"></a>AUTO-INC锁</h2><p>AUTO-INC锁（自动递增锁）是MySQL在使用<code>AUTO_INCREMENT</code>列时为了确保自增值唯一性和顺序性而使用的一种特殊锁。它主要用于控制并发插入操作，以保证每个插入操作都能获得唯一且递增的自增值。</p><p>表里的主键通常都会设置成自增的，这是通过对主键字段声明 <code>AUTO_INCREMENT</code> 属性实现的。之后可以在插入数据时，可以不指定主键的值，数据库会自动给主键赋值递增的值，这主要是通过 <strong>AUTO-INC 锁</strong>实现的。</p><h3 id="AUTO-INC锁的工作原理"><a href="#AUTO-INC锁的工作原理" class="headerlink" title="AUTO-INC锁的工作原理"></a>AUTO-INC锁的工作原理</h3><p>当一个表包含一个<code>AUTO_INCREMENT</code>列时，MySQL在执行插入操作时会申请一个AUTO-INC锁。这个锁的作用是确保在并发插入操作中，每个插入操作获得的自增值都是唯一且按顺序递增的。具体过程如下：</p><ol><li><strong>申请AUTO-INC锁</strong>：<ul><li>当事务要向包含AUTO_INCREMENT列的表插入一行时，首先需要获取AUTO-INC锁。</li></ul></li><li><strong>分配自增值</strong>：<ul><li>获得AUTO-INC锁后，MySQL从当前的自增值计数器中分配一个新的自增值给该插入操作。</li></ul></li><li><strong>释放AUTO-INC锁</strong>：<ul><li>插入操作完成后，事务释放AUTO-INC锁，允许其他事务继续进行插入操作。</li></ul></li></ol><h3 id="AUTO-INC锁的类型和范围"><a href="#AUTO-INC锁的类型和范围" class="headerlink" title="AUTO-INC锁的类型和范围"></a>AUTO-INC锁的类型和范围</h3><ul><li><strong>表级锁</strong>：AUTO-INC锁是表级锁，而不是行级锁。这意味着当一个事务持有AUTO-INC锁时，其他事务不能向同一个表插入数据，直到该锁被释放。</li><li><strong>短期锁</strong>：AUTO-INC锁是短期锁，<strong>仅在分配自增值的过程中持有</strong>。这使得插入操作不会因为等待自增值分配而长期阻塞。</li></ul><h3 id="AUTO-INC锁的并发控制"><a href="#AUTO-INC锁的并发控制" class="headerlink" title="AUTO-INC锁的并发控制"></a>AUTO-INC锁的并发控制</h3><p>AUTO-INC锁通过以下机制控制并发插入操作：</p><ol><li><strong>串行化插入操作</strong>：<ul><li>由于AUTO-INC锁是表级锁，所有向包含AUTO_INCREMENT列的表插入数据的操作在分配自增值时都是串行化的。这确保了自增值的唯一性和顺序性。</li></ul></li><li><strong>减少锁竞争</strong>：<ul><li>AUTO-INC锁是短期锁，仅在分配自增值时持有，插入数据时立即释放。这减少了锁竞争的机会，提高了并发插入操作的效率。</li></ul></li></ol><h1 id="行级锁"><a href="#行级锁" class="headerlink" title="行级锁"></a>行级锁</h1><p>InnoDB引擎是支持行级锁的，MyISAM引擎不支持行级锁。</p><p>由于InnoDB支持行级锁，粒度更细，所以尽量使用行级锁而不是表锁。</p><p>在InnoDB中，由于默认的隔离级别是可重复读，所以支持Read View，读数据属于快照读，不需要加锁，但是也可以使用如下语句进行加锁：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">/</span><span class="hljs-operator">/</span>对读取的记录加共享锁<br><span class="hljs-keyword">select</span> ... lock <span class="hljs-keyword">in</span> share mode;<br><br><span class="hljs-operator">/</span><span class="hljs-operator">/</span>对读取的记录加独占锁<br><span class="hljs-keyword">select</span> ... <span class="hljs-keyword">for</span> <span class="hljs-keyword">update</span>;<br></code></pre></td></tr></table></figure><p>先说行级锁之间的兼容情况</p><table><thead><tr><th></th><th>X</th><th>S</th></tr></thead><tbody><tr><td>X</td><td>N</td><td>N</td></tr><tr><td>S</td><td>N</td><td>Y</td></tr></tbody></table><ul><li>当一个事务对一条记录加了 S 型记录锁后，其他事务也可以继续对该记录加 S 型记录锁（S 型与 S 锁兼容），但是不可以对该记录加 X 型记录锁（S 型与 X 锁不兼容）;</li><li>当一个事务对一条记录加了 X 型记录锁后，其他事务既不可以对该记录加 S 型记录锁（S 型与 X 锁不兼容），也不可以对该记录加 X 型记录锁（X 型与 X 锁不兼容）。</li></ul><p>在 MySQL 的 InnoDB 存储引擎中，行级锁主要包括记录锁（Record Lock）、间隙锁（Gap Lock）和临键锁（Next-Key Lock）。</p><h2 id="记录锁（Record-Lock）"><a href="#记录锁（Record-Lock）" class="headerlink" title="记录锁（Record Lock）"></a>记录锁（Record Lock）</h2><p>记录锁锁定的是索引记录本身，而不是间隙或范围。记录锁通常用于精确锁定某一行数据，以防止其他事务对该行进行并发修改。</p><p>示例：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">START</span> TRANSACTION;<br><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> orders <span class="hljs-keyword">WHERE</span> id <span class="hljs-operator">=</span> <span class="hljs-number">1</span> <span class="hljs-keyword">FOR</span> <span class="hljs-keyword">UPDATE</span>;<br></code></pre></td></tr></table></figure><p>上述查询会对 <code>id = 1</code> 的记录加一个排他锁（X锁），防止其他事务对该行进行修改。</p><h2 id="间隙锁（Gap-Lock）"><a href="#间隙锁（Gap-Lock）" class="headerlink" title="间隙锁（Gap Lock）"></a>间隙锁（Gap Lock）</h2><p>间隙锁锁定的是索引记录之间的间隙，而不是实际的索引记录。间隙锁用于防止其他事务在锁定间隙中插入新的行，以避免幻读现象。</p><p><strong>使用场景：</strong></p><p>间隙锁主要在可重复读（REPEATABLE READ）隔离级别下使用，当执行范围查询并加锁时，InnoDB 会使用间隙锁来锁定查询范围内的间隙。</p><p>示例：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">START</span> TRANSACTION;<br><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> orders <span class="hljs-keyword">WHERE</span> id <span class="hljs-operator">&gt;</span> <span class="hljs-number">5</span> <span class="hljs-keyword">AND</span> id <span class="hljs-operator">&lt;</span> <span class="hljs-number">10</span> <span class="hljs-keyword">FOR</span> <span class="hljs-keyword">UPDATE</span>;<br></code></pre></td></tr></table></figure><p>上述查询将锁定 <code>id</code> 为 5 和 10 之间的所有间隙，防止其他事务在这些间隙中插入新的行。</p><p>间隙锁的目的是防止间隙中插入新的行，所以是可以有多个事务，对同一个间隙加锁的，都是为了保证间隙中不会插入新行</p><h2 id="临键锁（Next-Key-Lock）"><a href="#临键锁（Next-Key-Lock）" class="headerlink" title="临键锁（Next-Key Lock）"></a>临键锁（Next-Key Lock）</h2><p>临键锁是记录锁和间隙锁的组合，用于锁定一个索引记录以及它前面的间隙。这种锁用于防止幻读现象，确保一致性读取。</p><p><strong>使用场景：</strong></p><p>临键锁在范围查询和单行查询中都可以使用，以确保查询范围内的所有记录和间隙都被锁定。</p><p>示例：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">START</span> TRANSACTION;<br><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> orders <span class="hljs-keyword">WHERE</span> id <span class="hljs-operator">=</span> <span class="hljs-number">7</span> <span class="hljs-keyword">FOR</span> <span class="hljs-keyword">UPDATE</span>;<br></code></pre></td></tr></table></figure><p>上述查询将锁定 <code>id = 7</code> 的记录及其前面的间隙。这意味着 <code>id = 7</code> 的记录和从 <code>id = 6</code> 到 <code>id = 7</code> 的间隙都被锁定，防止其他事务对这些区域进行插入、更新或删除操作。</p><p>虽然相同范围的间隙锁是多个事务相互兼容的，但对于记录锁，我们是要考虑 X 型与 S 型关系，X 型的记录锁与 X 型的记录锁是冲突的。</p><h2 id="插入意向锁（Insert-Intention-Lock）"><a href="#插入意向锁（Insert-Intention-Lock）" class="headerlink" title="插入意向锁（Insert Intention Lock）"></a>插入意向锁（Insert Intention Lock）</h2><p>一个事务在插入一条记录的时候，需要判断插入位置是否已被其他事务加了间隙锁（next-key lock 也包含间隙锁）。</p><p>如果有的话，插入操作就会发生<strong>阻塞</strong>，直到拥有间隙锁的那个事务提交为止（释放间隙锁的时刻），在此期间会生成一个<strong>插入意向锁</strong>，表明有事务想在某个区间插入新记录，但是现在处于等待状态。</p><p>插入意向锁名字虽然有意向锁，但是它并<strong>不是意向锁，它是一种特殊的间隙锁，属于行级别锁</strong>。</p><h3 id="插入意向锁的工作原理"><a href="#插入意向锁的工作原理" class="headerlink" title="插入意向锁的工作原理"></a>插入意向锁的工作原理</h3><ol><li><strong>获取间隙锁</strong>：当一个事务尝试在某个索引间隙中插入一条新记录时，它首先会获取一个插入意向锁。这是一个特殊类型的间隙锁，用于表示该事务计划在这个间隙中插入一条记录。</li><li><strong>允许并发插入</strong>：插入意向锁是互相兼容的，这意味着多个事务可以同时在同一个索引间隙中获取插入意向锁。这允许多个插入操作并发进行，而不会互相阻塞。</li><li><strong>实际插入</strong>：当事务实际插入记录时，插入意向锁会升级为插入操作所需的具体锁（如记录锁）。如果插入的位置已经被其他事务锁定（例如，被一个排他锁锁定），插入操作将等待直到锁被释放。</li></ol><h1 id="MySQL是怎样加锁的"><a href="#MySQL是怎样加锁的" class="headerlink" title="MySQL是怎样加锁的"></a>MySQL是怎样加锁的</h1><p>行锁加锁的对象是索引，加锁的基本单位是 next-key lock，它是由记录锁和间隙锁组合而成的，next-key lock是前开后闭区间，而间隙锁是前开后开区间。</p><p>但是在记录锁或者间隙锁就能避免幻读时， next-key lock就会退化成记录锁或者间隙锁。</p><p>加锁位置实在主键索引上的，如果是用二级索引（不管是不是非唯一索引，还是唯一索引）进行锁定读查询的时候，除了会对二级索引项加行级锁（如果是唯一索引的二级索引，加锁规则和主键索引的案例相同），而且还会对查询到的记录的主键索引项上加「记录锁」。</p><p>具体如何退化，以如下四个场景来介绍</p><h2 id="唯一索引等值查询"><a href="#唯一索引等值查询" class="headerlink" title="唯一索引等值查询"></a>唯一索引等值查询</h2><p>如果查询条件是基于唯一索引的等值查询，并且只锁定一行，临键锁会退化为记录锁。</p><p>当查询记录不存在时，在索引树找到第一条大于该查询记录的记录后，该记录的索引中的next-key lock，就会退化成间隙锁。</p><h2 id="唯一索引范围查询"><a href="#唯一索引范围查询" class="headerlink" title="唯一索引范围查询"></a>唯一索引范围查询</h2><p>对于使用唯一索引的范围查询，临键锁可能会退化为记录锁和间隙锁的组合，这取决于查询的具体范围和数据的分布。</p><p>情况一：针对「大于等于」的范围查询，因为存在等值查询的条件，那么如果等值查询的记录是存在于表中，那么该记录的索引中的 next-key 锁会退化成记录锁。</p><p>比如以下语句</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> users <span class="hljs-keyword">where</span> user_id <span class="hljs-operator">&gt;=</span> <span class="hljs-number">12</span>;<br></code></pre></td></tr></table></figure><p>当12存在的时候，对于该记录的临建锁就会退化成记录锁，当12不存在，就会给第一个大于12的值，假如说是13加上临键锁</p><p>情况二：针对「小于或者小于等于」的范围查询，要看条件值的记录是否存在于表中：</p><p>当条件值的记录不在表中，那么不管是「小于」还是「小于等于」条件的范围查询，扫描到终止范围查询的记录时，该记录的索引的 next-key 锁会退化成间隙锁，其他扫描到的记录，都是在这些记录的索引上加 next-key 锁。</p><p>当条件值的记录在表中，如果是「小于」条件的范围查询，扫描到终止范围查询的记录时，该记录的索引的 next-key 锁会退化成间隙锁，其他扫描到的记录，都是在这些记录的索引上加 next-key 锁；如果「小于等于」条件的范围查询，扫描到终止范围查询的记录时，该记录的索引 next-key 锁不会退化成间隙锁。其他扫描到的记录，都是在这些记录的索引上加 next-key 锁</p><h2 id="非唯一索引等值查询"><a href="#非唯一索引等值查询" class="headerlink" title="非唯一索引等值查询"></a>非唯一索引等值查询</h2><p>当查询条件是基于非唯一索引的查询时，InnoDB 通常会使用间隙锁来锁定索引记录之间的间隙，以防止幻读现象。非唯一索引无法精确锁定单个记录，因此需要锁定范围。</p><p>假如现在有表如下</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> orders (<br>    id <span class="hljs-type">INT</span> AUTO_INCREMENT,<br>    product_name <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">255</span>),<br>    quantity <span class="hljs-type">INT</span>,<br>    <span class="hljs-keyword">PRIMARY</span> KEY (id),<br>    INDEX (product_name)<br>);<br></code></pre></td></tr></table></figure><p>现在我们进行非唯一索引查询：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">START</span> TRANSACTION;<br><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> orders <span class="hljs-keyword">WHERE</span> product_name <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;Product A&#x27;</span> <span class="hljs-keyword">FOR</span> <span class="hljs-keyword">UPDATE</span>;<br></code></pre></td></tr></table></figure><p>在这个查询中：</p><ul><li>查询条件使用了非唯一索引 <code>product_name</code>。</li><li>InnoDB 需要锁定 <code>product_name = &#39;Product A&#39;</code> 的所有记录及其前后的间隙，防止其他事务插入新的 <code>product_name = &#39;Product A&#39;</code> 记录。</li><li>临键锁会退化为间隙锁（Gap Lock），以确保查询范围内的所有间隙都被锁定，防止幻读。</li></ul><p>当Porduct A不存在时，扫描到第一条不符合条件的二级索引记录，该二级索引的 next-key 锁会退化成间隙锁。</p><h2 id="非唯一索引的范围查询"><a href="#非唯一索引的范围查询" class="headerlink" title="非唯一索引的范围查询"></a>非唯一索引的范围查询</h2><p>非唯一索引范围查询，索引的 next-key lock 不会有退化为间隙锁和记录锁的情况</p>]]></content>
    
    
    <categories>
      
      <category>MySQL</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MySQL</tag>
      
      <tag>数据库</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MySQL事务</title>
    <link href="/2024/07/01/MySQL%E4%BA%8B%E5%8A%A1/"/>
    <url>/2024/07/01/MySQL%E4%BA%8B%E5%8A%A1/</url>
    
    <content type="html"><![CDATA[<h1 id="什么是事务"><a href="#什么是事务" class="headerlink" title="什么是事务"></a>什么是事务</h1><h2 id="事务的典型场景"><a href="#事务的典型场景" class="headerlink" title="事务的典型场景"></a>事务的典型场景</h2><p>我们在买东西的过程中，会涉及到转账这个动作。</p><p>假如我们要给卖家转账1500元。</p><p>那么这个过程中就涉及到了两个对数据库的操作：</p><ul><li>我们的账户余额减少1500元</li><li>卖家的账户余额增加1500元</li></ul><p>这两个操作是同时成功同时失败的，只要我们的账户余额减少，卖家的账户余额就会增加。</p><p>单独一个操作的成功或失败都是不合理的，比如说我们的账户余额减少了，而卖家的账户余额却没有增加。或者说我们的账户余额没有减少而卖家的账户余额还是增加了，这都是不合理的。</p><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>数据库事务是<strong>访问</strong>并可能<strong>更新</strong>数据库中各种数据项的一个<strong>程序执行单元</strong>，由一个有限的数据库<strong>操作序列</strong>构成。</p><h2 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h2><ol><li>为数据库操作提供了一个<strong>从失败中恢复到正常状态</strong>的方法，同时提供了数据库即使在<strong>异常状态下仍能保持一致性</strong>的方法</li><li>当多个应用程序在并发访问数据库时，可以<strong>在这些应用程序之间提供一个隔离方法，以防止彼此操作相互干扰</strong></li></ol><p><strong>成功情况下：</strong> 能将数据从一种状态变为另外一种状态，并且能够持久化</p><p><strong>异常情况下：</strong></p><ol><li>能将数据恢复到正常状态</li><li>要能保证一致性，包含数据的一致性和约束的一致性</li></ol><p><strong>并发情况下：</strong> 并发的操作之间不能产生相互影响</p><h1 id="事务的使用"><a href="#事务的使用" class="headerlink" title="事务的使用"></a>事务的使用</h1><h2 id="事务的开启"><a href="#事务的开启" class="headerlink" title="事务的开启"></a>事务的开启</h2><p>首先，当我们在执行单条增删改语句时，会自动开启事务并且会自动提交，所以最终写入了磁盘</p><p>或者手动开启事务，两种方式：</p><ol><li>begin</li><li>start transaction</li></ol><h2 id="事务的结束"><a href="#事务的结束" class="headerlink" title="事务的结束"></a>事务的结束</h2><p>首先，如果客户端断开连接了，自然就会结束事务</p><p>或者手动结束事务：</p><ol><li>回滚事务，使用 rollback</li><li>提交事务，使用 commit</li></ol><hr><p><strong>理论有效，实践开始</strong></p><p>首先创建一张表，并插入数据</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> bank(<br>name <span class="hljs-type">varchar</span>(<span class="hljs-number">20</span>),<br>money <span class="hljs-type">decimal</span>(<span class="hljs-number">5</span>,<span class="hljs-number">1</span>)<br>);<br><br> <span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> bank <span class="hljs-keyword">values</span><br> (<span class="hljs-string">&#x27;i&#x27;</span>,<span class="hljs-number">5000</span>),<br> (<span class="hljs-string">&#x27;store&#x27;</span>,<span class="hljs-number">50000</span>); <br><br></code></pre></td></tr></table></figure><p>查询该表就可以看到数据</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> bank;<br><br><span class="hljs-operator">/</span><span class="hljs-operator">/</span> 数据如下<br><span class="hljs-operator">+</span><span class="hljs-comment">-------+--------+</span><br><span class="hljs-operator">|</span>  name <span class="hljs-operator">|</span> money  <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">-------+--------+</span><br><span class="hljs-operator">|</span>   i   <span class="hljs-operator">|</span> <span class="hljs-number">5000</span>   <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">-------+--------+</span><br><span class="hljs-operator">|</span> store <span class="hljs-operator">|</span> <span class="hljs-number">500000</span> <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">-------+--------+</span><br><br></code></pre></td></tr></table></figure><p>那么让我们开启事务并进行转账</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs shell">//开启事务<br>begin;<br>// 成功会提示<br>// Query OK, 0 rows affected (0.00 sec) <br><br>update bank set money=money-1500 where name=&#x27;i&#x27;;<br>//成功会提示<br>//Query OK, 1 row affected (0.00 sec) <br>//Rows matched: 1 Changed: 1 Warnings: 0 <br><br>// 此时打开另一个终端查询表中数据是没有变化的，因为还没有提交<br><br>update bank set money=money+1500 where name=&#x27;store&#x27;;<br><br>// 提交之后在另一个终端就可以看到此时数据才发生变化<br>// 或者此处用 rollback 就可以看到数据不会变化<br>commit;<br></code></pre></td></tr></table></figure><h1 id="事务的特性"><a href="#事务的特性" class="headerlink" title="事务的特性"></a>事务的特性</h1><p>原子性： 事务作为一个整体被执行，包含在其中的对数据库的操作要么全部被执行，要么都不执行</p><p>一致性： 事务应确保数据库的状态从一个一致状态转变为另一个一致状态。一致状态的含义是数据库中的数据应满足完整性约束</p><p>隔离性： 多个事务并发执行时，一个事务的执行不应影响其他事务的执行</p><p>持久性： 一个事务一旦提交，他对数据库的修改应该永久保存在数据库中</p><h2 id="事务的并发异常"><a href="#事务的并发异常" class="headerlink" title="事务的并发异常"></a>事务的并发异常</h2><h3 id="回滚丢失-第一类更新丢失"><a href="#回滚丢失-第一类更新丢失" class="headerlink" title="回滚丢失&#x2F;第一类更新丢失"></a>回滚丢失&#x2F;第一类更新丢失</h3><p>此种更新丢失的是因为回滚的原因，所以也叫回滚丢失</p><table><thead><tr><th>事务A</th><th>事务B</th></tr></thead><tbody><tr><td>查询数据值得到初始值10</td><td>查询数据得到初始值10</td></tr><tr><td>更新为10+1&#x3D;11</td><td>更新为10+2&#x3D;12</td></tr><tr><td>提交</td><td>回滚失败</td></tr><tr><td></td><td>数据回到初始状态10，导致事务A的更新丢失了，由于回滚导致丢失所以叫做回滚丢失</td></tr></tbody></table><h3 id="覆盖丢失-第二类更新丢失"><a href="#覆盖丢失-第二类更新丢失" class="headerlink" title="覆盖丢失&#x2F;第二类更新丢失"></a>覆盖丢失&#x2F;第二类更新丢失</h3><p>此种更新丢失是因为更新被其他事务给覆盖了，也可以叫覆盖丢失</p><table><thead><tr><th>事务A</th><th>事务B</th></tr></thead><tbody><tr><td>查询数据得到初始值10</td><td>查询数据得到初始值10</td></tr><tr><td>更新10+1&#x3D;11</td><td>更新10+2&#x3D;12</td></tr><tr><td>提交</td><td>提交</td></tr><tr><td></td><td>最终结果变为12，由于事务B是从10开始计算的，并不知道数据已经发生了变化，所以导致事务A的更新结果被覆盖了，所以叫覆盖更新</td></tr></tbody></table><h3 id="脏读"><a href="#脏读" class="headerlink" title="脏读"></a>脏读</h3><p>此种异常是因为一个事务读取了，另一个事务修改了但是未提交的数据</p><table><thead><tr><th>事务A</th><th>事务B</th></tr></thead><tbody><tr><td>查询数据得到初始值10</td><td>查询数据得到初始值10</td></tr><tr><td>更新为10+1&#x3D;11</td><td>再次读取数值的到11</td></tr><tr><td></td><td>更新数据11+1&#x3D;12</td></tr><tr><td>回滚</td><td>提交</td></tr><tr><td></td><td>最终数据变为12，由于读取到的数据11被回滚了，结果是错误的，读取到了脏数据</td></tr></tbody></table><h3 id="不可重复读"><a href="#不可重复读" class="headerlink" title="不可重复读"></a>不可重复读</h3><p>一个事务对同一行数据执行了两次或更多次查询，但是却得到了不同的结果</p><table><thead><tr><th>事务A</th><th>事务B</th></tr></thead><tbody><tr><td>查询数据得到初始值10</td><td>查询数据得到初始值10</td></tr><tr><td>更新为10+1&#x3D;11</td><td>再次读取数据得到11</td></tr><tr><td></td><td>在一个事务内两次对同一条数据查询，得到的结果是不同的，因此叫做不可重复读</td></tr></tbody></table><h3 id="幻读"><a href="#幻读" class="headerlink" title="幻读"></a>幻读</h3><p>幻读和不可重复读有点像，只是针对的不是数据的值而是数据的数量</p><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td>事务A</td><td>事务B</td></tr><tr><td>查询数据有11条</td><td>查询数据有11条</td></tr><tr><td>更新全部数据为1</td><td>插入一条数据</td></tr><tr><td>查询结果有1条没被更新，比原来多了一条</td><td></td></tr><tr><td>仿佛全表更新语句不正常，自己出现了幻觉，因此叫幻读</td><td></td></tr></tbody></table><h1 id="事务的隔离级别"><a href="#事务的隔离级别" class="headerlink" title="事务的隔离级别"></a>事务的隔离级别</h1><p><strong>读未提交：</strong> 该隔离级别指即使一个事务更新语句没有提交，但是别的事务可以读到这个改变</p><p><strong>读已提交：</strong> 指一个事务只能看到其他事务的已经提交的更新，看不到未提交的更新，消除了脏读和第一类丢失更新，这是大多数数据库的默认隔离级别，如Oracle SqlServer</p><p><strong>可重复读：</strong> 该隔离级别指一个事务中进行两次或多次同样的对于数据内容的查询，得到的结果是一样的，但不保证对于数据条数的查询是一样的，只要存在读，该行数据就禁止写，消除了不可重复读和第二类更新丢失，这是MySql数据库的默认隔离级别</p><p><strong>串行化：</strong> 事务执行的时候不允许别的事务并发执行，完全串行化的读，只要存在读就禁止写，但可以同时读，消除了幻读。这是事务隔离级别的最高级别。虽然最安全最省心，但是效率太低，一般不会用</p><h2 id="各种隔离级别能解决哪些并发异常"><a href="#各种隔离级别能解决哪些并发异常" class="headerlink" title="各种隔离级别能解决哪些并发异常"></a>各种隔离级别能解决哪些并发异常</h2><table><thead><tr><th>隔离级别 \ 并发异常</th><th>回滚丢失</th><th>脏读</th><th>不可重复读</th><th>覆盖丢失</th><th>幻读</th></tr></thead><tbody><tr><td>读未提交</td><td>×</td><td>×</td><td>×</td><td>×</td><td>×</td></tr><tr><td>读已提交</td><td>√</td><td>√</td><td>×</td><td>×</td><td>×</td></tr><tr><td>可重复读</td><td>√</td><td>√</td><td>√</td><td>√</td><td>×</td></tr><tr><td>串行化</td><td>√</td><td>√</td><td>√</td><td>√</td><td>√</td></tr></tbody></table><h2 id="mysql为什么选择-可重复读-为默认隔离级别"><a href="#mysql为什么选择-可重复读-为默认隔离级别" class="headerlink" title="mysql为什么选择 可重复读 为默认隔离级别"></a>mysql为什么选择 可重复读 为默认隔离级别</h2><p>首先说一些 mysql InnoDB对隔离级别的支持</p><table><thead><tr><th>事务隔离级别</th><th>脏读</th><th>不可重复读</th><th>幻读</th></tr></thead><tbody><tr><td>读未提交（Read Uncommitted）</td><td>可能</td><td>可能</td><td>可能</td></tr><tr><td>读已提交（Read Committed</td><td>不可能</td><td>可能</td><td>可能</td></tr><tr><td><strong>可重复读（Repeatable Read）</strong></td><td>不可能</td><td>不可能</td><td>对InnoDB不可能</td></tr><tr><td>串行化（Serializable）</td><td>不可能</td><td>不可能</td><td>不可能</td></tr></tbody></table><p>InnoDB 支持的四个隔离级别和 SQL92 定义的完全一致，隔离级别越高事务的并发度就越低。唯一的区别就在于，InnoDB在 RR 的级别就解决了幻读的问题。也就是说，不需要使用串行化的隔离级别就可以解决所有问题，既保证了数据的一致性，又支持较高的并发度。这个就是 InnoDB 默认使用 RR 作为事务隔离级别的原因。</p><p>MySQL解决幻读的方案有两种：</p><ul><li>针对<strong>快照读</strong>（普通 select 语句），是<strong>通过 MVCC 方式解决了幻读</strong>，因为可重复读隔离级别下，事务执行过程中看到的数据，一直跟这个事务启动时看到的数据是一致的，即使中途有其他事务插入了一条数据，是查询不出来这条数据的，所以就很好了避免幻读问题。</li><li>针对<strong>当前读</strong>（select … for update 等语句），是<strong>通过 next-key lock（记录锁+间隙锁）方式解决了幻读</strong>，因为当执行 select … for update 语句的时候，会加上 next-key lock，如果有其他事务在 next-key lock 锁范围内插入了一条记录，那么这个插入语句就会被阻塞，无法成功插入，所以就很好了避免幻读问题。</li></ul><h1 id="mysql是如何实现事务的提交、回滚，怎样保证数据的一致性？"><a href="#mysql是如何实现事务的提交、回滚，怎样保证数据的一致性？" class="headerlink" title="mysql是如何实现事务的提交、回滚，怎样保证数据的一致性？"></a>mysql是如何实现事务的提交、回滚，怎样保证数据的一致性？</h1><p>首先说如何实现事务的提交和回滚<br>数据库为了保证事务的原子性和持久性，引入了 redo log和 undo log</p><p>redo log和 undo log包括两部分：一个是内存中的日志缓冲(redo log buffer &#x2F; undo log buffer)，另一个是磁盘上的日志文件(redo log file &#x2F; undo log file)。mysql每执行一条语句，先将记录写入redo log buffer &#x2F; undo log buffer，后续某个时间点再一次性将多个操作记录写到redo log file &#x2F; undo log file。</p><p>在计算机操作系统中，用户空间(user space)下的缓冲区数据一般情况下是无法直接写入磁盘的，中间必须经过操作系统内核空间(kernel space)缓冲区(OS Buffer)。因此，redo log buffer &#x2F; undo log buffer写入redo log file &#x2F; undo log file实际上是先写入OS Buffer，然后再通过系统调用fsync()将其刷到redo log file &#x2F; undo log file中，过程如下<br><img src="https://gxc-hexo-blog.oss-cn-beijing.aliyuncs.com/blog/mysql_log_buffer.png"></p><h2 id="redo-log"><a href="#redo-log" class="headerlink" title="redo log"></a>redo log</h2><p>redo log叫做重做日志，是用来实现事务的持久性。该日志文件由两部分组成：重做日志缓冲（redo log buffer）以及重做日志文件（redo log）,前者是在内存中，后者在磁盘中。当事务提交之后会把所有修改信息都会存到该日志中。</p><p>SQL操作数据库之前，会先记录重做日志，为了保证效率会先写到日志缓冲区中（redo log Buffer），再通过缓冲区写到磁盘文件中进行持久化，既然有缓冲区说明数据不是实时写到redo log file中的，那么假如redo log写到缓冲区后，此时服务器断电了，那redo log岂不是会丢失？</p><p>在MySQL中可以自已控制log buffer刷新到log file中的频率，通过innodb_flush_log_at_trx_commit参数可以设置事务提交时log buffer如何保存到log file中，innodb_flush_log_at_trx_commit参数有3个值(0、1、2)，表示三种不同的方式</p><ul><li>为0表示事务提交时不会将log buffer写入到os buffer中，而是每秒写入os buffer然后调用fsync()方法将日志写入log file，这种方式在MySQL系统崩溃时会丢失大约1秒钟的数据</li><li>为1表示事务每次提交都会将log buffer写入到os buffer，并调用操作系统的fsync()方法将日志写入log file，这种方式的好处是就算MySQL崩溃也不会丢数据，redo log file保存了所有已提交事务的日志，MySQL重新启动后会通过redo log file进行恢复。但这种方式每次提交事务都会写入磁盘，IO性能较差</li><li>为2表示事务每次提交仅将log buffer写入到os buffer中，然后每秒调用fsync()方法将日志写入log file，这种方式在MySQL崩溃时也会丢失大约1秒钟的数据</li></ul><h2 id="undo-log"><a href="#undo-log" class="headerlink" title="undo log"></a>undo log</h2><p>undo log是回滚日志，用来回滚行记录到某个版本，undo log一般是逻辑日志，根据行的数据变化进行记录，可以简单的理解为：当insert一条记录时，undo log会记录一条对应的delete语句；当update一条语句时，undo log记录的是一条与之操作相反的语句</p><p>undo log跟redo log一样也是在SQL操作数据之前记录的，也就是SQL操作先记录日志，再进行操作数据</p><p>当事务需要回滚时，可以从undo log中找到相应的内容进行回滚操作，回滚后数据恢复到操作之前的状态</p><h2 id="保证数据一致性"><a href="#保证数据一致性" class="headerlink" title="保证数据一致性"></a>保证数据一致性</h2><p>如果要解决读一致性的问题，保证一个事务中前后两次读取数据结果一致，实现事务隔离，应该怎么做？</p><p>总体上来说，我们有两大类的方案。</p><p><strong>LBCC</strong><br>既然要保证前后两次读取数据一致，那么我读取数据的时候，锁定我要操作的数据，不允许其他的事务修改就行了。这种方案我们叫做基于锁的并发控制 Lock Based Concurrency Control（LBCC）。</p><p>如果仅仅是基于锁来实现事务隔离，一个事务读取的时候不允许其他时候修改，那就意味着不支持并发的读写操作，而我们的大多数应用都是读多写少的，这样会极大地影响操作数据的效率。</p><p><strong>MVCC</strong><br>如果要让一个事务前后两次读取的数据保持一致，那么我们可以再修改数据之前给它建立一个备份或者叫快照，后面再来读取这个快照就行了。这种方案我们叫做多版本的并发控制 Multi Version Concurrency Control（MVCC）。</p><p>MVCC只在 读已提交和可重复读两个隔离级别下工作。其他两个隔离级别和MVCC不兼容，因为 读未提交总是读取最新的数据行，而不是符合当前事务版本的数据行。而串行化则会对所有读取的行都加锁。</p><p>聚簇索引记录中有两个必要的隐藏列：</p><ul><li><p>trx_id：用来存储每次对某条聚簇索引记录进行修改的时候的事务id</p></li><li><p>roll_pointer：每次对哪条聚簇索引记录有修改的时候，都会把老版本写入 undo 日志中。这个roll_pointer就是存了一个指针，它指向这条聚簇索引记录的上一个版本的位置，通过它来获得上一个版本的记录信息（注意插入操作的 undo操作日志没有这个属性，因为它没有老版本）</p></li></ul><p>MVCC 的原则：<br>一个事务能看到的数据版本：</p><ul><li>第一次查询之前已经提交的事务的修改</li><li>本事务的修改</li></ul><p>一个事务不能看到的数据版本：</p><ul><li>在本事务第一次查询之后创建的事务（事务 ID 比我的事务 ID 大）</li><li>活跃的（未提交的）事务的修改</li></ul><p>MVCC 的效果：我可以查到在我这个事务开始之前已经存在的数据，即使它在后面被修改或者删除了。而在我这个事务之后新增的数据，我是查不到的。</p><p>所以我们才把这个叫做快照，不管别的事务做任何增删改查的操作，它只能看到第一次查询时看到的数据版本。</p><blockquote><p>这个快照是怎么实现的呢？会不会占用额外的存储空间？</p></blockquote><p>下面我们来分析一下 MVCC 的原理。首先，InnoDB的事务都是有编号的，而且会不断递增。</p><p>InnoDB 为每行记录都实现了两个隐藏字段：</p><ul><li><p>DB_TRX_ID（6字节）：事务ID，数据是在哪个事务插入或者修改为新数据的，就记录为当前事务 ID。</p></li><li><p>DB_ROLL_PTR（7字节）：回滚指针（我们把它理解为删除版本号，数据被删除或记录为旧数据的时候，记录当前事务ID，没有修改或者删除的时候是空，注意插入操作的 undo操作日志没有这个属性，因为它没有老版本）</p></li></ul><p>拿个栗子来说，现在有一张表</p><table><thead><tr><th>id</th><th>name</th><th>DB_TRX_ID</th><th>DB_ROLL_PTR</th></tr></thead><tbody><tr><td></td><td></td><td></td><td></td></tr></tbody></table><p>第一个事务，初始化数据</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">begin</span>;<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> mvcctest <span class="hljs-keyword">values</span>(<span class="hljs-number">1</span>,<span class="hljs-string">&#x27;qingshan&#x27;</span>);<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> mvcctest <span class="hljs-keyword">values</span>(<span class="hljs-number">2</span>,<span class="hljs-string">&#x27;huihui&#x27;</span>);<br><span class="hljs-keyword">commit</span>;<br></code></pre></td></tr></table></figure><p>此时的数据，创建版本是当前事务ID（假设事务编号是1），删除版本为空</p><table><thead><tr><th>id</th><th>name</th><th>创建版本</th><th>删除版本</th></tr></thead><tbody><tr><td>1</td><td>唐三藏</td><td>1</td><td>undefined</td></tr><tr><td>2</td><td>孙悟空</td><td>1</td><td>undefined</td></tr></tbody></table><p>第二个事务，执行第一次查询，读取到两条原始数据，这个时候事务ID是2</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">begin</span>;<br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> mvcctest;  <span class="hljs-operator">/</span><span class="hljs-operator">/</span> 第一次查询<br></code></pre></td></tr></table></figure><p>第三个事务，插入数据</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">begin</span>;<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> mvcctest <span class="hljs-keyword">values</span>(<span class="hljs-number">3</span>,<span class="hljs-string">&#x27;猪八戒&#x27;</span>);<br><span class="hljs-keyword">commit</span>;<br></code></pre></td></tr></table></figure><p>此时的数据，多了一条猪八戒，他的创建版本号是当前事务id（3）</p><table><thead><tr><th>id</th><th>name</th><th>创建版本</th><th>删除版本</th></tr></thead><tbody><tr><td>1</td><td>唐三藏</td><td>1</td><td>undefined</td></tr><tr><td>2</td><td>孙悟空</td><td>1</td><td>undefined</td></tr><tr><td>3</td><td>猪八戒</td><td>3</td><td>undefined</td></tr></tbody></table><p>第二个事务，执行第二次查询</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> mvcctest;  <span class="hljs-operator">/</span><span class="hljs-operator">/</span> 第二次查询<br></code></pre></td></tr></table></figure><p>MVCC的查询规则：只能查找创建时间小于等于当前事务 ID 的数据，和删除时间大于当前事务 ID 的行（或未删除）。</p><p>也就是不能查到在我的事务开始之后插入的数据，猪八戒 的创建 ID 大于 2，所以还是只能查到两条数据。</p><p>第四个事务，删除数据，删除 id&#x3D;2，孙悟空这条记录</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">begin</span>;<br><span class="hljs-keyword">delete</span> <span class="hljs-keyword">from</span> mvcctest <span class="hljs-keyword">where</span> id<span class="hljs-operator">=</span><span class="hljs-number">2</span>;<br><span class="hljs-keyword">commit</span>;<br></code></pre></td></tr></table></figure><p>此时的数据，孙悟空 的删除版本被记录为当前事务 ID （4），其他数据不变：</p><table><thead><tr><th>id</th><th>name</th><th>创建版本</th><th>删除版本</th></tr></thead><tbody><tr><td>1</td><td>唐三藏</td><td>1</td><td>undefined</td></tr><tr><td>2</td><td>孙悟空</td><td>1</td><td>4</td></tr><tr><td>3</td><td>猪八戒</td><td>3</td><td>undefined</td></tr></tbody></table><p>在第二个事务中，执行第 3 次查询：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> mvcctest;  <span class="hljs-operator">/</span><span class="hljs-operator">/</span>第三次查询<br></code></pre></td></tr></table></figure><p>查找规则：只能查找创建时间小于等于当前事务 ID 的数据，和删除时间大于当前事务 ID 的行（或未删除）。</p><p>也就是，在我事务开始之后删除的数据，所以 孙悟空 依然可以查出来。所以还是这两条数据。</p><p>第五个事务，执行更新操作，这个事务 ID 是5：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">begin</span>;<br><span class="hljs-keyword">update</span> mvcctest <span class="hljs-keyword">set</span> name<span class="hljs-operator">=</span><span class="hljs-string">&#x27;杨过&#x27;</span> <span class="hljs-keyword">where</span> id<span class="hljs-operator">=</span><span class="hljs-number">1</span>;<br><span class="hljs-keyword">commit</span>;<br></code></pre></td></tr></table></figure><p>此时的数据，更新数据的时候，旧数据的删除版本被记录为当前事务 ID （5）（undo），产生了一条新数据，创建 ID 为当前事务 ID 5：</p><table><thead><tr><th>id</th><th>name</th><th>创建版本</th><th>删除版本</th></tr></thead><tbody><tr><td>1</td><td>唐三藏</td><td>1</td><td>5</td></tr><tr><td>2</td><td>孙悟空</td><td>1</td><td>4</td></tr><tr><td>3</td><td>猪八戒</td><td>3</td><td>undefined</td></tr><tr><td>1</td><td>杨过</td><td>5</td><td>undefined</td></tr></tbody></table><p>第二个事务，执行第 4 次查询：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> mvcctest;  <span class="hljs-operator">/</span><span class="hljs-operator">/</span>第四次查询<br></code></pre></td></tr></table></figure><p>查找规则：只能查找创建时间小于等于当前事务 ID 的数据，和删除时间大于当前事务 ID 的行（或未删除）。</p><p>因为更新后的数据 杨过 创建版本大于 2，代表是在事务之后增加的，查不出来。</p><p>而旧数据 孙悟空 的删除版本大于 2，代表是在事务之后删除的，可以查出来。</p><p>通过以上演示我们能看到，通过版本号的控制，无论其他事务是插入、修改、删除，第一个事务查询到的数据都没有变化。这个就是 MVCC 的效果。</p><p>回想一下MVCC规则：<br>一个事务能看到的数据版本：</p><ol><li>第一次查询之前已经提交的事务的修改</li><li>本事务的修改</li></ol><p>一个事务不能看见的数据版本：</p><ul><li>在本事务第一次查询之后创建的事务（事务 ID 比我的事务 ID 大）</li><li>活跃的（未提交的）事务的修改</li></ul><p>所以，我们必须要有一个数据结构，把本事务 ID、活跃事务 ID、当前系统最大事务 ID 存起来，这样才能实现判断。这个数据结果就叫 Read View（可见性视图），每个事务都维护一个自己的 Read View。</p><p><strong>m_ids：</strong> 表示在生成 ReadView 时，当前系统中活跃的读写事务的事务 id 列表。</p><p>min_trx_id： 表示在生成 ReadView 时，当前系统中活跃的读写事务中最小的事务 id，也就是 m_ids 中的最小值。</p><p><strong>max_trx_id：</strong> 表示生成 ReadView 时，系统中应该分配给下一个事务的 id 值。</p><p><strong>creator_trx_id：</strong> 表示生成该 ReadView 的事务的事务 id。</p><p>有了这个数据结构之后，事务判断可见性的规则是这样的：</p><ol><li>从数据的最早版本开始（undo log）。</li><li>数据版本的 trx_id &#x3D; creator_trx_id，本事务修改，可以访问。</li><li>数据版本的 trx_id &lt; min_trx_id（未提交事务的最小 ID），说明这个版本在生成 ReadView 已经提交，可以访问。</li><li>数据版本的 trx_id &gt; max_trx_id（下一个事务 ID），这个版本是生成 ReadView 之后才开启的事务建立的，不能访问。</li><li>数据版本的 trx_id 在 min_trx_id 和 max_trx_id 之间，看看是否在 m_ids 中。如果在，不可以。如果不在，可以。</li><li>如果当前版本不可见，就找 undo log 链中的下一个版本。</li></ol><p><strong>注意：</strong> RR 中 Read View 是事务第一次查询的时候建立的。RC 的 Read View 是事务每次查询的时候建立的。</p>]]></content>
    
    
    <categories>
      
      <category>MySQL</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MySQL</tag>
      
      <tag>数据库</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MySQL索引</title>
    <link href="/2024/06/24/MySQL%E7%B4%A2%E5%BC%95/"/>
    <url>/2024/06/24/MySQL%E7%B4%A2%E5%BC%95/</url>
    
    <content type="html"><![CDATA[<h1 id="什么是索引"><a href="#什么是索引" class="headerlink" title="什么是索引"></a>什么是索引</h1><p>当我们想查找书籍中特定的内容时就会想到，去翻目录，就能快速找到目标内容。书籍的目录就是<strong>索引</strong></p><p>在数据库中，索引的定义就是帮助存储引擎快速获取数据的一种数据结构，形象的说就是<strong>索引是数据的目录</strong></p><h1 id="InnoDB索引模型"><a href="#InnoDB索引模型" class="headerlink" title="InnoDB索引模型"></a>InnoDB索引模型</h1><p>在 InnoDB 中，表都是根据主键顺序以索引的形式存放的，这种存储方式的表称为索引组织表。InnoDB 使用了 B+ 树索引模型，所以数据都是存储在 B+ 树中的。</p><p>这里顺带说一下InnoDB的表结构：</p><ol><li>在 InnoDB 中，每一张表其实就是多个 B+ 树，即一个主键索引树和多个非主键索引树。</li><li>执行查询的效率，使用主键索引 &gt; 使用非主键索引 &gt; 不使用索引。</li><li>如果不使用索引进行查询，则从主索引 B+ 树的叶子节点进行遍历。</li></ol><p>每一个索引在 InnoDB 里面对应一棵 B+ 树。索引名称对应所有索引记录，对应一棵B+树，而不是单条记录。</p><p>假设现有一张表如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> T(<br>id <span class="hljs-type">bigint</span> <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span> auto_increment <span class="hljs-keyword">primary</span> key,<br>  name <span class="hljs-type">varchar</span>(<span class="hljs-number">32</span>) <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span> <span class="hljs-keyword">default</span> <span class="hljs-string">&#x27;&#x27;</span>,<br>  age <span class="hljs-type">int</span> <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span> <span class="hljs-keyword">default</span> <span class="hljs-number">0</span>,<br>  index idx_age(age)<br>)engine<span class="hljs-operator">=</span>InnoDB;<br></code></pre></td></tr></table></figure><p>表中 R1~R5 的 (id,age) 值分别为 (100,1)、(200,2)、(300,3)、(500,5) 和 (600,6)，两棵树的示例示意图如下。</p><p><img src="https://gxc-hexo-blog.oss-cn-beijing.aliyuncs.com/blog/mysql_index_model.png"></p><p>根据叶子结点的内容，索引类型分为了主键索引和非主键索引。</p><p>主键索引的叶子节点存的是整行数据。在 InnoDB 里，主键索引也被称为聚簇索引（clustered index）。 key:主键的值，value:整行数据。</p><p>非主键索引的叶子节点内容是主键的值。在 InnoDB 里，非主键索引也被称为二级索引（secondary index）。 key：索引列的值， value:主键的值。</p><p>基于逐渐索引和普通索引的查询有什么区别呢？</p><ul><li>如果语句是 <code>select * from T where id=100</code>，当使用主键索引进行查询的时候，只需要搜索id这颗b+树</li><li>如果语句是 <code>select * from T where age=3</code>，当使用普通索引查询时，先要搜索age索引树，查询到id为300，在用id索引树查到一次，这个过程称为<strong>回表</strong>（如果语句为 <code>select id from T where age=3</code>，这种在二级索引的B+tree就能查询到结果的过程就叫做<strong>覆盖索引</strong>，也就是只需要查一个B+tree就能找到数据）</li></ul><p>所以，基于非主键索引的查询需要多扫描一棵索引树。因此，我们应用中应该多使用主键查询。</p><h1 id="索引维护"><a href="#索引维护" class="headerlink" title="索引维护"></a>索引维护</h1><p>B+树为了维护索引的有序性，在插入新值的时候需要做必要的维护。以上图为例，如果插入的值是700，则只要在R5的记录后边插入一个新纪录。如果新插入的值是400，就麻烦了，需要逻辑上挪动后边的数据，空出位置。</p><p>而更糟的情况是，如果 R5 所在的数据页已经满了，根据 B+ 树的算法，这时候需要申请一个新的数据页，然后挪动部分数据过去。这个过程称为页分裂。在这种情况下，性能自然会受影响。</p><p>除了性能外，页分裂操作还影响数据页的利用率。原本放在一个页的数据，现在分到两个页中，整体空间利用率降低大约 50%。</p><p>当然有分裂就有合并。当相邻两个页由于删除了数据，利用率很低之后，会将数据页做合并。合并的过程，可以认为是分裂过程的逆过程。</p><p>在很多规范里边，都要求建表语句一定要有自增主键，但是事无绝对，也有一些场景不需要。</p><p>自增主键是指自增列上定义的主键，在建表语句中一般是这么定义的： NOT NULL PRIMARY KEY AUTO_INCREMENT。</p><p>插入新记录的时候可以不指定 ID 的值，系统会获取当前 ID 最大值加 1 作为下一条记录的 ID 值。</p><p>也就是说，自增主键的插入数据模式，正符合了我们前面提到的递增插入的场景。每次插入一条新记录，都是追加操作，都不涉及到挪动其他记录，也不会触发叶子节点的分裂。</p><p>而有业务逻辑的字段做主键，则往往不容易保证有序插入，这样写数据成本相对较高。除了考虑性能外，我们还可以从存储空间的角度来看。假设你的表中确实有一个唯一字段，比如字符串类型的身份证号，那应该用身份证号做主键，还是用自增字段做主键呢？由于每个非主键索引的叶子节点上都是主键的值。如果用身份证号做主键，那么每个二级索引的叶子节点占用约 20 个字节，而如果用整型做主键，则只要 4 个字节，如果是长整型（bigint）则是 8 个字节。</p><p><strong>显然，主键长度越小，普通索引的叶子节点就越小，普通索引占用的空间也就越小。</strong></p><p>所以从性能和存储空间上分析，自增主键往往更合理。</p><p>但是，假如有的需求场景如下：</p><ul><li>只有一个索引</li><li>索引必须是唯一索引</li></ul><p>此时就是一个kv场景，由于没有其他索引，也不用考虑其他索引叶子结点的大小问题，这时候查询就用到<code>尽量使用主键查询</code>的原则，直接将这个索引设置为主键，避免为此搜索两棵树。</p><h1 id="索引的分类"><a href="#索引的分类" class="headerlink" title="索引的分类"></a>索引的分类</h1><p>上面大概介绍了下索引，对索引有了大致了解后，从 数据结构、物理存储、字段特性、字段个数 四个方面看看都有哪些索引</p><ul><li>数据结构：B+tree索引、Hash索引、Full-text索引</li><li>物理存储：聚簇索引（主键索引）、二级索引（辅助索引）</li><li>字段特性：主键索引、唯一索引、普通索引、前缀索引</li><li>字段个数：单列索引、联合索引</li></ul><h2 id="按数据结构分类"><a href="#按数据结构分类" class="headerlink" title="按数据结构分类"></a>按数据结构分类</h2><p>从数据结构分类上看，常见的有B+tree索引、Hash索引、Full-text索引灯</p><p>每一种存储引擎支持的索引类型不一定相同，具体如下表：</p><table><thead><tr><th>索引类型</th><th>InnoDB引擎</th><th>MyISAM引擎</th><th>Memory引擎</th></tr></thead><tbody><tr><td>B+tree索引</td><td>Yes</td><td>Yes</td><td>Yes</td></tr><tr><td>Hash索引</td><td>No（不支持hash索引，但是在内存结构中有一个自适应的hash索引）</td><td>No</td><td>Yes</td></tr><tr><td>Full-text索引</td><td>Yes（MySQL 5.6版本后支持）</td><td>Yes</td><td>No</td></tr></tbody></table><p>InnoDB在MySQL5.5之后成为默认的存储引擎，B+tree索引类型也是MySQL存储引擎采用最多的索引类型</p><p>在创建表时，InnoDB 存储引擎会根据不同的场景选择不同的列作为索引：</p><ul><li>如果有主键，默认会使用主键作为聚簇索引的索引键（key）</li><li>如果没有主键，就选择第一个不包含 NULL 值的唯一列作为聚簇索引的索引键（key）</li><li>在上面两个都没有的情况下，InnoDB 将自动生成一个隐式自增 id 列作为聚簇索引的索引键（key）</li></ul><p>其它索引都属于辅助索引（Secondary Index），也被称为二级索引或非聚簇索引。<strong>创建的主键索引和二级索引默认使用的是 B+Tree 索引</strong>。</p><p>数据库的索引和数据都是存储在硬盘的，我们可以把读取一个节点当作一次磁盘 I&#x2F;O 操作。B+Tree 存储千万级的数据只需要 3-4 层高度就可以满足，这意味着从千万级的表查询目标数据最多需要 3-4 次磁盘 I&#x2F;O，所以<strong>B+Tree 相比于 B 树和二叉树来说，最大的优势在于查询效率很高，因为即使在数据量很大的情况，查询一个数据的磁盘 I&#x2F;O 依然维持在 3-4次。</strong></p><p>为什么MySQL选择B+tree作为索引的数据结构呢？</p><p><strong>1、B+Tree vs B Tree</strong></p><p>B+Tree 只在叶子节点存储数据，而 B 树 的非叶子节点也要存储数据，所以 B+Tree 的单个节点的数据量更小，在相同的磁盘 I&#x2F;O 次数下，就能查询更多的节点。</p><p>另外，B+Tree 叶子节点采用的是双链表连接，适合 MySQL 中常见的基于范围的顺序查找，而 B 树无法做到这一点。</p><p><strong>2、B+Tree vs 二叉树</strong></p><p>对于有 N 个叶子节点的 B+Tree，其搜索复杂度为<code>O(logdN)</code>，其中 d 表示节点允许的最大子节点个数为 d 个。</p><p>在实际的应用当中， d 值是大于100的，这样就保证了，即使数据达到千万级别时，B+Tree 的高度依然维持在 3~4 层左右，也就是说一次数据查询操作只需要做 3~4 次的磁盘 I&#x2F;O 操作就能查询到目标数据。</p><p>而二叉树的每个父节点的儿子节点个数只能是 2 个，意味着其搜索复杂度为 <code>O(logN)</code>，这已经比 B+Tree 高出不少，因此二叉树检索到目标数据所经历的磁盘 I&#x2F;O 次数要更多。</p><p><strong>3、B+Tree vs Hash</strong></p><p>Hash 在做等值查询的时候效率贼快，搜索复杂度为 O(1)。</p><p>但是 Hash 表不适合做范围查询，它更适合做等值的查询，这也是 B+Tree 索引要比 Hash 表索引有着更广泛的适用场景的原因。</p><h2 id="按物理存储分类"><a href="#按物理存储分类" class="headerlink" title="按物理存储分类"></a>按物理存储分类</h2><p>在物理存储上，索引可以分为聚簇索引（主键索引）、二级索引（辅助索引）</p><p>这两个区别在前面也提到了：</p><ul><li>主键索引的 B+Tree 的叶子节点存放的是实际数据，所有完整的用户记录都存放在主键索引的 B+Tree 的叶子节点里；</li><li>二级索引的 B+Tree 的叶子节点存放的是主键值，而不是实际数据。</li></ul><p>所以，在查询时使用了二级索引，如果查询的数据能在二级索引里查询的到，那么就不需要回表，这个过程就是覆盖索引。如果查询的数据不在二级索引里，就会先检索二级索引，找到对应的叶子节点，获取到主键值后，然后再检索主键索引，就能查询到数据了，这个过程就是回表。</p><h2 id="按字段特性分类"><a href="#按字段特性分类" class="headerlink" title="按字段特性分类"></a>按字段特性分类</h2><p>从字段特性上看，索引可以分为 主键索引、唯一索引、普通索引、前缀索引</p><h3 id="主键索引"><a href="#主键索引" class="headerlink" title="主键索引"></a>主键索引</h3><p>主键索引就是一张表的主键上的索引，一张表只能有一个主键索引，主键列的值非空且唯一。</p><h3 id="唯一索引"><a href="#唯一索引" class="headerlink" title="唯一索引"></a>唯一索引</h3><p>唯一索引也就是 <code>UNIQUE</code>字段上的索引，一张表可以有多个唯一索引，但是唯一索引的每一列的值，都必须唯一</p><h3 id="普通索引"><a href="#普通索引" class="headerlink" title="普通索引"></a>普通索引</h3><p>普通索引是在普通字段上的索引，不要求字段为主键也不要求字段为<code>UNIQUE</code></p><h3 id="前缀索引"><a href="#前缀索引" class="headerlink" title="前缀索引"></a>前缀索引</h3><p>前缀索引是指对字符类型的前几个字符建立的索引，前缀索引可以建立在字段类型为 char、varchar、binary、varbinary、blob、text的列上</p><h2 id="按字段个数分类"><a href="#按字段个数分类" class="headerlink" title="按字段个数分类"></a>按字段个数分类</h2><p>从字段个数上，索引可以分为单列索引、联合索引</p><p><strong>联合索引</strong>：将多个字段组合成一个索引即为联合索引</p><p>现在将课程表中的课程id和课程名组成联合索引(class_id, class_name)，联合索引的b+tree示意图如下</p><p><img src="https://gxc-hexo-blog.oss-cn-beijing.aliyuncs.com/blog/index_tree.png"></p><p>如图，联合索引的非叶子结点用两个字段的值作为b+tree的key值。当联合索引查询数据时，先按<code>class_id</code>字段进行比较，在<code>class_id</code>字段相同的情况下再按照<code>class_name</code>字段进行比较。即，联合索引查询时，先按<code>class_id</code>进行排序，再按照<code>class_name</code>进行排序。</p><p>因此，在使用联合索引时，存在<strong>最左匹配原则</strong>，也就是按照最左优先的方式进行索引的匹配。在使用联合索引进行查询的时候，如果不遵循<strong>最左匹配原则</strong>，联合索引就会失效。</p><h1 id="索引失效的情况"><a href="#索引失效的情况" class="headerlink" title="索引失效的情况"></a>索引失效的情况</h1><p>使用索引失效有6种情况</p><ul><li>当使用 左 或者 左右 模糊匹配时，也就是<code>like %xxx</code>或者<code>linke %xxx%</code>这两种方式都会造成索引失效</li><li>在查询条件中对索引列使用函数</li><li>在查询条件中对表达式进行计算</li><li>MySQL遇到字符串和数字比较时，会自动吧字符串转为数字，然后进行比较。如果字符串是索引列，那么就会发生隐式类型转换，由于隐式类型转换是通过 CAST 函数实现的，等同于对索引列使用了函数，所以就会导致索引失效。</li><li>联合索引中未正确遵循最左匹配原则</li><li>WHERE字句中，如果在 OR 前的条件列是索引列，而在 OR 后的条件列不是索引列，那么索引会失效。</li></ul><h2 id="对索引使用左或者左右模糊匹配"><a href="#对索引使用左或者左右模糊匹配" class="headerlink" title="对索引使用左或者左右模糊匹配"></a>对索引使用左或者左右模糊匹配</h2><p>由于索引B+树是按照索引值有序排列存储的，只能根据前缀进行比较</p><p>假设现在有二级索引的B+树结构如下图所示</p><p><img src="https://gxc-hexo-blog.oss-cn-beijing.aliyuncs.com/blog/%E4%BA%8C%E7%BA%A7%E7%B4%A2%E5%BC%95.png"></p><p>假如现在要查询name字段前缀为 宝 的数据，即<code>name like &#39;%宝&#39;</code>，扫描索引过程如下：</p><ul><li>在根节点查询，宝这个字的拼音大小比根节点第一个索引的爱大，但是比第二个康小，所以走到二层的节点</li><li>在二层的节点查询，首字爱比宝小，第二个索引宝岛与之匹配，所以走到宝岛的叶子节点查询，即叶子节点的所在层的第二个</li><li>发现第一个索引值的前缀是宝字，与前缀匹配，于是读取该行，接着继续向右匹配，知道匹配不到宝字前缀的索引值</li></ul><p>如果使用<code>name like &#39;%宝&#39;</code>方式来查询，结果可能是 宝岛、宝贝、宝宝 等，所以不知道从哪里开始比较，于是就走了全表扫描的</p><h2 id="对索引使用函数"><a href="#对索引使用函数" class="headerlink" title="对索引使用函数"></a>对索引使用函数</h2><p>因为索引保存的是索引字段的原始值，而不是经过函数计算后的值，所以没办法走索引。</p><p>比如如下的sql</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> product <span class="hljs-keyword">where</span> length(name)<span class="hljs-operator">=</span><span class="hljs-number">3</span>;<br></code></pre></td></tr></table></figure><p>这里需要全表扫描name字段，判断长度是否等于3</p><h2 id="对索引进行表达式计算"><a href="#对索引进行表达式计算" class="headerlink" title="对索引进行表达式计算"></a>对索引进行表达式计算</h2><p>如下这个sql，在执行时也是进行了全表扫描</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> product <span class="hljs-keyword">where</span> price <span class="hljs-operator">+</span><span class="hljs-number">35</span> <span class="hljs-operator">=</span> <span class="hljs-number">100</span>;<br></code></pre></td></tr></table></figure><p>但是如果略作修改，把条件改成  <code>where price = 100-35</code> 就可以走索引了，为什么？</p><p>因为当条件是 <code>price+35 = 100</code>时，需要全表扫描，逐个去判断，那个price+35能等于100。但是当条件改为了<code>price = 100-35</code>的时候，mysql会进行计算，然后再判断 price &#x3D; 65。</p><h2 id="对索引隐式类型转化"><a href="#对索引隐式类型转化" class="headerlink" title="对索引隐式类型转化"></a>对索引隐式类型转化</h2><p>如果索引是字段是字符串类型，但是在条件查询中，输入的参数是整型，最后就会走全表扫描。</p><p>但是如果索引的字段是整型，输入的参数是字符串，还是会走索引。</p><p>因为MySQL在遇到字符串和数字进行比较的时候，会自动把字符串转为数字，然后再进行比较。</p><p>MySQL的CAST函数可以修改类型。</p><p>当索引字段是字符串类型，输入参数是整型时，会把索引字段转为整型，相当于给索引字段用了CAST函数，而如上所说，<strong>对索引使用函数会导致索引失效</strong></p><p>当索引字段是整型，而输入参数是字符串时，会把字符串转为整型，相当于给入参使用了CAST函数，不影响索引，所以还是会走索引扫描。</p><h2 id="联合索引非最左前缀"><a href="#联合索引非最左前缀" class="headerlink" title="联合索引非最左前缀"></a>联合索引非最左前缀</h2><p>在联合索引的情况下，数据是按照索引第一列排序，第一列数据相同时才会按照第二列排序。</p><p>所以如果我们想使用索引中尽可能多的列，查询条件的各个列必须是联合索引中最左边开始连续的列。</p><p>联合索引有一些特殊情况，<strong>并不是查询过程使用了联合索引查询，就代表联合索引中的所有字段都用到了联合索引进行索引查询</strong>，也就是可能存在部分字段用到联合索引的 B+Tree，部分字段没有用到联合索引的 B+Tree 的情况。</p><p>这种特殊情况就发生在范围查询。联合索引的最左匹配原则会一直向右匹配直到遇到「范围查询」就会停止匹配。<strong>也就是范围查询的字段可以用到联合索引，但是在范围查询字段的后面的字段无法用到联合索引</strong>。</p><p>看几个案例：</p><blockquote><p><code>select * from t_table where a &gt; 1 and b = 2</code>，联合索引（a, b）哪一个字段用到了联合索引的 B+Tree？</p></blockquote><p>由于联合索引是先按照a字段的值进行排序的，所以查找a&gt;1的联合索引记录肯定是相邻的，在进行索引扫描时，可以定位到符合a&gt;1的第一条记录，然后沿着记录的链表向后扫描，直到a&gt;1条件不成立。</p><p>但是在符合a&gt;1条件的联合索引记录的范围里，b字段的值是无序的。所以这条语句，只有a字段用到了联合索引，b字段没有用到。</p><blockquote><p><code>select * from t_table where a &gt;= 1 and b = 2</code>，联合索引（a, b）哪一个字段用到了联合索引的 B+Tree？</p></blockquote><p>a&gt;&#x3D;1条件的联合索引记录范围里，b字段是无序的，但是对于符合 a &#x3D; 1的联合索引范围里，b字段的值是有序的。由于联合索引，先按照a字段排序，然后再a字段相同的情况下，再按照b字段排序，所以，从符合a&#x3D;1 and b&#x3D;2条件的第一条记录开始扫描，而不需要从第一个a字段值为1的记录开始扫描，所以，此时a字段和b字段都用到了联合索引</p><blockquote><p><code>SELECT * FROM t_table WHERE a BETWEEN 2 AND 8 AND b = 2</code>，联合索引（a, b）哪一个字段用到了联合索引的 B+Tree？</p></blockquote><p>在MySQL中，BETWEEN包含了 value1和value2边界值，类似 &gt;&#x3D; and &lt;&#x3D;，通过上一个案例可知，在a字段等于2 和等于8的时候，b字段可以走联合索引，所以此时，a字段和b字段都可以用到联合索引</p><blockquote><p><code>SELECT * FROM t_user WHERE name like &#39;j%&#39; and age = 22</code>，联合索引（name, age）哪一个字段用到了联合索引的 B+Tree？</p></blockquote><p>此时是右模糊匹配，所以左前缀不受影响，在name &#x3D; j时，age字段可以走联合索引</p><p>综上所示，<strong>联合索引的最左匹配原则，在遇到范围查询（如 &gt;、&lt;）的时候，就会停止匹配，也就是范围查询的字段可以用到联合索引，但是在范围查询字段的后面的字段无法用到联合索引。注意，对于 &gt;&#x3D;、&lt;&#x3D;、BETWEEN、like 前缀匹配的范围查询，并不会停止匹配</strong></p><h3 id="索引下推"><a href="#索引下推" class="headerlink" title="索引下推"></a>索引下推</h3><p>上边的案例说<code>select * from table where a &gt; 1 and b = 2</code> 语句中的a字段可以走索引，但是b字段不能走索引，那在联合索引里边，是不是回回表呢？</p><p>在MySQL5.6之前，只能根据查到的主键值，一个一个回表，再试在MySQL5.6引入了<strong>索引下推</strong>，可以再联合索引遍历的过程中，对联合索引中包含的字段先做判断，直接过滤掉不满足条件的记录，减少回表次数。</p><p>索引下推的大概原理是：截断的字段不会在 Server 层进行条件判断，而是会被下推到「存储引擎层」进行条件判断（因为 b 字段的值是在 <code>(a, b)</code> 联合索引里的），然后过滤出符合条件的数据后再返回给 Server 层。由于在引擎层就过滤掉大量的数据，无需再回表读取数据来进行判断，减少回表次数，从而提升了性能。</p><h3 id="索引区分度"><a href="#索引区分度" class="headerlink" title="索引区分度"></a>索引区分度</h3><p>建立联合索引时的字段顺序，对索引效率也有很大影响。越靠前的字段被用于索引过滤的概率越高，实际开发工作中<strong>建立联合索引时，要把区分度大的字段排在前面，这样区分度大的字段越有可能被更多的 SQL 使用到</strong>。</p><p>区分度就是某个字段 column 不同值的个数「除以」表的总行数，计算公式如下：</p><blockquote><p>区分度 &#x3D; distinct(column) &#x2F; count(*)</p></blockquote><p>比如，性别的区分度就很小，不适合建立索引或不适合排在联合索引列的靠前的位置，而 UUID 这类字段就比较适合做索引或排在联合索引列的靠前的位置。</p><p>因为如果索引的区分度很小，假设字段的值分布均匀，那么无论搜索哪个值都可能得到一半的数据。在这些情况下，还不如不要索引，因为 MySQL 还有一个查询优化器，查询优化器发现某个值出现在表的数据行中的百分比（惯用的百分比界线是”30%”）很高的时候，它一般会忽略索引，进行全表扫描。</p><h1 id="优化索引的方法"><a href="#优化索引的方法" class="headerlink" title="优化索引的方法"></a>优化索引的方法</h1><h2 id="前缀索引优化"><a href="#前缀索引优化" class="headerlink" title="前缀索引优化"></a>前缀索引优化</h2><p>使用前缀索引是为了减小索引字段大小，可以增加一个索引页中存储的索引值，有效提高索引的查询速度。在一些大字符串的字段作为索引时，使用前缀索引可以帮助我们减小索引项的大小。</p><p>不过，前缀索引有一定的局限性，例如：</p><ul><li>order by 就无法使用前缀索引；</li><li>无法把前缀索引用作覆盖索引；</li></ul><h2 id="覆盖索引优化"><a href="#覆盖索引优化" class="headerlink" title="覆盖索引优化"></a>覆盖索引优化</h2><p>覆盖索引是指，在索引的叶子节点上就能找到值，而不需要再回表。</p><p>比如建立一个联合索引，「name, age, address」， 当查小明的年龄和地址的时候，直接从索引中就能得到数据，不需要再回表</p><h2 id="主键索引最好是自增的"><a href="#主键索引最好是自增的" class="headerlink" title="主键索引最好是自增的"></a>主键索引最好是自增的</h2><p><strong>如果我们使用自增主键</strong>，那么每次插入的新数据就会按顺序添加到当前索引节点的位置，不需要移动已有的数据，当页面写满，就会自动开辟一个新页面。因为每次<strong>插入一条新记录，都是追加操作，不需要重新移动数据</strong>，因此这种插入数据的方法效率非常高。</p><p><strong>如果我们使用非自增主键</strong>，由于每次插入主键的索引值都是随机的，因此每次插入新的数据时，就可能会插入到现有数据页中间的某个位置，这将不得不移动其它数据来满足新数据的插入，甚至需要从一个页面复制数据到另外一个页面，我们通常将这种情况称为<strong>页分裂</strong>。<strong>页分裂还有可能会造成大量的内存碎片，导致索引结构不紧凑，从而影响查询效率</strong>。</p><p>另外，主键字段的长度不要太大，因为<strong>主键字段长度越小，意味着二级索引的叶子节点越小（二级索引的叶子节点存放的数据是主键值），这样二级索引占用的空间也就越小</strong>。</p><h2 id="索引最好设置为NOT-NULL"><a href="#索引最好设置为NOT-NULL" class="headerlink" title="索引最好设置为NOT NULL"></a>索引最好设置为NOT NULL</h2><p>索引列存在 NULL 就会导致优化器在做索引选择的时候更加复杂，更加难以优化，因为可为 NULL 的列会使索引、索引统计和值比较都更复杂，比如进行索引统计时，count 会省略值为NULL 的行。</p><p>NULL 值是一个没意义的值，但是它会占用物理空间，所以会带来的存储空间的问题，因为 InnoDB 存储记录的时候，如果表中存在允许为 NULL 的字段，那么行格式 (opens new window)中<strong>至少会用 1 字节空间存储 NULL 值列表</strong></p><h2 id="防止索引失效"><a href="#防止索引失效" class="headerlink" title="防止索引失效"></a>防止索引失效</h2>]]></content>
    
    
    <categories>
      
      <category>MySQL</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MySQL</tag>
      
      <tag>数据库</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SQL查询过程</title>
    <link href="/2024/06/23/SQL%E6%9F%A5%E8%AF%A2%E8%BF%87%E7%A8%8B/"/>
    <url>/2024/06/23/SQL%E6%9F%A5%E8%AF%A2%E8%BF%87%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="MySQL基本架构"><a href="#MySQL基本架构" class="headerlink" title="MySQL基本架构"></a>MySQL基本架构</h1><p><img src="https://gxc-hexo-blog.oss-cn-beijing.aliyuncs.com/blog/MySQL%E5%9F%BA%E6%9C%AC%E6%9E%B6%E6%9E%84.png"></p><p>从上图看，MySQL分为两部分：Server层 和 存储引擎 </p><p><strong>Server层</strong>：负责建立连接，分析和执行SQL。涵盖MySQL的大多数核心服务功能，主要包括连接器，查询缓存、解析器、预处理器、优化器、执行器等，以及所有的内置函数（如日期、时间、数学和加密函数等）</p><p><strong>存储引擎层</strong>：负责数据的存储和提取。支持 InnoDB、MyISAM、Memory 等多个存储引擎。现在最常用的存储引擎是 InnoDB，它从 MySQL 5.5.5 版本开始成为了默认存储引擎。</p><h1 id="连接器"><a href="#连接器" class="headerlink" title="连接器"></a>连接器</h1><p>执行SQL语句首先得连接到数据库上，这时候就会遇到连机器。连接器负责跟客户端建立连接、获取权限、维持和管理链接。链接命令如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">mysql -h$ip -P$port -u$user -p<br></code></pre></td></tr></table></figure><p>为了密码的安全，不在如上命令后写密码，而是直接执行上述命令在后续的对话框中输入密码。</p><p>连接的过程需要先经过 TCP 三次握手，因为 MySQL 是基于 TCP 协议进行传输的，如果 MySQL 服务并没有启动，则会报一个 “Can’t not connect to MySQL through socket ….”</p><p>如果MySQL服务正常，完成TCP连接之后，连接器就要开始验证用户名和密码</p><ul><li>如果用户名或者密码不对，则会报 “Access denied for user”</li><li>如果用户名密码认证通过，连接器会到权限表里面查出你拥有的权限。之后，这个连接里面的权限判断逻辑，都将依赖于此时读到的权限</li></ul><p>因为在成功建立连接后，连接器已经校验了权限，所以后续管理员账号哪怕对这个权限做了修改，也不会影响已经存在的连接的权限，只有新建的连接才会使用新的权限。</p><p>如何查看MySQL的连接呢？</p><p>连接完成后，如果你没有后续的动作，这个连接就处于空闲状态，你可以在 <code>show processlist</code> 命令中看到它。其中的 Command 列显示为“Sleep”的这一行，就表示现在系统里面有一个空闲连接。</p><p><img src="https://gxc-hexo-blog.oss-cn-beijing.aliyuncs.com/blog/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5.png"></p><p>共有两个用户名为 root 的用户连接了 MySQL 服务，其中 id 为 6 的用户的 Command 列的状态为 <code>Sleep</code> ，这意味着该用户连接完 MySQL 服务就没有再执行过任何命令，也就是说这是一个空闲的连接，并且空闲的时长是 736 秒（ Time 列）。</p><p>客户端如果太长时间没动静，连接器就会自动将它断开。这个时间是由参数 wait_timeout 控制的，默认值是 8 小时。(<code>mysql&gt; show variables like &#39;wait_timeout&#39;;</code> 可以查看此配置)</p><p>也可以手动断开空闲的连接，使用 <code>kill connection + id</code> </p><p>如果在连接被断开之后，客户端不会马上感知，当再次发送请求的时，就会收到一个错误提醒： Lost connection to MySQL server during query。这时候如果你要继续，就需要重连，然后再执行请求了。</p><p>建立连接的过程通常是比较复杂的，所以在使用中要尽量减少建立连接的动作，也就是尽量使用长连接。（使用长连接，通过连接池维护一些长连接）</p><p>但是MySQL的连接数有限制，支持的最大连接数由 max_connections 参数控制，如果超过这个限制就会拒绝接下来的连接请求，并报错提示：”Too many connections”，而且使用长连接后可能会占用内存增多，因为 MySQL 在执行查询过程中临时使用内存管理连接对象，这些连接对象资源只有在连接断开时才会释放。如果长连接累计很多，将导致 MySQL 服务占用内存太大，有可能会被系统强制杀掉，这样会发生 MySQL 服务异常重启的现象。</p><p>那如何解决长连接占用内存问题呢？</p><ol><li>定期断开长连接。使用一段时间，或者程序里面判断执行过一个占用内存的大查询后，断开连接，之后要查询再重连。</li><li>如果用的是 MySQL 5.7 或更新版本，可以在每次执行一个比较大的操作后，通过执行 mysql_reset_connection 来重新初始化连接资源。这个过程不需要重连和重新做权限验证，但是会将连接恢复到刚刚创建完时的状态。注意这是接口函数不是命令，那么当客户端执行了一个很大的操作后，在代码里调用 mysql_reset_connection 函数来重置连接，达到释放内存的效果。</li></ol><p>小结：</p><ul><li>与客户端进行 TCP 三次握手建立连接；</li><li>校验客户端的用户名和密码，如果用户名或密码不对，则会报错；</li><li>如果用户名和密码都对了，会读取该用户的权限，然后后面的权限逻辑判断都基于此时读取到的权限；</li></ul><h1 id="查询缓存"><a href="#查询缓存" class="headerlink" title="查询缓存"></a>查询缓存</h1><p>连接建立完成后，执行逻辑就会来到第二步：查询缓存。</p><p>MySQL 拿到一个查询请求后，会先到查询缓存看看，之前是不是执行过这条语句。之前执行过的语句及其结果可能会以 key-value 对的形式，被直接缓存在内存中。key 是查询的语句，value 是查询的结果。如果你的查询能够直接在这个缓存中找到 key，那么这个 value 就会被直接返回给客户端。如果查询的语句没有命中查询缓存中，那么就要往下继续执行，等执行完后，查询的结果就会被存入查询缓存中。</p><p><strong>但是查询缓存往往弊大于利</strong></p><p><strong>查询缓存的失效非常频繁，只要有对一个表的更新，这个表上所有的查询缓存都会被清空。</strong>对于更新比较频繁的表，查询缓存的命中率很低的，如果刚缓存了一个查询结果很大的数据，还没被使用的时候，刚好这个表有更新操作，查询缓冲就被清空了。</p><p>查询缓存受 <code>query_cache_type</code>参数控制，将其设置成 “DEMAND”，SQL就默认不使用查询缓存，对于要使用查询缓存的，可以用 SQL_CACHE 显示指定，例如：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs SQL"><span class="hljs-keyword">select</span> SQL_CACHE <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> T <span class="hljs-keyword">where</span> ID<span class="hljs-operator">=</span><span class="hljs-number">1</span>；<br></code></pre></td></tr></table></figure><p>在 MySQL 8.0版本之后，查询缓存的功能被移除了。注意：此处移除的是server层的查询缓存，不是InnoDB存储引擎中的 buffer pool。</p><h1 id="分析器"><a href="#分析器" class="headerlink" title="分析器"></a>分析器</h1><p>没有命中查询缓存的查询SQL，就要开始真正执行了。所以接下来要对SQL进行分析</p><p>分析器会做两种分析：<strong>词法分析</strong>、<strong>语法分析</strong></p><p>词法分析：MySQL根据输入的字符串识别出关键字来，比如根据输入的 “select” 识别出这是一个查询语句。</p><p>语法分析：语法分析会根据语法规则，判断输入的这个SQL是否符合MySQL的语法，如果语句有错误，就会收到”You have an error in your SQL syntax”的错误提醒，</p><h1 id="执行SQL"><a href="#执行SQL" class="headerlink" title="执行SQL"></a>执行SQL</h1><p>经过解析器后，就要进入执行SQL查询语句的流程了，查询分三个阶段：预处理阶段、优化阶段、执行阶段</p><h2 id="预处理器"><a href="#预处理器" class="headerlink" title="预处理器"></a>预处理器</h2><ul><li>检查SQL查询语句中的表或者字段是否存在</li><li>将 <code>select *</code> 中的<code>*</code>符号，扩展为表中所有的列</li></ul><h2 id="优化器"><a href="#优化器" class="headerlink" title="优化器"></a>优化器</h2><p>在预处理过后，还需要优化器进行处理</p><p><strong>优化器主要负责将 SQL 查询语句的执行方案确定下来</strong>，比如在表里面有多个索引的时候，决定使用哪个索引，或者在一个语句有多表关联（join）的时候，决定各个表的连接顺序。</p><p>如何知道优化器选择了哪个索引？</p><p>可以在查询语句最前面加个 <code>explain</code> 命令，这样就会输出这条 SQL 语句的执行计划，然后执行计划中的 key 就表示执行过程中使用了哪个索引，当 key 为 <code>PRIMARY</code> 就是使用了主键索引。</p><blockquote><p>type显示的是访问类型，访问类型表示我是以何种方式去访问我们的数据，最容易想的是全表扫描，直接暴力的遍历一张表去寻找需要的数据，效率非常低下，访问的类型有很多，效率从最好到最坏依次是：</p><p>所有的连接类型中，上面的最好，越往下越差。在常用的链接类型中：system &gt; const &gt; eq_ref &gt; ref &gt; fulltext &gt; ref_or_null &gt; index_merge &gt; unique_subquery &gt; index_subquery &gt; range &gt; index &gt; ALL</p><p>以上访问类型除了 all，都能用到索引,一般情况下，得保证查询至少达到range级别，最好能达到ref</p><p>–all:全表扫描，一般情况下出现这样的sql语句而且数据量比较大的话那么就需要进行优化。<br>explain select * from emp;</p><p>–index：全索引扫描这个比all的效率要好，主要有两种情况，一种是当前的查询时覆盖索引，即我们需要的数据在索引中就可以索取，或者是使用了索引进行排序，这样就避免数据的重排序<br>explain  select empno from emp;</p><p>–range：表示利用索引查询的时候限制了范围，在指定范围内进行查询，这样避免了index的全索引扫描，适用的操作符： &#x3D;, &lt;&gt;, &gt;, &gt;&#x3D;, &lt;, &lt;&#x3D;, IS NULL, BETWEEN, LIKE, or IN()<br>explain select * from emp where empno between 7000 and 7500;</p><p>–index_subquery：利用索引来关联子查询，不再扫描全表<br>explain select * from emp where emp.job in (select job from t_job);</p><p>–unique_subquery:该连接类型类似与index_subquery,使用的是唯一索引<br> explain select * from emp e where e.deptno in (select distinct deptno from dept);</p><p>–index_merge：在查询过程中需要多个索引组合使用</p><p>–ref_or_null：对于某个字段即需要关联条件，也需要null值的情况下，查询优化器会选择这种访问方式<br>explain select * from emp e where  e.mgr is null or e.mgr&#x3D;7369;</p><p>–ref：使用了非唯一性索引进行数据的查找，查询用到了非唯一性索引，或者关联操作只使用了索引的最左前缀。<br> create index idx_3 on emp(deptno);<br> explain select * from emp e,dept d where e.deptno &#x3D;d.deptno;</p><p>–eq_ref ：通常出现在多表的 join 查询，被驱动表通过唯一性索引（UNIQUE 或 PRIMARY KEY）进行访问，此时被驱动表的访问方式就是 eq_ref。eq_ref 是除 const 之外最好的访问类型。使用唯一性索引进行数据查找<br>explain select * from emp,emp2 where emp.empno &#x3D; emp2.empno;</p><p>–const：主键索引或者唯一索引,这个表至多有一个匹配行；<br>explain select * from emp where empno &#x3D; 7369;</p><p>–system：system 是 const 的一种特例，只有一行满足条件，对于 MyISAM、Memory 的表，只查询到一条记录，也是 system。比如系统库的这张表（8.0 的版本中系统表全部变成 InnoDB 存储引擎了）：<br>表只有一行记录（等于系统表），这是const类型的特例，平时不会出现；<br>EXPLAIN SELECT * FROM mysql.proxies_priv;</p></blockquote><h2 id="执行器"><a href="#执行器" class="headerlink" title="执行器"></a>执行器</h2><p>MySQL 通过分析器知道了你要做什么，通过优化器知道了该怎么做，于是就进入了执行器阶段，开始执行语句。</p><p>开始执行的时候，要先判断一下你对这个表 T 有没有执行查询的权限，如果没有，就会返回没有权限的错误(在工程实现上，如果命中查询缓存，会在查询缓存返回结果的时候，做权限验证。查询也会在优化器之前调用 precheck 验证权限)。</p>]]></content>
    
    
    <categories>
      
      <category>MySQL</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MySQL</tag>
      
      <tag>数据库</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MongoDB集群</title>
    <link href="/2024/06/19/MongoDB%E9%9B%86%E7%BE%A4/"/>
    <url>/2024/06/19/MongoDB%E9%9B%86%E7%BE%A4/</url>
    
    <content type="html"><![CDATA[<h1 id="副本集"><a href="#副本集" class="headerlink" title="副本集"></a>副本集</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>MongoDB副本集（Replica Set）是一组维护相同数据集的mongod服务，旨在提供冗余和高可用性。它由多个mongod进程组成，这些进程在不同的机器上运行，共同维护相同的数据集。</p><p>副本集的工作原理类似于具有自动故障恢复功能的主从集群，通过多台机器进行同一数据的异步同步，确保多台机器拥有同一数据的多个副本。当主库发生故障时，副本集能够自动切换到其他备份服务器作为新的主库，无需用户干预，从而保证了数据的可用性和系统的持续性运行。此外，副本集还可以利用副本服务器作为只读服务器，实现读写分离，提高系统的负载能力。</p><p>（1）冗余和数据可用性</p><p>复制提供冗余并提高数据可用性。 通过在不同数据库服务器上提供多个数据副本，复制可提供一定级别的容错功能，以防止丢失单个数据库服务器。</p><p>在某些情况下，复制可以提供增加的读取性能，因为客户端可以将读取操作发送到不同的服务上， 在不同数据中心维护数据副本可以增加分布式应用程序的数据位置和可用性。 您还可以为专用目的维护其他副本，例如灾难恢复，报告或备份。</p><p>（2）MongoDB中的复制</p><p>副本集是一组维护相同数据集的mongod实例。 副本集包含多个数据承载节点和可选的一个仲裁节点。在承载数据的节点中，一个且仅一个成员被视为主节点，而其他节点被视为次要（从）节点。</p><p>主节点接收所有写操作。 副本集只能有一个主要能够确认具有{w：“most”}写入关注的写入; 虽然在某些情况下，另一个mongod实例可能暂时认为自己也是主要的。主要记录其操作日志中的数据集的所有更改，即oplog。</p><p>辅助(副本)节点复制主节点的oplog并将操作应用于其数据集，以使辅助节点的数据集反映主节点数据集。 如果主要人员不在，则符合条件的中将举行选举以选出新的主要人员。</p><p>（3）主从复制和副本集区别</p><p>主从集群和副本集最大的区别就是副本集没有固定的“主节点”；整个集群会选出一个“主节点”，当其挂掉后，又在剩下的从节点中选中其他节点为“主节点”，副本集总有一个活跃点(主、primary)和一个或多个备份节点(从、secondary)。</p><h2 id="副本集的三个角色"><a href="#副本集的三个角色" class="headerlink" title="副本集的三个角色"></a>副本集的三个角色</h2><p>副本集有两种类型三种角色</p><p>两种类型：</p><ul><li><p>主节点（Primary）类型：数据操作的主要连接点，可读写。</p></li><li><p>次要（辅助、从）节点（Secondaries）类型：数据冗余备份节点，可以读或选举。</p></li></ul><p>三种角色：</p><p>主要成员（Primary）：主要接收所有写操作。就是主节点。</p><p>副本成员（Replicate）：从主节点通过复制操作以维护相同的数据集，即备份数据，不可写操作，但可以读操作（但需要配置）。是默认的一种从节点类型。</p><p>仲裁者（Arbiter）：不保留任何数据的副本，只具有投票选举作用。当然也可以将仲裁服务器维护为副本集的一部分，即副本成员同时也可以是仲裁者。也是一种从节点类型。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs shell">+-----------------+<br>|    Client       |<br>+-----------------+<br>       |<br>       v<br>+-----------------+<br>|   Primary Node  |<br>+-----------------+<br>       |<br>       v<br>+------------------+        +------------------+<br>| Secondary Node 1 | &lt;----&gt; | Secondary Node 2 |<br>+------------------+        +------------------+<br>       ^<br>       |<br>+------------------+<br>|   Arbiter Node   |<br>+------------------+<br><br></code></pre></td></tr></table></figure><p>关于仲裁者的额外说明：</p><p>您可以将额外的mongod实例添加到副本集作为仲裁者。 仲裁者不维护数据集。 仲裁者的目的是通过响应其他副本集成员的心跳和选举请求来维护副本集中的仲裁。 因为它们不存储数据集，所以仲裁器可以是提供副本集仲裁功能的好方法，其资源成本比具有数据集的全功能副本集成员更便宜。</p><p>如果您的副本集具有偶数个成员，请添加仲裁者以获得主要选举中的“大多数”投票。 仲裁者不需要专用硬件。</p><p>仲裁者将永远是仲裁者，而主要人员可能会退出并成为次要人员，而次要人员可能成为选举期间的主要人员。</p><p>如果你的副本+主节点的个数是偶数，建议加一个仲裁者，形成奇数，容易满足大多数的投票。</p><p>如果你的副本+主节点的个数是奇数，可以不加仲裁者。</p><h2 id="副本集架构目标"><a href="#副本集架构目标" class="headerlink" title="副本集架构目标"></a>副本集架构目标</h2><p>一主一副本一仲裁</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs shell">+-----------------+<br>|    Client       |<br>+-----------------+<br>       |<br>       v<br>+-----------------+<br>|   Primary Node  |<br>+-----------------+<br>       |<br>       v<br>+------------------+        +------------------+<br>| Secondary Node 1 | &lt;----&gt; | Secondary Node 2 |<br>+------------------+        +------------------+<br>       ^<br>       |<br>+------------------+<br>|   Arbiter Node   |<br>+------------------+<br><br><br></code></pre></td></tr></table></figure><h2 id="副本集的创建"><a href="#副本集的创建" class="headerlink" title="副本集的创建"></a>副本集的创建</h2><h3 id="创建主节点"><a href="#创建主节点" class="headerlink" title="创建主节点"></a>创建主节点</h3><p>简历存放数据和日志的目录</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">-----------myrs</span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">主节点</span><br>mkdir -p /mongodb/replica_sets/myrs_27017/log \ &amp;<br>mkdir -p /mongodb/replica_sets/myrs_27017/data/db<br></code></pre></td></tr></table></figure><p>新建或修改配置文件：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">vim /mongodb/replica_sets/myrs_27017/mongod.conf<br></code></pre></td></tr></table></figure><p>myrs_27017：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">systemLog:</span><br>  <span class="hljs-comment">#MongoDB发送所有日志输出的目标指定为文件</span><br>  <span class="hljs-attr">destination:</span> <span class="hljs-string">file</span><br>  <span class="hljs-comment">#mongod或mongos应向其发送所有诊断日志记录信息的日志文件的路径</span><br>  <span class="hljs-attr">path:</span> <span class="hljs-string">&quot;/mongodb/replica_sets/myrs_27017/log/mongod.log&quot;</span><br>  <span class="hljs-comment">#当mongos或mongod实例重新启动时，mongos或mongod会将新条目附加到现有日志文件的末尾。</span><br>  <span class="hljs-attr">logAppend:</span> <span class="hljs-literal">true</span><br><span class="hljs-attr">storage:</span><br>  <span class="hljs-comment">#mongod实例存储其数据的目录。storage.dbPath设置仅适用于mongod。</span><br>  <span class="hljs-attr">dbPath:</span> <span class="hljs-string">&quot;/mongodb/replica_sets/myrs_27017/data/db&quot;</span><br>  <span class="hljs-attr">journal:</span><br>  <span class="hljs-comment">#启用或禁用持久性日志以确保数据文件保持有效和可恢复。</span><br>  <span class="hljs-attr">enabled:</span> <span class="hljs-literal">true</span><br><span class="hljs-attr">processManagement:</span><br>  <span class="hljs-comment">#启用在后台运行mongos或mongod进程的守护进程模式。</span><br>  <span class="hljs-attr">fork:</span> <span class="hljs-literal">true</span><br>  <span class="hljs-comment">#指定用于保存mongos或mongod进程的进程ID的文件位置，其中mongos或mongod将写入其PID</span><br>  <span class="hljs-attr">pidFilePath:</span> <span class="hljs-string">&quot;/mongodb/replica_sets/myrs_27017/log/mongod.pid&quot;</span><br><span class="hljs-attr">net:</span><br>  <span class="hljs-comment">#服务实例绑定所有IP，有副作用，副本集初始化的时候，节点名字会自动设置为本地域名，而不是ip</span><br>  <span class="hljs-comment">#bindIpAll: true</span><br>  <span class="hljs-comment">#服务实例绑定的IP</span><br>  <span class="hljs-attr">bindIp:</span> <span class="hljs-string">localhost,192.168.0.2</span><br>  <span class="hljs-comment">#bindIp</span><br>  <span class="hljs-comment">#绑定的端口</span><br>  <span class="hljs-attr">port:</span> <span class="hljs-number">27017</span><br><span class="hljs-attr">replication:</span><br>  <span class="hljs-comment">#副本集的名称</span><br>  <span class="hljs-attr">replSetName:</span> <span class="hljs-string">myrs</span><br></code></pre></td></tr></table></figure><p>启动节点服务：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">/usr/local/mongodb/bin/mongod -f /mongodb/replica_sets/myrs_27017/mongod.conf<br>about to fork child process, waiting until server is ready for connections.<br>forked process: 54257<br>child process started successfully, parent exiting<br></code></pre></td></tr></table></figure><h3 id="创建副本节点"><a href="#创建副本节点" class="headerlink" title="创建副本节点"></a>创建副本节点</h3><p>建立存放数据和日志的目录</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">副本节点</span><br>mkdir -p /mongodb/replica_sets/myrs_27018/log \ &amp;<br>mkdir -p /mongodb/replica_sets/myrs_27018/data/db<br></code></pre></td></tr></table></figure><p>新建或修改配置文件：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">vim /mongodb/replica_sets/myrs_27018/mongod.conf<br></code></pre></td></tr></table></figure><p>myrs_27018：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs shell">systemLog:<br><span class="hljs-meta prompt_">  #</span><span class="language-bash">MongoDB发送所有日志输出的目标指定为文件</span><br>  destination: file<br><span class="hljs-meta prompt_">  #</span><span class="language-bash">mongod或mongos应向其发送所有诊断日志记录信息的日志文件的路径</span><br>  path: &quot;/mongodb/replica_sets/myrs_27018/log/mongod.log&quot;<br><span class="hljs-meta prompt_">  #</span><span class="language-bash">当mongos或mongod实例重新启动时，mongos或mongod会将新条目附加到现有日志文件的末尾。</span><br>  logAppend: true<br>storage:<br><span class="hljs-meta prompt_">  #</span><span class="language-bash">mongod实例存储其数据的目录。storage.dbPath设置仅适用于mongod。</span><br>  dbPath: &quot;/mongodb/replica_sets/myrs_27018/data/db&quot;<br>  journal:<br><span class="hljs-meta prompt_">  #</span><span class="language-bash">启用或禁用持久性日志以确保数据文件保持有效和可恢复。</span><br>  enabled: true<br>processManagement:<br><span class="hljs-meta prompt_">  #</span><span class="language-bash">启用在后台运行mongos或mongod进程的守护进程模式。</span><br>  fork: true<br><span class="hljs-meta prompt_">  #</span><span class="language-bash">指定用于保存mongos或mongod进程的进程ID的文件位置，其中mongos或mongod将写入其PID</span><br>  pidFilePath: &quot;/mongodb/replica_sets/myrs_27018/log/mongod.pid&quot;<br>net:<br><span class="hljs-meta prompt_">  #</span><span class="language-bash">服务实例绑定所有IP，有副作用，副本集初始化的时候，节点名字会自动设置为本地域名，而不是ip</span><br><span class="hljs-meta prompt_">  #</span><span class="language-bash">bindIpAll: <span class="hljs-literal">true</span></span><br><span class="hljs-meta prompt_">  #</span><span class="language-bash">服务实例绑定的IP</span><br>  bindIp: localhost,192.168.0.2<br><span class="hljs-meta prompt_">  #</span><span class="language-bash">bindIp</span><br><span class="hljs-meta prompt_">  #</span><span class="language-bash">绑定的端口</span><br>  port: 27018<br>replication:<br><span class="hljs-meta prompt_">  #</span><span class="language-bash">副本集的名称</span><br>  replSetName: myrs<br></code></pre></td></tr></table></figure><p>启动节点服务：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">/usr/local/mongodb/bin/mongod -f /mongodb/replica_sets/myrs_27018/mongod.conf<br>about to fork child process, waiting until server is ready for connections.<br>forked process: 54361<br>child process started successfully, parent exiting<br></code></pre></td></tr></table></figure><h3 id="创建仲裁节点"><a href="#创建仲裁节点" class="headerlink" title="创建仲裁节点"></a>创建仲裁节点</h3><p>建立存放数据和日志的目录</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">-----------myrs</span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">仲裁节点</span><br>mkdir -p /mongodb/replica_sets/myrs_27019/log \ &amp;<br>mkdir -p /mongodb/replica_sets/myrs_27019/data/db<br></code></pre></td></tr></table></figure><p>仲裁节点：</p><p>新建或修改配置文件：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">vim /mongodb/replica_sets/myrs_27019/mongod.conf<br></code></pre></td></tr></table></figure><p>myrs_27019：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs shell">systemLog:<br><span class="hljs-meta prompt_">  #</span><span class="language-bash">MongoDB发送所有日志输出的目标指定为文件</span><br>  destination: file<br><span class="hljs-meta prompt_">  #</span><span class="language-bash">mongod或mongos应向其发送所有诊断日志记录信息的日志文件的路径</span><br>  path: &quot;/mongodb/replica_sets/myrs_27019/log/mongod.log&quot;<br><span class="hljs-meta prompt_">  #</span><span class="language-bash">当mongos或mongod实例重新启动时，mongos或mongod会将新条目附加到现有日志文件的末尾。</span><br>  logAppend: true<br>storage:<br><span class="hljs-meta prompt_">  #</span><span class="language-bash">mongod实例存储其数据的目录。storage.dbPath设置仅适用于mongod。</span><br>  dbPath: &quot;/mongodb/replica_sets/myrs_27019/data/db&quot;<br>  journal:<br><span class="hljs-meta prompt_">  #</span><span class="language-bash">启用或禁用持久性日志以确保数据文件保持有效和可恢复。</span><br>  enabled: true<br>processManagement:<br><span class="hljs-meta prompt_">  #</span><span class="language-bash">启用在后台运行mongos或mongod进程的守护进程模式。</span><br>  fork: true<br><span class="hljs-meta prompt_">  #</span><span class="language-bash">指定用于保存mongos或mongod进程的进程ID的文件位置，其中mongos或mongod将写入其PID</span><br>  pidFilePath: &quot;/mongodb/replica_sets/myrs_27019/log/mongod.pid&quot;<br>net:<br><span class="hljs-meta prompt_">  #</span><span class="language-bash">服务实例绑定所有IP，有副作用，副本集初始化的时候，节点名字会自动设置为本地域名，而不是ip</span><br><span class="hljs-meta prompt_">  #</span><span class="language-bash">bindIpAll: <span class="hljs-literal">true</span></span><br><span class="hljs-meta prompt_">  #</span><span class="language-bash">服务实例绑定的IP</span><br>  bindIp: localhost,192.168.0.2<br><span class="hljs-meta prompt_">  #</span><span class="language-bash">bindIp</span><br><span class="hljs-meta prompt_">  #</span><span class="language-bash">绑定的端口</span><br>  port: 27019<br>replication:<br><span class="hljs-meta prompt_">  #</span><span class="language-bash">副本集的名称</span><br>  replSetName: myrs<br></code></pre></td></tr></table></figure><p>启动节点服务：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"> /usr/local/mongodb/bin/mongod -f /mongodb/replica_sets/myrs_27019/mongod.conf<br>about to fork child process, waiting until server is ready for connections.<br>forked process: 54410<br>child process started successfully, parent exiting<br></code></pre></td></tr></table></figure><h3 id="初始化配置副本集和主节点"><a href="#初始化配置副本集和主节点" class="headerlink" title="初始化配置副本集和主节点"></a>初始化配置副本集和主节点</h3><p>使用客户端命令连接任意一个节点，但这里尽量要连接主节点(27017节点)：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">/usr/local/mongodb/bin/mongo --host=180.76.159.126 --port=27017<br></code></pre></td></tr></table></figure><p>结果，连接上之后，很多命令无法使用，，比如 show dbs 等，必须初始化副本集才行</p><p>准备初始化新的副本集：</p><p>语法：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">rs.initiate(configuration)<br></code></pre></td></tr></table></figure><table><thead><tr><th><strong>Parameter</strong></th><th><strong>Type</strong></th><th><strong>Description</strong></th></tr></thead><tbody><tr><td>configuration</td><td>document</td><td>Optional. A document that specifies <a href="https://www.mongodb.com/docs/manual/reference/replica-configuration/#replica-set-configuration-document">configuration</a> for the new replica set. If a configuration is not specified, MongoDB uses a default replica set configuration.</td></tr></tbody></table><p>【示例】</p><p>使用默认的配置来初始化副本集：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">rs.initiate()<br></code></pre></td></tr></table></figure><p>执行结果：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs shell">rs.initiate()<br>&#123;<br>&quot;info2&quot; : &quot;no configuration specified. Using a default configuration for<br>the set&quot;,<br>  &quot;me&quot; : &quot;180.76.159.126:27017&quot;,<br>  &quot;ok&quot; : 1,<br>  &quot;operationTime&quot; : Timestamp(1565760476, 1),<br>  &quot;$clusterTime&quot; : &#123;<br>    &quot;clusterTime&quot; : Timestamp(1565760476, 1),<br>    &quot;signature&quot; : &#123;<br>      &quot;hash&quot; : BinData(0,&quot;AAAAAAAAAAAAAAAAAAAAAAAAAAA=&quot;),<br>      &quot;keyId&quot; : NumberLong(0)<br>&#125;<br>&#125;<br>&#125;<br>myrs:SECONDARY&gt;<br>myrs:PRIMARY&gt;<br></code></pre></td></tr></table></figure><p>提示：</p><p>1）“ok”的值为1，说明创建成功。</p><p>2）命令行提示符发生变化，变成了一个从节点角色，此时默认不能读写。稍等片刻，回车，变成主节点。</p><h3 id="查看副本集的配置内容"><a href="#查看副本集的配置内容" class="headerlink" title="查看副本集的配置内容"></a>查看副本集的配置内容</h3><p>说明：</p><p>返回包含当前副本集配置的文档。</p><p>语法：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">rs.conf(configuration)<br></code></pre></td></tr></table></figure><p>提示：</p><p>rs.config() 是该方法的别名。</p><p>configuration：可选，如果没有配置，则使用默认主节点配置。</p><p>【示例】</p><p>在27017上执行副本集中当前节点的默认节点配置</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs shell">myrs:PRIMARY&gt; rs.conf()<br>&#123;<br>  &quot;_id&quot; : &quot;myrs&quot;,<br>  &quot;version&quot; : 1,<br>  &quot;protocolVersion&quot; : NumberLong(1),<br>  &quot;writeConcernMajorityJournalDefault&quot; : true,<br>  &quot;members&quot; : [<br>    &#123;<br>    &quot;_id&quot; : 0,<br>    &quot;host&quot; : &quot;180.76.159.126:27017&quot;,<br>    &quot;arbiterOnly&quot; : false,<br>    &quot;buildIndexes&quot; : true,<br>    &quot;hidden&quot; : false,<br>    &quot;priority&quot; : 1,<br>    &quot;tags&quot; : &#123;<br>    &#125;,<br>    &quot;slaveDelay&quot; : NumberLong(0),<br>    &quot;votes&quot; : 1<br>  &#125;<br>  ],<br>  &quot;settings&quot; : &#123;<br>    &quot;chainingAllowed&quot; : true,<br>    &quot;heartbeatIntervalMillis&quot; : 2000,<br>    &quot;heartbeatTimeoutSecs&quot; : 10,<br>    &quot;electionTimeoutMillis&quot; : 10000,<br>    &quot;catchUpTimeoutMillis&quot; : -1,<br>    &quot;catchUpTakeoverDelayMillis&quot; : 30000,<br>    &quot;getLastErrorModes&quot; : &#123;<br>  &#125;,<br>  &quot;getLastErrorDefaults&quot; : &#123;<br>    &quot;w&quot; : 1,<br>    &quot;wtimeout&quot; : 0<br>  &#125;,<br>  &quot;replicaSetId&quot; : ObjectId(&quot;5d539bdcd6a308e600d126bb&quot;)<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>说明：</p><p>1） “_id” : “myrs” ：副本集的配置数据存储的主键值，默认就是副本集的名字</p><p>2） “members” ：副本集成员数组，此时只有一个： “host” : “180.76.159.126:27017” ，该成员不是仲裁节点： “arbiterOnly” : false ，优先级（权重值）： “priority” : 1,</p><p>3） “settings” ：副本集的参数配置。</p><p>提示：副本集配置的查看命令，本质是查询的是 system.replset 的表中的数据：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs shell">myrs:PRIMARY&gt; use local<br>switched to db local<br>myrs:PRIMARY&gt; show collections<br>oplog.rs<br>replset.election<br>replset.minvalid<br>replset.oplogTruncateAfterPoint<br>startup_log<br>system.replset<br>system.rollback.id<br>myrs:PRIMARY&gt; db.system.replset.find()<br>&#123; &quot;_id&quot; : &quot;myrs&quot;, &quot;version&quot; : 1, &quot;protocolVersion&quot; : NumberLong(1),<br>&quot;writeConcernMajorityJournalDefault&quot; : true, &quot;members&quot; : [ &#123; &quot;_id&quot; : 0, &quot;host&quot; :<br>&quot;180.76.159.126:27017&quot;, &quot;arbiterOnly&quot; : false, &quot;buildIndexes&quot; : true, &quot;hidden&quot; :<br>false, &quot;priority&quot; : 1, &quot;tags&quot; : &#123; &#125;, &quot;slaveDelay&quot; : NumberLong(0), &quot;votes&quot; : 1<br>&#125; ], &quot;settings&quot; : &#123; &quot;chainingAllowed&quot; : true, &quot;heartbeatIntervalMillis&quot; : 2000,<br>&quot;heartbeatTimeoutSecs&quot; : 10, &quot;electionTimeoutMillis&quot; : 10000,<br>&quot;catchUpTimeoutMillis&quot; : -1, &quot;catchUpTakeoverDelayMillis&quot; : 30000,<br>&quot;getLastErrorModes&quot; : &#123; &#125;, &quot;getLastErrorDefaults&quot; : &#123; &quot;w&quot; : 1, &quot;wtimeout&quot; : 0<br>&#125;, &quot;replicaSetId&quot; : ObjectId(&quot;5d539bdcd6a308e600d126bb&quot;) &#125; &#125;<br>myrs:PRIMARY&gt;<br></code></pre></td></tr></table></figure><h3 id="查看副本集状态"><a href="#查看副本集状态" class="headerlink" title="查看副本集状态"></a>查看副本集状态</h3><p>检查副本集状态。</p><p>说明：</p><p>返回包含状态信息的文档。此输出使用从副本集的其他成员发送的心跳包中获得的数据反映副本集的当前状态。</p><p>语法：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">rs.status()<br></code></pre></td></tr></table></figure><p>【示例】</p><p>在27017上查看副本集状态：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs shell">myrs:PRIMARY&gt; rs.status()<br>&#123;  <br>  &quot;set&quot;: &quot;myrs&quot;,  <br>  &quot;date&quot;: &quot;ISODate(\&quot;2019-08-14T05:29:45.161Z\&quot;)&quot;,  <br>  &quot;myState&quot;: 1,  <br>  &quot;term&quot;: &quot;NumberLong(1)&quot;,  <br>  &quot;syncingTo&quot;: &quot;&quot;,  <br>  &quot;syncSourceHost&quot;: &quot;&quot;,  <br>  &quot;syncSourceId&quot;: -1,  <br>  &quot;heartbeatIntervalMillis&quot;: &quot;NumberLong(2000)&quot;,  <br>  &quot;optimes&quot;: &#123;  <br>    &quot;lastCommittedOpTime&quot;: &#123;  <br>      &quot;ts&quot;: &quot;Timestamp(1565760578, 1)&quot;,  <br>      &quot;t&quot;: &quot;NumberLong(1)&quot;  <br>    &#125;,  <br>    &quot;readConcernMajorityOpTime&quot;: &#123;  <br>      &quot;ts&quot;: &quot;Timestamp(1565760578, 1)&quot;,  <br>      &quot;t&quot;: &quot;NumberLong(1)&quot;  <br>    &#125;,  <br>    &quot;appliedOpTime&quot;: &#123;  <br>      &quot;ts&quot;: &quot;Timestamp(1565760578, 1)&quot;,  <br>      &quot;t&quot;: &quot;NumberLong(1)&quot;  <br>    &#125;,  <br>    &quot;durableOpTime&quot;: &#123;  <br>      &quot;ts&quot;: &quot;Timestamp(1565760578, 1)&quot;,  <br>      &quot;t&quot;: &quot;NumberLong(1)&quot;  <br>    &#125;  <br>  &#125;,  <br>  &quot;lastStableCheckpointTimestamp&quot;: &quot;Timestamp(1565760528, 1)&quot;,  <br>  &quot;members&quot;: [  <br>    &#123;  <br>      &quot;_id&quot;: 0,  <br>      &quot;name&quot;: &quot;180.76.159.126:27017&quot;,  <br>      &quot;health&quot;: 1,  <br>      &quot;state&quot;: 1,  <br>      &quot;stateStr&quot;: &quot;PRIMARY&quot;,  <br>      &quot;uptime&quot;: 419,  <br>      &quot;optime&quot;: &#123;  <br>        &quot;ts&quot;: &quot;Timestamp(1565760578, 1)&quot;,  <br>        &quot;t&quot;: &quot;NumberLong(1)&quot;  <br>      &#125;,  <br>      &quot;optimeDate&quot;: &quot;ISODate(\&quot;2019-08-14T05:29:38Z\&quot;)&quot;,  <br>      &quot;syncingTo&quot;: &quot;&quot;,  <br>      &quot;syncSourceHost&quot;: &quot;&quot;,  <br>      &quot;syncSourceId&quot;: -1,  <br>      &quot;infoMessage&quot;: &quot;could not find member to sync from&quot;,  <br>      &quot;electionTime&quot;: &quot;Timestamp(1565760476, 2)&quot;,  <br>      &quot;electionDate&quot;: &quot;ISODate(\&quot;2019-08-14T05:27:56Z\&quot;)&quot;,  <br>      &quot;configVersion&quot;: 1,  <br>      &quot;self&quot;: true,  <br>      &quot;lastHeartbeatMessage&quot;: &quot;&quot;  <br>    &#125;  <br>  ],  <br>  &quot;ok&quot;: 1,  <br>  &quot;operationTime&quot;: &quot;Timestamp(1565760578, 1)&quot;,  <br>  &quot;$clusterTime&quot;: &#123;  <br>    &quot;clusterTime&quot;: &quot;Timestamp(1565760578, 1)&quot;,  <br>    &quot;signature&quot;: &#123;  <br>      &quot;hash&quot;: &quot;BinData(0,\&quot;AAAAAAAAAAAAAAAAAAAAAAAAAAA=\&quot;)&quot;,  <br>      &quot;keyId&quot;: &quot;NumberLong(0)&quot;  <br>    &#125;  <br>  &#125;  <br>&#125;<br></code></pre></td></tr></table></figure><p>说明：</p><p>1） “set” : “myrs” ：副本集的名字</p><p>2） “myState” : 1：说明状态正常</p><p>3） “members” ：副本集成员数组，此时只有一个： “name” : “180.76.159.126:27017” ，该成员的角色是 “stateStr” : “PRIMARY”, 该节点是健康的： “health” : 1 </p><h3 id="添加副本从节点"><a href="#添加副本从节点" class="headerlink" title="添加副本从节点"></a>添加副本从节点</h3><p>在主节点添加从节点，将其他成员加入到副本集</p><p>语法：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">rs.add(host, arbiterOnly)<br></code></pre></td></tr></table></figure><p>选项：</p><table><thead><tr><th><strong>Parameter</strong></th><th><strong>Type</strong></th><th><strong>Description</strong></th></tr></thead><tbody><tr><td>host</td><td>string or document</td><td>要添加到副本集的新成员。 指定为字符串或配置文档：1）如果是一个字符串，则需要指定新成员的主机名和可选的端口号；2）如果是一个文档，请指定在members数组中找到的副本集成员配置文档。 您必须在成员配置文档中指定主机字段。有关文档配置字段的说明，详见下方文档：“主机成员的配置文档”</td></tr><tr><td>arbiteronly</td><td>boolean</td><td>可选的。 仅在 <host> 值为字符串时适用。 如果为true，则添加的主机是仲裁者。</td></tr></tbody></table><p>主机成员的配置文档：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs shell">&#123;<br>  _id: &lt;int&gt;,<br>  host: &lt;string&gt;, // required<br>  arbiterOnly: &lt;boolean&gt;,<br>  buildIndexes: &lt;boolean&gt;,<br>  hidden: &lt;boolean&gt;,<br>  priority: &lt;number&gt;,<br>  tags: &lt;document&gt;,<br>  slaveDelay: &lt;int&gt;,<br>  votes: &lt;number&gt;<br>&#125;<br></code></pre></td></tr></table></figure><p>【示例】</p><p>将27018的副本节点添加到副本集中：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs shell">myrs:PRIMARY&gt; rs.add(&quot;180.76.159.126:27018&quot;)<br>&#123;  <br>  &quot;ok&quot;: 1,  <br>  &quot;operationTime&quot;: &quot;Timestamp(1565761757, 1)&quot;,  <br>  &quot;$clusterTime&quot;: &#123;  <br>    &quot;clusterTime&quot;: &quot;Timestamp(1565761757, 1)&quot;,  <br>    &quot;signature&quot;: &#123;  <br>      &quot;hash&quot;: &quot;BinData(0,\&quot;AAAAAAAAAAAAAAAAAAAAAAAAAAA=\&quot;)&quot;,  <br>      &quot;keyId&quot;: &quot;NumberLong(0)&quot;  <br>    &#125;  <br>  &#125;  <br>&#125;<br></code></pre></td></tr></table></figure><p>说明：</p><p>1） “ok” : 1 ：说明添加成功。</p><p>查看副本集状态：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><code class="hljs shell">myrs:PRIMARY&gt; rs.status()<br>&#123;<br>    &quot;set&quot; : &quot;myrs&quot;,<br>    &quot;date&quot; : ISODate(&quot;2019-08-14T05:50:05.738Z&quot;),<br>    &quot;myState&quot; : 1,<br>    &quot;term&quot; : NumberLong(1),<br>    &quot;syncingTo&quot; : &quot;&quot;,<br>    &quot;syncSourceHost&quot; : &quot;&quot;,<br>    &quot;syncSourceId&quot; : -1,<br>    &quot;heartbeatIntervalMillis&quot; : NumberLong(2000),<br>    &quot;optimes&quot; : &#123;<br>        &quot;lastCommittedOpTime&quot; : &#123;<br>            &quot;ts&quot; : Timestamp(1565761798, 1),<br>            &quot;t&quot; : NumberLong(1)<br>        &#125;,<br>        &quot;readConcernMajorityOpTime&quot; : &#123;<br>            &quot;ts&quot; : Timestamp(1565761798, 1),<br>            &quot;t&quot; : NumberLong(1)<br>        &#125;,<br>        &quot;appliedOpTime&quot; : &#123;<br>            &quot;ts&quot; : Timestamp(1565761798, 1),<br>            &quot;t&quot; : NumberLong(1)<br>        &#125;,<br>        &quot;durableOpTime&quot; : &#123;<br>            &quot;ts&quot; : Timestamp(1565761798, 1),<br>            &quot;t&quot; : NumberLong(1)<br>        &#125;<br>    &#125;,<br>    &quot;lastStableCheckpointTimestamp&quot; : Timestamp(1565761798, 1),<br>    &quot;members&quot; : [<br>        &#123;<br>            &quot;_id&quot; : 0,<br>            &quot;name&quot; : &quot;180.76.159.126:27017&quot;,<br>            &quot;health&quot; : 1,<br>            &quot;state&quot; : 1,<br>            &quot;stateStr&quot; : &quot;PRIMARY&quot;,<br>            &quot;uptime&quot; : 1639,<br>            &quot;optime&quot; : &#123;<br>                &quot;ts&quot; : Timestamp(1565761798, 1),<br>                &quot;t&quot; : NumberLong(1)<br>            &#125;,<br>            &quot;optimeDate&quot; : ISODate(&quot;2019-08-14T05:49:58Z&quot;),<br>            &quot;syncingTo&quot; : &quot;&quot;,<br>            &quot;syncSourceHost&quot; : &quot;&quot;,<br>            &quot;syncSourceId&quot; : -1,<br>            &quot;infoMessage&quot; : &quot;&quot;,<br>            &quot;electionTime&quot; : Timestamp(1565760476, 2),<br>            &quot;electionDate&quot; : ISODate(&quot;2019-08-14T05:27:56Z&quot;),<br>            &quot;configVersion&quot; : 2,<br>            &quot;self&quot; : true,<br>            &quot;lastHeartbeatMessage&quot; : &quot;&quot;<br>        &#125;,<br>        &#123;<br>            &quot;_id&quot; : 1,<br>            &quot;name&quot; : &quot;180.76.159.126:27018&quot;,<br>            &quot;health&quot; : 1,<br>            &quot;state&quot; : 2,<br>            &quot;stateStr&quot; : &quot;SECONDARY&quot;,<br>            &quot;uptime&quot; : 48,<br>            &quot;optime&quot; : &#123;<br>                &quot;ts&quot; : Timestamp(1565761798, 1),<br>                &quot;t&quot; : NumberLong(1)<br>            &#125;,<br>            &quot;optimeDurable&quot; : &#123;<br>                &quot;ts&quot; : Timestamp(1565761798, 1),<br>                &quot;t&quot; : NumberLong(1)<br>            &#125;,<br>            &quot;optimeDate&quot; : ISODate(&quot;2019-08-14T05:49:58Z&quot;),<br>            &quot;optimeDurableDate&quot; : ISODate(&quot;2019-08-14T05:49:58Z&quot;),<br>            &quot;lastHeartbeat&quot; : ISODate(&quot;2019-08-14T05:50:05.294Z&quot;),<br>            &quot;lastHeartbeatRecv&quot; : ISODate(&quot;2019-08-14T05:50:05.476Z&quot;),<br>            &quot;pingMs&quot; : NumberLong(0),<br>            &quot;lastHeartbeatMessage&quot; : &quot;&quot;,<br>            &quot;syncingTo&quot; : &quot;180.76.159.126:27017&quot;,<br>            &quot;syncSourceHost&quot; : &quot;180.76.159.126:27017&quot;,<br>            &quot;syncSourceId&quot; : 0,<br>            &quot;infoMessage&quot; : &quot;&quot;,<br>            &quot;configVersion&quot; : 2<br>        &#125;<br>    ],<br>    &quot;ok&quot; : 1,<br>    &quot;operationTime&quot; : Timestamp(1565761798, 1),<br>    &quot;$clusterTime&quot; : &#123;<br>        &quot;clusterTime&quot; : Timestamp(1565761798, 1),<br>        &quot;signature&quot; : &#123;<br>            &quot;hash&quot; : BinData(0, &quot;AAAAAAAAAAAAAAAAAAAAAAAAAAA=&quot;),<br>            &quot;keyId&quot; : NumberLong(0)<br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>说明：</p><p>1） “name” : “180.76.159.126:27018” 是第二个节点的名字，其角色是 “stateStr” : “SECONDARY”</p><h3 id="添加仲裁节点"><a href="#添加仲裁节点" class="headerlink" title="添加仲裁节点"></a>添加仲裁节点</h3><p>添加一个仲裁节点到副本集</p><p>语法：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">rs.addArb(host)<br></code></pre></td></tr></table></figure><p>将27019的仲裁节点添加到副本集中：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs shell">myrs:PRIMARY&gt; rs.addArb(&quot;180.76.159.126:27019&quot;)<br>&#123;<br>    &quot;ok&quot; : 1,<br>    &quot;operationTime&quot; : Timestamp(1565761959, 1),<br>    &quot;$clusterTime&quot; : &#123;<br>        &quot;clusterTime&quot; : Timestamp(1565761959, 1),<br>        &quot;signature&quot; : &#123;<br>            &quot;hash&quot; : BinData(0,&quot;AAAAAAAAAAAAAAAAAAAAAAAAAAA=&quot;),<br>            &quot;keyId&quot; : NumberLong(0)<br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>说明：</p><p>1） “ok” : 1 ：说明添加成功。</p><p>查看副本集状态：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><code class="hljs shell">myrs:PRIMARY&gt; rs.status()<br>&#123;<br>    &quot;set&quot; : &quot;myrs&quot;,<br>    &quot;date&quot; : ISODate(&quot;2019-08-14T05:53:27.198Z&quot;),<br>    &quot;myState&quot; : 1,<br>    &quot;term&quot; : NumberLong(1),<br>    &quot;syncingTo&quot; : &quot;&quot;,<br>    &quot;syncSourceHost&quot; : &quot;&quot;,<br>    &quot;syncSourceId&quot; : -1,<br>    &quot;heartbeatIntervalMillis&quot; : NumberLong(2000),<br>    &quot;optimes&quot; : &#123;<br>        &quot;lastCommittedOpTime&quot; : &#123;<br>            &quot;ts&quot; : Timestamp(1565761998, 1),<br>            &quot;t&quot; : NumberLong(1)<br>        &#125;,<br>        &quot;readConcernMajorityOpTime&quot; : &#123;<br>            &quot;ts&quot; : Timestamp(1565761998, 1),<br>            &quot;t&quot; : NumberLong(1)<br>        &#125;,<br>        &quot;appliedOpTime&quot; : &#123;<br>            &quot;ts&quot; : Timestamp(1565761998, 1),<br>            &quot;t&quot; : NumberLong(1)<br>        &#125;,<br>        &quot;durableOpTime&quot; : &#123;<br>            &quot;ts&quot; : Timestamp(1565761998, 1),<br>            &quot;t&quot; : NumberLong(1)<br>        &#125;<br>    &#125;,<br>    &quot;lastStableCheckpointTimestamp&quot; : Timestamp(1565761978, 1),<br>    &quot;members&quot; : [<br>        &#123;<br>            &quot;_id&quot; : 0,<br>            &quot;name&quot; : &quot;180.76.159.126:27017&quot;,<br>            &quot;health&quot; : 1,<br>            &quot;state&quot; : 1,<br>            &quot;stateStr&quot; : &quot;PRIMARY&quot;,<br>            &quot;uptime&quot; : 1841,<br>            &quot;optime&quot; : &#123;<br>                &quot;ts&quot; : Timestamp(1565761998, 1),<br>                &quot;t&quot; : NumberLong(1)<br>            &#125;,<br>            &quot;optimeDate&quot; : ISODate(&quot;2019-08-14T05:53:18Z&quot;),<br>            &quot;syncingTo&quot; : &quot;&quot;,<br>            &quot;syncSourceHost&quot; : &quot;&quot;,<br>            &quot;syncSourceId&quot; : -1,<br>            &quot;infoMessage&quot; : &quot;&quot;,<br>            &quot;electionTime&quot; : Timestamp(1565760476, 2),<br>            &quot;electionDate&quot; : ISODate(&quot;2019-08-14T05:27:56Z&quot;),<br>            &quot;configVersion&quot; : 3,<br>            &quot;self&quot; : true,<br>            &quot;lastHeartbeatMessage&quot; : &quot;&quot;<br>        &#125;,<br>        &#123;<br>            &quot;_id&quot; : 1,<br>            &quot;name&quot; : &quot;180.76.159.126:27018&quot;,<br>            &quot;health&quot; : 1,<br>            &quot;state&quot; : 2,<br>            &quot;stateStr&quot; : &quot;SECONDARY&quot;,<br>            &quot;uptime&quot; : 249,<br>            &quot;optime&quot; : &#123;<br>                &quot;ts&quot; : Timestamp(1565761998, 1),<br>                &quot;t&quot; : NumberLong(1)<br>            &#125;,<br>            &quot;optimeDurable&quot; : &#123;<br>                &quot;ts&quot; : Timestamp(1565761998, 1),<br>                &quot;t&quot; : NumberLong(1)<br>            &#125;,<br>            &quot;optimeDate&quot; : ISODate(&quot;2019-08-14T05:53:18Z&quot;),<br>            &quot;optimeDurableDate&quot; : ISODate(&quot;2019-08-14T05:53:18Z&quot;),<br>            &quot;lastHeartbeat&quot; : ISODate(&quot;2019-08-14T05:53:25.668Z&quot;),<br>            &quot;lastHeartbeatRecv&quot; : ISODate(&quot;2019-08-14T05:53:26.702Z&quot;),<br>            &quot;pingMs&quot; : NumberLong(0),<br>            &quot;lastHeartbeatMessage&quot; : &quot;&quot;,<br>            &quot;syncingTo&quot; : &quot;180.76.159.126:27017&quot;,<br>            &quot;syncSourceHost&quot; : &quot;180.76.159.126:27017&quot;,<br>            &quot;syncSourceId&quot; : 0,<br>            &quot;infoMessage&quot; : &quot;&quot;,<br>            &quot;configVersion&quot; : 3<br>        &#125;,<br>        &#123;<br>            &quot;_id&quot; : 2,<br>            &quot;name&quot; : &quot;180.76.159.126:27019&quot;,<br>            &quot;health&quot; : 1,<br>            &quot;state&quot; : 7,<br>            &quot;stateStr&quot; : &quot;ARBITER&quot;,<br>            &quot;uptime&quot; : 47,<br>            &quot;lastHeartbeat&quot; : ISODate(&quot;2019-08-14T05:53:25.668Z&quot;),<br>            &quot;lastHeartbeatRecv&quot; : ISODate(&quot;2019-08-14T05:53:25.685Z&quot;),<br>            &quot;pingMs&quot; : NumberLong(0),<br>            &quot;lastHeartbeatMessage&quot; : &quot;&quot;,<br>            &quot;syncingTo&quot; : &quot;&quot;,<br>            &quot;syncSourceHost&quot; : &quot;&quot;,<br>            &quot;syncSourceId&quot; : -1,<br>            &quot;infoMessage&quot; : &quot;&quot;,<br>            &quot;configVersion&quot; : 3<br>        &#125;<br>    ],<br>    &quot;ok&quot; : 1,<br>    &quot;operationTime&quot; : Timestamp(1565761998, 1),<br>    &quot;$clusterTime&quot; : &#123;<br>        &quot;clusterTime&quot; : Timestamp(1565761998, 1),<br>        &quot;signature&quot; : &#123;<br>            &quot;hash&quot; : BinData(0,&quot;AAAAAAAAAAAAAAAAAAAAAAAAAAA=&quot;),<br>            &quot;keyId&quot; : NumberLong(0)<br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>说明：</p><p>1） “name” : “180.76.159.126:27019” 是第二个节点的名字，其角色是 “stateStr” : “ARBITER”</p><h2 id="副本集的读写操作"><a href="#副本集的读写操作" class="headerlink" title="副本集的读写操作"></a>副本集的读写操作</h2><p>目标：测试三个不同角色的节点的数据读写情况。</p><p>登录主节点27017，写入和读取数据：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@bobohost ~]# /usr/local/mongodb/bin/mongo --host 180.76.159.126 --port<br>27017<br>myrs:PRIMARY&gt; use articledb<br>switched to db articledb<br>myrs:PRIMARY&gt; db<br>articledb<br>myrs:PRIMARY&gt; db.comment.insert(&#123;&quot;articleid&quot;:&quot;100000&quot;,&quot;content&quot;:&quot;今天天气真好，阳光<br>明媚&quot;,&quot;userid&quot;:&quot;1001&quot;,&quot;nickname&quot;:&quot;Rose&quot;,&quot;createdatetime&quot;:new Date()&#125;)<br>WriteResult(&#123; &quot;nInserted&quot; : 1 &#125;)<br>myrs:PRIMARY&gt; db.comment.find()<br>&#123; &quot;_id&quot; : ObjectId(&quot;5d4d2ae3068138b4570f53bf&quot;), &quot;articleid&quot; : &quot;100000&quot;,<br>&quot;content&quot; : &quot;今天天气真好，阳光明媚&quot;, &quot;userid&quot; : &quot;1001&quot;, &quot;nickname&quot; : &quot;Rose&quot;,<br>&quot;createdatetime&quot; : ISODate(&quot;2019-08-09T08:12:19.427Z&quot;) &#125;<br></code></pre></td></tr></table></figure><p>登录从节点27018</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@bobohost ~]# /usr/local/mongodb/bin/mongo --host 180.76.159.126 --port<br>27018<br>myrs:SECONDARY&gt; show dbs;<br>2019-09-10T10:56:51.953+0800 E QUERY [js] Error: listDatabases failed:&#123;<br>  &quot;operationTime&quot; : Timestamp(1568084204, 1),<br>  &quot;ok&quot; : 0,<br>  &quot;errmsg&quot; : &quot;not master and slaveOk=false&quot;,<br>  &quot;code&quot; : 13435,<br>  &quot;codeName&quot; : &quot;NotMasterNoSlaveOk&quot;,<br>  &quot;$clusterTime&quot; : &#123;<br>    &quot;clusterTime&quot; : Timestamp(1568084204, 1),<br>    &quot;signature&quot; : &#123;<br>      &quot;hash&quot; : BinData(0,&quot;AAAAAAAAAAAAAAAAAAAAAAAAAAA=&quot;),<br>      &quot;keyId&quot; : NumberLong(0)<br>    &#125;<br>  &#125;<br>&#125; :<br>_getErrorWithCode@src/mongo/shell/utils.js:25:13<br>Mongo.prototype.getDBs@src/mongo/shell/mongo.js:139:1<br>shellHelper.show@src/mongo/shell/utils.js:882:13<br>shellHelper@src/mongo/shell/utils.js:766:15<br>@(shellhelp2):1:1<br></code></pre></td></tr></table></figure><p>发现，不能读取集合的数据。当前从节点只是一个备份，不是奴隶节点，无法读取数据，写当然更不行。</p><p>因为默认情况下，从节点是没有读写权限的，可以增加读的权限，但需要进行设置。</p><p>设置读操作权限：</p><p>说明：</p><p>设置为奴隶节点，允许在从成员上运行读的操作</p><p>语法：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">rs.slaveOk()<br><span class="hljs-meta prompt_">#</span><span class="language-bash">或</span><br>rs.slaveOk(true)<br></code></pre></td></tr></table></figure><p>提示：</p><p>该命令是 db.getMongo().setSlaveOk() 的简化命令。</p><p>【示例】</p><p>在27018上设置作为奴隶节点权限，具备读权限：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">rs:SECONDARY&gt; rs.slaveOk()<br></code></pre></td></tr></table></figure><p>此时，在执行查询命令，运行成功！</p><p>但仍然不允许插入。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs shell">myrs:SECONDARY&gt; rs.slaveOk()<br>myrs:SECONDARY&gt; show dbs;<br>admin 0.000GB<br>articledb 0.000GB<br>config 0.000GB<br>local 0.000GB<br>myrs:SECONDARY&gt; use articledb<br>switched to db articledb<br>myrs:SECONDARY&gt; show collections<br>comment<br>myrs:SECONDARY&gt; db.comment.find()<br>&#123; &quot;_id&quot; : ObjectId(&quot;5d7710c04cfd7eee2e3cdabe&quot;), &quot;articleid&quot; : &quot;100000&quot;,<br>&quot;content&quot; : &quot;今天天气真好，阳光明媚&quot;, &quot;userid&quot; : &quot;1001&quot;, &quot;nickname&quot; : &quot;Rose&quot;,<br>&quot;createdatetime&quot; : ISODate(&quot;2019-09-10T02:56:00.467Z&quot;) &#125;<br>myrs:SECONDARY&gt; db.comment.insert(&#123;&quot;_id&quot;:&quot;1&quot;,&quot;articleid&quot;:&quot;100001&quot;,&quot;content&quot;:&quot;我们<br>不应该把清晨浪费在手机上，健康很重要，k一杯温水幸福你我<br>他。&quot;,&quot;userid&quot;:&quot;1002&quot;,&quot;nickname&quot;:&quot;相忘于江湖&quot;,&quot;createdatetime&quot;:new Date(&quot;2019-08-<br>05T22:08:15.522Z&quot;),&quot;likenum&quot;:NumberInt(1000),&quot;state&quot;:&quot;1&quot;&#125;)<br>WriteCommandError(&#123;<br>  &quot;operationTime&quot; : Timestamp(1568084434, 1),<br>  &quot;ok&quot; : 0,<br>  &quot;errmsg&quot; : &quot;not master&quot;,<br>  &quot;code&quot; : 10107,<br>  &quot;codeName&quot; : &quot;NotMaster&quot;,<br>  &quot;$clusterTime&quot; : &#123;<br>  &quot;clusterTime&quot; : Timestamp(1568084434, 1),<br>    &quot;signature&quot; : &#123;<br>      &quot;hash&quot; : BinData(0,&quot;AAAAAAAAAAAAAAAAAAAAAAAAAAA=&quot;),<br>      &quot;keyId&quot; : NumberLong(0)<br>    &#125;<br>  &#125;<br>&#125;)<br></code></pre></td></tr></table></figure><p>现在可实现了读写分离，让主插入数据，让从来读取数据。</p><p>如果要取消作为奴隶节点的读权限：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs shell">myrs:SECONDARY&gt; rs.slaveOk(false)<br>myrs:SECONDARY&gt; db.comment.find()<br>Error: error: &#123;<br>  &quot;operationTime&quot; : Timestamp(1568084459, 1),<br>  &quot;ok&quot; : 0,<br>  &quot;errmsg&quot; : &quot;not master and slaveOk=false&quot;,<br>  &quot;code&quot; : 13435,<br>  &quot;codeName&quot; : &quot;NotMasterNoSlaveOk&quot;,<br>  &quot;$clusterTime&quot; : &#123;<br>    &quot;clusterTime&quot; : Timestamp(1568084459, 1),<br>    &quot;signature&quot; : &#123;<br>      &quot;hash&quot; : BinData(0,&quot;AAAAAAAAAAAAAAAAAAAAAAAAAAA=&quot;),<br>      &quot;keyId&quot; : NumberLong(0)<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>仲裁者节点，不存放任何业务数据的，可以登录查看</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@bobohost ~]# /usr/local/mongodb/bin/mongo --host 180.76.159.126 --port<br>27019<br>myrs:ARBITER&gt; rs.slaveOk()<br>myrs:ARBITER&gt; show dbs<br>local 0.000GB<br>myrs:ARBITER&gt; use local<br>switched to db local<br>myrs:ARBITER&gt; show collections<br>replset.minvalid<br>replset.oplogTruncateAfterPoint<br>startup_log<br>system.replset<br>system.rollback.id<br>myrs:ARBITER&gt;<br></code></pre></td></tr></table></figure><p>发现，只存放副本集配置等数据。</p><h2 id="主节点的选举原则"><a href="#主节点的选举原则" class="headerlink" title="主节点的选举原则"></a>主节点的选举原则</h2><p>MongoDB在副本集中，会自动进行主节点的选举，主节点选举的触发条件：</p><p>1） 主节点故障</p><p>2） 主节点网络不可达（默认心跳信息为10秒）</p><p>3） 人工干预（rs.stepDown(600)）</p><p>一旦触发选举，就要根据一定规则来选主节点。</p><p>选举规则是根据票数来决定谁获胜：</p><ul><li>票数最高，且获得了“大多数”成员的投票支持的节点获胜。“大多数”的定义为：假设复制集内投票成员数量为N，则大多数为 N&#x2F;2 + 1。例如：3个投票成员，则大多数的值是2。当复制集内存活成员数量不足大多数时，整个复制集将无法选举出Primary，复制集将无法提供写服务，处于只读状态。</li><li>若票数相同，且都获得了“大多数”成员的投票支持的，数据新的节点获胜。数据的新旧是通过操作日志oplog来对比的。</li></ul><p>在获得票数的时候，优先级（priority）参数影响重大。</p><p>可以通过设置优先级（priority）来设置额外票数。优先级即权重，取值为0-1000，相当于可额外增加0-1000的票数，优先级的值越大，就越可能获得多数成员的投票（votes）数。指定较高的值可使成员更有资格成为主要成员，更低的值可使成员更不符合条件。</p><p>默认情况下，优先级的值是1</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs shell">myrs:PRIMARY&gt; rs.conf()<br>&#123;<br>    &quot;_id&quot; : &quot;myrs&quot;,<br>    &quot;version&quot; : 3,<br>    &quot;protocolVersion&quot; : NumberLong(1),<br>    &quot;writeConcernMajorityJournalDefault&quot; : true,<br>    &quot;members&quot; : [<br>        &#123;<br>            &quot;_id&quot; : 0,<br>            &quot;host&quot; : &quot;180.76.159.126:27017&quot;,<br>            &quot;arbiterOnly&quot; : false,<br>            &quot;buildIndexes&quot; : true,<br>            &quot;hidden&quot; : false,<br>            &quot;priority&quot; : 1,<br>            &quot;tags&quot; : &#123;&#125;,<br>            &quot;slaveDelay&quot; : NumberLong(0),<br>            &quot;votes&quot; : 1<br>        &#125;,<br>        &#123;<br>            &quot;_id&quot; : 1,<br>            &quot;host&quot; : &quot;180.76.159.126:27018&quot;,<br>            &quot;arbiterOnly&quot; : false,<br>            &quot;buildIndexes&quot; : true,<br>            &quot;hidden&quot; : false,<br>            &quot;priority&quot; : 1,<br>            &quot;tags&quot; : &#123;&#125;,<br>            &quot;slaveDelay&quot; : NumberLong(0),<br>            &quot;votes&quot; : 1<br>        &#125;,<br>        &#123;<br>            &quot;_id&quot; : 2,<br>            &quot;host&quot; : &quot;180.76.159.126:27019&quot;,<br>            &quot;arbiterOnly&quot; : true,<br>            &quot;buildIndexes&quot; : true,<br>            &quot;hidden&quot; : false,<br>            &quot;priority&quot; : 0,<br>            &quot;tags&quot; : &#123;&#125;,<br>            &quot;slaveDelay&quot; : NumberLong(0),<br>            &quot;votes&quot; : 1<br>        &#125;<br>    ],<br>    &quot;settings&quot; : &#123;<br>        &quot;chainingAllowed&quot; : true,<br>        &quot;heartbeatIntervalMillis&quot; : 2000,<br>        &quot;heartbeatTimeoutSecs&quot; : 10,<br>        &quot;electionTimeoutMillis&quot; : 10000,<br>        &quot;catchUpTimeoutMillis&quot; : -1,<br>        &quot;catchUpTakeoverDelayMillis&quot; : 30000,<br>        &quot;getLastErrorModes&quot; : &#123;&#125;,<br>        &quot;getLastErrorDefaults&quot; : &#123;<br>            &quot;w&quot; : 1,<br>            &quot;wtimeout&quot; : 0<br>        &#125;,<br>        &quot;replicaSetId&quot; : ObjectId(&quot;5d539bdcd6a308e600d126bb&quot;)<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>可以看出，主节点和副本节点的优先级各为1，即，默认可以认为都已经有了一票。但选举节点，优先级是0，（要注意是，官方说了，选举节点的优先级必须是0，不能是别的值。即不具备选举权，但具有投票权）</p><p>【了解】修改优先级</p><p>比如，下面提升从节点的优先级：</p><p>1）先将配置导入cfg变量</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">myrs:SECONDARY&gt; cfg=rs.conf()<br></code></pre></td></tr></table></figure><p>2）然后修改值（ID号默认从0开始）：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">myrs:SECONDARY&gt; cfg.members[1].priority=2<br>2<br></code></pre></td></tr></table></figure><p>3）重新加载配置</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">myrs:SECONDARY&gt; rs.reconfig(cfg)<br>&#123; &quot;ok&quot; : 1 &#125;<br></code></pre></td></tr></table></figure><p>稍等片刻会重新开始选举。</p><h2 id="故障测试"><a href="#故障测试" class="headerlink" title="故障测试"></a>故障测试</h2><h3 id="副本节点故障测试"><a href="#副本节点故障测试" class="headerlink" title="副本节点故障测试"></a>副本节点故障测试</h3><p>关闭27018副本节点：</p><p>发现，主节点和仲裁节点对27018的心跳失败。因为主节点还在，因此，没有触发投票选举。</p><p>如果此时，在主节点写入数据。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">db.comment.insert(&#123;&quot;_id&quot;:&quot;1&quot;,&quot;articleid&quot;:&quot;100001&quot;,&quot;content&quot;:&quot;我们不应该把清晨浪费在<br>手机上，健康很重要，一杯温水幸福你我他。&quot;,&quot;userid&quot;:&quot;1002&quot;,&quot;nickname&quot;:&quot;相忘于江<br>湖&quot;,&quot;createdatetime&quot;:new Date(&quot;2019-08-<br>05T22:08:15.522Z&quot;),&quot;likenum&quot;:NumberInt(1000),&quot;state&quot;:&quot;1&quot;&#125;)<br></code></pre></td></tr></table></figure><p>再启动从节点，会发现，主节点写入的数据，会自动同步给从节点。</p><h3 id="主节点故障测试"><a href="#主节点故障测试" class="headerlink" title="主节点故障测试"></a>主节点故障测试</h3><p>关闭27017节点</p><p>发现，从节点和仲裁节点对27017的心跳失败，当失败超过10秒，此时因为没有主节点了，会自动发起投票。</p><p>而副本节点只有27018，因此，候选人只有一个就是27018，开始投票。</p><p>27019向27018投了一票，27018本身自带一票，因此共两票，超过了“大多数”</p><p>27019是仲裁节点，没有选举权，27018不向其投票，其票数是0.</p><p>最终结果，27018成为主节点。具备读写功能。</p><p>在27018写入数据查看。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">db.comment.insert(&#123;&quot;_id&quot;:&quot;2&quot;,&quot;articleid&quot;:&quot;100001&quot;,&quot;content&quot;:&quot;我夏天空腹喝凉开水，冬<br>天喝温开水&quot;,&quot;userid&quot;:&quot;1005&quot;,&quot;nickname&quot;:&quot;伊人憔悴&quot;,&quot;createdatetime&quot;:new Date(&quot;2019-<br>08-05T23:58:51.485Z&quot;),&quot;likenum&quot;:NumberInt(888),&quot;state&quot;:&quot;1&quot;&#125;)<br></code></pre></td></tr></table></figure><p>再启动27017节点，发现27017变成了从节点，27018仍保持主节点。</p><p>登录27017节点，发现是从节点了，数据自动从27018同步。</p><p>从而实现了高可用。</p><h3 id="仲裁节点和主节点故障"><a href="#仲裁节点和主节点故障" class="headerlink" title="仲裁节点和主节点故障"></a>仲裁节点和主节点故障</h3><p>先关掉仲裁节点27019，</p><p>关掉现在的主节点27018</p><p>登录27017后，发现，27017仍然是从节点，副本集中没有主节点了，导致此时，副本集是只读状态，无法写入。</p><p>为啥不选举了？因为27017的票数，没有获得大多数，即没有大于等于2，它只有默认的一票（优先级是1）</p><p>如果要触发选举，随便加入一个成员即可。</p><ul><li>如果只加入27019仲裁节点成员，则主节点一定是27017，因为没得选了，仲裁节点不参与选举，但参与投票。（不演示）</li><li>如果只加入27018节点，会发起选举。因为27017和27018都是两票，则按照谁数据新，谁当主节点。</li></ul><h3 id="仲裁节点和从节点故障"><a href="#仲裁节点和从节点故障" class="headerlink" title="仲裁节点和从节点故障"></a>仲裁节点和从节点故障</h3><p>先关掉仲裁节点27019，</p><p>关掉现在的副本节点27018</p><p>10秒后，27017主节点自动降级为副本节点。（服务降级）</p><p>副本集不可写数据了，已经故障了。</p><h2 id="连接副本集"><a href="#连接副本集" class="headerlink" title="连接副本集"></a>连接副本集</h2><p>MongoDB客户端连接语法：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">mongodb://[username:password@]host1[:port1][,host2[:port2],...[,hostN[:portN]]]<br>[/[database][?options]]<br></code></pre></td></tr></table></figure><ul><li><p><strong>mongodb:&#x2F;&#x2F;</strong> 这是固定的格式，必须要指定。</p></li><li><p><strong>username:password@</strong> 可选项，如果设置，在连接数据库服务器之后，驱动都会尝试登陆这个数据库</p></li><li><p><strong>host1</strong> 必须的指定至少一个host, host1 是这个URI唯一要填写的。它指定了要连接服务器的地址。如果要连接复制集，请指定多个主机地址。</p></li><li><p><strong>portX</strong> 可选的指定端口，如果不填，默认为27017</p></li><li><p><strong>&#x2F;database</strong> 如果指定username:password@，连接并验证登陆指定数据库。若不指定，默认打开test 数据库。</p></li><li><p><strong>?options</strong> 是连接选项。如果不使用&#x2F;database，则前面需要加上&#x2F;。所有连接选项都是键值对name&#x3D;value，键值对之间通过&amp;或;（分号）隔开</p></li></ul><p>标准的连接格式包含了多个选项(options)，如下所示：</p><table><thead><tr><th>选项</th><th>描述</th></tr></thead><tbody><tr><td>replicaSet&#x3D;name</td><td>验证replica set的名称。 Impliesconnect&#x3D;replicaSet.</td></tr><tr><td>slaveOk&#x3D;true|false</td><td>true:在connect&#x3D;direct模式下，驱动会连接第一台机器，即使这台服务器不是主。在connect&#x3D;replicaSet模式下，驱动会发送所有的写请求到主并且把读取操作分布在其他从服务器。false: 在connect&#x3D;direct模式下，驱动会自动找寻主服务器. 在connect&#x3D;replicaSet 模式下，驱动仅仅连接主服务器，并且所有的读写命令都连接到主服务器。</td></tr><tr><td>safe&#x3D;true|false</td><td>true: 在执行更新操作之后，驱动都会发送getLastError命令来确保更新成功。(还要参考 wtimeoutMS).false: 在每次更新之后，驱动不会发送getLastError来确保更新成功</td></tr><tr><td>w&#x3D;n</td><td>驱动添加 { w : n } 到getLastError命令. 应用于safe&#x3D;true。</td></tr><tr><td>wtimeoutMS&#x3D;ms</td><td>驱动添加 { wtimeout : ms } 到 getlasterror 命令. 应用于 safe&#x3D;true.</td></tr><tr><td>fsync&#x3D;true|false</td><td>true: 驱动添加 { fsync : true } 到 getlasterror 命令.应用于safe&#x3D;true.false: 驱动不会添加到getLastError命令中。</td></tr><tr><td>journal&#x3D;true|false</td><td>如果设置为 true, 同步到 journal (在提交到数据库前写入到实体中).应用于 safe&#x3D;true</td></tr><tr><td>connectTimeoutMS&#x3D;ms</td><td>可以打开连接的时间。</td></tr><tr><td>socketTimeoutMS&#x3D;ms</td><td>发送和接受sockets的时间。</td></tr></tbody></table><h1 id="分片"><a href="#分片" class="headerlink" title="分片"></a>分片</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>分片（sharding）是一种跨多台机器分布数据的方法， MongoDB使用分片来支持具有非常大的数据集</p><p>和高吞吐量操作的部署。</p><p>换句话说：分片(sharding)是指将数据拆分，将其分散存在不同的机器上的过程。有时也用分区(partitioning)来表示这个概念。将数据分散到不同的机器上，不需要功能强大的大型计算机就可以储存更多的数据，处理更多的负载。</p><p>具有大型数据集或高吞吐量应用程序的数据库系统可以会挑战单个服务器的容量。例如，高查询率会耗尽服务器的CPU容量。工作集大小大于系统的RAM会强调磁盘驱动器的I &#x2F; O容量。</p><p>有两种解决系统增长的方法：垂直扩展和水平扩展。</p><p>垂直扩展意味着增加单个服务器的容量，例如使用更强大的CPU，添加更多RAM或增加存储空间量。可用技术的局限性可能会限制单个机器对于给定工作负载而言足够强大。此外，基于云的提供商基于可用的硬件配置具有硬性上限。结果，垂直缩放有实际的最大值。水平扩展意味着划分系统数据集并加载多个服务器，添加其他服务器以根据需要增加容量。虽然单个机器的总体速度或容量可能不高，但每台机器处理整个工作负载的子集，可能提供比单个高速大容量服务器更高的效率。扩展部署容量只需要根据需要添加额外的服务器，这可能比单个机器的高端硬件的总体成本更低。权衡是基础架构和部署维护的复杂性增加。</p><p>MongoDB支持通过分片进行水平扩展。</p><h2 id="分片集群包含的组件"><a href="#分片集群包含的组件" class="headerlink" title="分片集群包含的组件"></a>分片集群包含的组件</h2><p>MongoDB分片群集包含以下组件：</p><ul><li><p>分片（存储）：每个分片包含分片数据的子集。 每个分片都可以部署为副本集。</p></li><li><p>mongos（路由）：mongos充当查询路由器，在客户端应用程序和分片集群之间提供接口。</p></li><li><p>config servers（“调度”的配置）：配置服务器存储群集的元数据和配置设置。 从MongoDB 3.4开始，必须将配置服务器部署为副本集（CSRS）。</p></li></ul><p>下图描述了分片集群中组件的交互：</p><p><img src="https://gxc-hexo-blog.oss-cn-beijing.aliyuncs.com/blog/%E5%88%86%E7%89%87.png" alt="分片"></p><p>MongoDB在集合级别对数据进行分片，将集合数据分布在集群中的分片上。</p><h2 id="分片集群架构目标"><a href="#分片集群架构目标" class="headerlink" title="分片集群架构目标"></a>分片集群架构目标</h2><p>两个分片节点副本集（3+3）+一个配置节点副本集（3）+两个路由节点（2），共11个服务节点。</p><p><img src="https://gxc-hexo-blog.oss-cn-beijing.aliyuncs.com/blog/%E5%88%86%E7%89%87%E9%9B%86%E7%BE%A4%E6%9E%B6%E6%9E%84%E7%9B%AE%E6%A0%87.png"></p>]]></content>
    
    
    <categories>
      
      <category>MongoDB</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据库</tag>
      
      <tag>MongoDB</tag>
      
      <tag>NoSQL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MongoDB基本使用</title>
    <link href="/2024/06/17/MongoDB%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/"/>
    <url>/2024/06/17/MongoDB%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="1-MongoDB介绍"><a href="#1-MongoDB介绍" class="headerlink" title="1. MongoDB介绍"></a>1. MongoDB介绍</h1><h2 id="1-1-MongoDB简介"><a href="#1-1-MongoDB简介" class="headerlink" title="1.1 MongoDB简介"></a>1.1 MongoDB简介</h2><p>MongoDB是一个开源、高性能、无模式的文档型数据库，当初的设计就是用于简化开发和方便扩展，是NoSQL数据库产品中的一种。是最像关系型数据库（MySQL）的非关系型数据库。</p><p>它支持的数据结构非常松散，是一种类似于 JSON 的 格式叫BSON，所以它既可以存储比较复杂的数据类型，又相当的灵活。</p><p>MongoDB中的记录是一个文档，它是一个由字段和值对（field:value）组成的数据结构。MongoDB文档类似于JSON对象，即一个文档认为就是一个对象。字段的数据类型是字符型，它的值除了使用基本的一些类型外，还可以包括其他文档、普通数组和文档数组。</p><h2 id="1-2-业务应用场景"><a href="#1-2-业务应用场景" class="headerlink" title="1.2 业务应用场景"></a>1.2 业务应用场景</h2><p>传统的关系型数据库（如MySQL），在数据操作的“三高”需求以及应对Web2.0的网站需求面前，显得力不从心。<strong>而MongoDB可以应对。</strong></p><p>解释：“三高”需求：</p><p>• High performance - 对数据库高并发读写的需求。</p><p>• Huge Storage - 对海量数据的高效率存储和访问的需求。</p><p>• High Scalability &amp;&amp; High Availability- 对数据库的高可扩展性和高可用性的需求。</p><p>MongoDB与MySQL对比</p><table>    <tr>      <td> </td>      <td> </td>      <td>MongoDB</td>      <td>MySQL</td>    </tr>    <tr>      <td rowspan="2">高并发性</td>      <td>架构设计</td>      <td>采用无模式（schema-less）设计，文档存储（BSON 格式），可以灵活处理变更数据结构。写入操作不需要锁定整个表或重新定义表结构，写性能较高。</td>      <td>使用固定模式（schema）设计，表结构变更（例如增加列）可能需要锁定整个表，影响写入性能。虽然支持事务和行级锁定，但在高并发写入时，锁争用仍可能成为瓶颈。</td>    </tr>    <tr>      <td>并发控制</td>      <td>使用优化的锁机制（如 WiredTiger 存储引擎中的多文档级锁），并且能够通过分片在多个节点上分散写入压力。</td>      <td>尽管支持行级锁（如 InnoDB 引擎），但在高并发场景下，锁冲突和死锁的概率增大，可能导致性能下降。</td>    </tr>    <tr>      <td rowspan="2">高存储能力</td>      <td>扩展性</td>      <td>内置分片（sharding）机制，可以将数据水平拆分到多个节点，几乎无限扩展存储容量，且分片管理自动化。</td>      <td>缺乏原生的分片机制，水平扩展需要手动配置分区、分库分表，管理复杂且成本高。MySQL Cluster 也能提供一定的扩展性，但配置和维护复杂度较高。</td>    </tr>    <tr>      <td>数据模型</td>      <td>文档模型（BSON）允许嵌套和数组，适用于复杂和非结构化数据，减少了表关联（JOIN）和多表查询的需求。</td>      <td>使用关系模型，数据规范化存储，复杂查询常需要 JOIN 操作。随着数据量增加，JOIN 操作的性能瓶颈更明显。</td>    </tr>    <tr>      <td rowspan="2">高可用性</td>      <td>复制与故障转移</td>      <td>内置复制集（Replica Sets）机制，支持自动故障转移。当主节点故障时，副本节点可以自动提升为主节点，确保高可用性。</td>      <td>支持主从复制和半同步复制，但自动故障转移需要额外配置（如使用 MHA 或 Percona XtraDB Cluster），增加了系统复杂度和维护难度。</td>    </tr>    <tr>      <td>分布式架构</td>      <td>从设计上就是分布式系统，支持地理分布的分片和复制，提高了系统的灾难恢复能力和全球可用性。</td>      <td>典型部署是集中式架构，虽然可以通过复制和分区实现一定程度的分布式，但不是原生支持，配置和维护更复杂。</td>    </tr>  </table><h2 id="1-3-概念解析"><a href="#1-3-概念解析" class="headerlink" title="1.3 概念解析"></a>1.3 概念解析</h2><table><thead><tr><th align="left">SQL术语&#x2F;概念</th><th align="left">MongoDB术语&#x2F;概念</th><th align="left">解释&#x2F;说明</th></tr></thead><tbody><tr><td align="left">database</td><td align="left">database</td><td align="left">数据库</td></tr><tr><td align="left">table</td><td align="left">collection</td><td align="left">数据库表&#x2F;集合</td></tr><tr><td align="left">row</td><td align="left">document</td><td align="left">数据记录行&#x2F;文档</td></tr><tr><td align="left">column</td><td align="left">field</td><td align="left">数据字段&#x2F;域</td></tr><tr><td align="left">index</td><td align="left">index</td><td align="left">索引</td></tr><tr><td align="left">table joins</td><td align="left"></td><td align="left">表连接,MongoDB不支持</td></tr><tr><td align="left">primary key</td><td align="left">primary key</td><td align="left">主键,MongoDB自动将_id字段设置为主键</td></tr></tbody></table><h2 id="1-4-数据模型"><a href="#1-4-数据模型" class="headerlink" title="1.4 数据模型"></a>1.4 数据模型</h2><p>MongoDB的最小存储单位就是文档(document)对象。文档(document)对象对应于关系型数据库的行。数据在MongoDB中以BSON（Binary-JSON）文档的格式存储在磁盘上。</p><p>BSON（Binary Serialized Document Format）是一种类json的一种二进制形式的存储格式，简称Binary JSON。BSON和JSON一样，支持内嵌的文档对象和数组对象，但是BSON有JSON没有的一些数据类型，如Date和BinData类型。</p><p>BSON采用了类似于 C 语言结构体的名称、对表示方法，支持内嵌的文档对象和数组对象，具有轻量性、可遍历性、高效性的三个特点，可以有效描述非结构化数据和结构化数据。这种格式的优点是灵活性高，但它的缺点是空间利用率不是很理想。</p><p>Bson中，除了基本的JSON类型：string,integer,boolean,double,null,array和object，mongo还使用了特殊的数据类型。这些类型包括date,object id,binary data,regular expression 和code。每一个驱动都以特定语言的方式实现了这些类型，查看你的驱动的文档来获取详细信息。</p><h2 id="1-5-优缺点"><a href="#1-5-优缺点" class="headerlink" title="1.5 优缺点"></a>1.5 优缺点</h2><p>MongoDB 是一种 NoSQL 数据库，以其灵活的文档模型和高性能而闻名。以下是 MongoDB 的主要优缺点：</p><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ol><li><strong>灵活的文档模型</strong><ul><li>MongoDB 使用 BSON（类似 JSON 的二进制格式）存储数据，这允许存储复杂的嵌套数据结构。</li><li>模型灵活，模式自由，可以轻松处理数据模型的变化。</li></ul></li><li><strong>高性能</strong><ul><li>MongoDB 对于读取和写入操作都有很好的性能表现，尤其适用于高吞吐量和低延迟的应用场景。</li></ul></li><li><strong>水平扩展</strong><ul><li>MongoDB 支持水平扩展（sharding），能够通过将数据分布在多个服务器上来扩展存储容量和计算能力，适应大规模数据存储和访问需求。</li></ul></li><li><strong>高可用性</strong><ul><li>通过复制集（replica sets）实现数据的高可用性和自动故障转移，确保数据的可靠性和服务的连续性。</li></ul></li><li><strong>丰富的查询语言</strong><ul><li>MongoDB 提供了强大的查询语言，可以进行复杂的查询、排序、投影和聚合操作，满足各种数据查询需求。</li></ul></li><li><strong>强大的社区和生态系统</strong><ul><li>MongoDB 有广泛的社区支持和丰富的第三方工具和库，提供了良好的文档、教程和支持。</li></ul></li><li><strong>地理空间查询</strong><ul><li>内置支持地理空间查询，适用于位置数据的存储和查询。</li></ul></li></ol><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ol><li><strong>内存消耗高</strong><ul><li>由于 MongoDB 的文档存储格式和索引机制，其内存消耗相对较高，对于内存有限的环境可能会有压力。</li></ul></li><li><strong>事务支持有限</strong><ul><li>虽然 MongoDB 从 4.0 版本开始支持多文档 ACID 事务，但在某些复杂的事务场景下，仍然不如传统的关系型数据库。</li></ul></li><li><strong>不支持传统的 SQL</strong><ul><li>MongoDB 的查询语言不同于传统的 SQL，对于习惯于 SQL 的开发者需要学习新的查询语法和操作方法。</li></ul></li><li><strong>数据一致性</strong><ul><li>在默认配置下，MongoDB 的写操作是异步的，这意味着在某些情况下可能会导致数据一致性问题。虽然可以通过配置来保证更高的一致性，但可能会影响性能。</li></ul></li><li><strong>索引大小</strong><ul><li>MongoDB 的索引在内存中占用的空间较大，需要合理设计索引以避免性能问题。</li></ul></li><li><strong>备份和恢复复杂</strong><ul><li>尽管 MongoDB 提供了备份和恢复的工具，但在大规模数据场景下，备份和恢复操作可能会比较复杂和耗时。</li></ul></li></ol><h1 id="2-MongoDB操作"><a href="#2-MongoDB操作" class="headerlink" title="2. MongoDB操作"></a>2. MongoDB操作</h1><h2 id="2-1-数据库操作"><a href="#2-1-数据库操作" class="headerlink" title="2.1 数据库操作"></a>2.1 数据库操作</h2><h3 id="选择和创建数据库"><a href="#选择和创建数据库" class="headerlink" title="选择和创建数据库"></a>选择和创建数据库</h3><p>选择和创建数据库的语法格式：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">use 数据库名称<br></code></pre></td></tr></table></figure><p>如果数据库不存在则自动创建，例如，以下语句创建testdb数据库：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">use testdb<br></code></pre></td></tr></table></figure><p>查看有权限查看的所有数据库命令</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">show</span> dbs<br>或<br><span class="hljs-keyword">show</span> databases<br></code></pre></td></tr></table></figure><blockquote><p>注意：在MongoDB中，集合只有在内容插入后才会创建，就是说，创建集合（数据表）后要在插入一个文档（记录），集合才会真正创建</p></blockquote><h3 id="查看当前正在使用的数据库命令"><a href="#查看当前正在使用的数据库命令" class="headerlink" title="查看当前正在使用的数据库命令"></a>查看当前正在使用的数据库命令</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">db<br></code></pre></td></tr></table></figure><p>MongoDB中默认的数据库为test，如果你没有选择数据库，集合将存放在test数据库中。</p><p>另外：</p><ul><li><p>数据库名可以是满足以下条件的任意UTF-8字符串。</p></li><li><p>不能是空字符串（””)。</p></li><li><p>不得含有’ ‘（空格)、.、$、&#x2F;、\和\0 (空字符)。</p></li><li><p>应全部小写。</p></li><li><p>最多64字节。</p></li></ul><p>有一些数据库名是保留的，可以直接访问这些有特殊作用的数据库。</p><ul><li><p><strong>admin</strong>： 从权限的角度来看，这是”root”数据库。要是将一个用户添加到这个数据库，这个用户自动继承所有数据库的权限。一些特定的服务器端命令也只能从这个数据库运行，比如列出所有的数据库或者关闭服务器。</p></li><li><p><strong>local:</strong> 这个数据永远不会被复制，可以用来存储限于本地单台服务器的任意集合</p></li><li><p><strong>config</strong>: 当Mongo用于分片设置时，config数据库在内部使用，用于保存分片的相关信息。</p></li></ul><h3 id="数据库的删除"><a href="#数据库的删除" class="headerlink" title="数据库的删除"></a>数据库的删除</h3><p>MongoDB删除数据的语法格式如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">db.dropDatabase()<br></code></pre></td></tr></table></figure><p>提示：主要用来删除已经持久化的数据库</p><h2 id="2-2-集合操作"><a href="#2-2-集合操作" class="headerlink" title="2.2 集合操作"></a>2.2 集合操作</h2><h3 id="集合的显示创建"><a href="#集合的显示创建" class="headerlink" title="集合的显示创建"></a>集合的显示创建</h3><p>基本语法格式：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">db.createCollection(name)<br></code></pre></td></tr></table></figure><p>参数说明：</p><ul><li>name：要创建的集合名称</li></ul><p>例如：创建一个名为mycollection的普通集合</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">db.createCollection(&quot;mycollection&quot;)<br></code></pre></td></tr></table></figure><p>查看当前库中的表：show tables命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">show collections<br>或<br>show tables<br></code></pre></td></tr></table></figure><p>集合的命名规范：</p><ul><li><p>集合名不能是空字符串””。</p></li><li><p>集合名不能含有\0字符（空字符)，这个字符表示集合名的结尾。</p></li><li><p>集合名不能以”system.”开头，这是为系统集合保留的前缀。</p></li><li><p>用户创建的集合名字不能含有保留字符。有些驱动程序的确支持在集合名里面包含，这是因为某些系统生成的集合中包含该字符。除非你要访问这种系统创建的集合，否则千万不要在名字里出现$。</p></li></ul><h3 id="集合的隐式创建"><a href="#集合的隐式创建" class="headerlink" title="集合的隐式创建"></a>集合的隐式创建</h3><p>当向一个集合中插入一个文档的时候，如果集合不存在，则会自动创建集合。</p><blockquote><p>提示：通常我们使用隐式创建集合即可</p></blockquote><h2 id="2-3-集合的删除"><a href="#2-3-集合的删除" class="headerlink" title="2.3 集合的删除"></a>2.3 集合的删除</h2><p>集合删除语法格式如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">db.collection.drop()<br>或<br>db.集合.drop()<br></code></pre></td></tr></table></figure><p><strong>返回值</strong></p><p>如果成功删除选定集合，则drop()方法返回true，否则返回flase。</p><p>例如：要删除mycollection集合</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">db.mycollection.drop()<br></code></pre></td></tr></table></figure><h2 id="2-4-文档基本CRUD"><a href="#2-4-文档基本CRUD" class="headerlink" title="2.4 文档基本CRUD"></a>2.4 文档基本CRUD</h2><p>文档（document）的数据结构和 JSON 基本一样。</p><p>所有存储在集合中的数据都是 BSON 格式。</p><h3 id="文档的插入"><a href="#文档的插入" class="headerlink" title="文档的插入"></a>文档的插入</h3><p>（1）单个文档插入</p><p>使用insert()或者save()方法向集合中插入文档，语法如下：</p><figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs xquery">db<span class="hljs-built_in">.collection</span>.<span class="hljs-keyword">insert</span>(<br>&lt;<span class="hljs-keyword">document</span> or array of <span class="hljs-keyword">document</span>&gt;,<br>&#123;<br>writeConcern: <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">document</span>&gt;</span>,</span><br><span class="language-xml">ordered: </span><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">boolean</span>&gt;</span></span><br><span class="language-xml">&#125;</span><br><span class="language-xml">)</span><br></code></pre></td></tr></table></figure><p>参数：</p><table><thead><tr><th>Parameter</th><th>Type</th><th>Description</th></tr></thead><tbody><tr><td>document</td><td>document or array</td><td>要插入到集合中的文档或者文档数组。（json格式）</td></tr><tr><td>writeConcern</td><td>document</td><td>Optional. A document expressing the <a href="https://docs.mongodb.com/manual/reference/write-concern/">write concern</a>. Omit to use the default <a href="https://docs.mongodb.com/manual/reference/write-concern/">write concern</a>.See Write Concern.Do not explicitly set the write concern for the operation if run in a transaction. To use write concern with transactions, see <a href="https://docs.mongodb.com/manual/core/transactions/#transactions-write-concern">Transactions and Write Concern</a>.</td></tr><tr><td>ordered</td><td>boolean</td><td>可选。如果为真，则按顺序插入数组中的文档，如果其中一个文档出现错误，MongoDB将返回而不处理数组中的其余文档。如果为假，则执行无序插入，如果其中一个文档出现错误，则继续处理数组中的主文档。在版本2.6+中默认为true</td></tr></tbody></table><p>【示例】</p><p>要向comment的集合（表）中插入一条数据：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs shell">db.comment.insert(<br>&#123;<br>&quot;articleid&quot;:&quot;100000&quot;,<br>&quot;content&quot;:&quot;今天天气真好，阳光明媚&quot;,<br>&quot;userid&quot;:&quot;1001&quot;,<br>&quot;nickname&quot;:&quot;Rose&quot;,<br>&quot;createdatetime&quot;:new Date(),<br>&quot;likenum&quot;:NumberInt(10),<br>&quot;state&quot;:null<br>&#125;<br>)<br></code></pre></td></tr></table></figure><p>提示：</p><p>1）comment集合如果不存在，则会隐式创建</p><p>2）mongo中的数字，默认情况下是double类型，如果要存整型，必须使用函数NumberInt(整型数字)，否则取出来就有问题了。</p><p>3）插入当前日期使用 new Date()</p><p>4）插入的数据没有指定 _id ，会自动生成主键值</p><p>5）如果某字段没值，可以赋值为null，或不写该字段。</p><p>执行后，如下，说明插入一个数据成功了</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">writeResult</span><span class="hljs-params">(&#123;<span class="hljs-string">&quot;nInserted&quot;</span>: <span class="hljs-number">1</span>&#125;)</span></span><br></code></pre></td></tr></table></figure><p>注意：</p><ol><li>文档中的键&#x2F;值对是有序的。</li><li>文档中的值不仅可以是在双引号里面的字符串，还可以是其他几种数据类型（甚至可以是整个嵌入的文档)。</li><li>MongoDB区分类型和大小写。</li><li>MongoDB的文档不能有重复的键。</li><li>文档的键是字符串。除了少数例外情况，键可以使用任意UTF-8字符。</li></ol><p>文档键命名规范：</p><ul><li><p>键不能含有\0 (空字符)。这个字符用来表示键的结尾。</p></li><li><p>.和$有特别的意义，只有在特定环境下才能使用。</p></li><li><p>以下划线”_”开头的键是保留的(不是严格要求的)。</p></li></ul><p>（2）批量插入</p><p>语法：</p><figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs pf">db.collection.insertM<span class="hljs-literal">any</span>(<br>[ <span class="hljs-variable">&lt;document 1&gt;</span> , <span class="hljs-variable">&lt;document 2&gt;</span>, ... ],<br>&#123;<br>writeConcern: <span class="hljs-variable">&lt;document&gt;</span>,<br>ordered: <span class="hljs-variable">&lt;boolean&gt;</span><br>&#125;<br>)<br></code></pre></td></tr></table></figure><p>【示例】</p><p>批量插入多条文章评论：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs shell">db.comment.insertMany([<br>&#123;&quot;_id&quot;:&quot;1&quot;,&quot;articleid&quot;:&quot;100001&quot;,&quot;content&quot;:&quot;我们不应该把清晨浪费在手机上，健康很重要，一杯温水幸福你我他。&quot;,&quot;userid&quot;:&quot;1002&quot;,&quot;nickname&quot;:&quot;相忘于江湖&quot;,&quot;createdatetime&quot;:new Date(&quot;2019-08-05T22:08:15.522Z&quot;),&quot;likenum&quot;:NumberInt(1000),&quot;state&quot;:&quot;1&quot;&#125;,<br>&#123;&quot;_id&quot;:&quot;2&quot;,&quot;articleid&quot;:&quot;100001&quot;,&quot;content&quot;:&quot;我夏天空腹喝凉开水，冬天喝温开水&quot;,&quot;userid&quot;:&quot;1005&quot;,&quot;nickname&quot;:&quot;伊人憔悴&quot;,&quot;createdatetime&quot;:new Date(&quot;2019-08-05T23:58:51.485Z&quot;),&quot;likenum&quot;:NumberInt(888),&quot;state&quot;:&quot;1&quot;&#125;,<br>&#123;&quot;_id&quot;:&quot;3&quot;,&quot;articleid&quot;:&quot;100001&quot;,&quot;content&quot;:&quot;我一直喝凉开水，冬天夏天都喝。&quot;,&quot;userid&quot;:&quot;1004&quot;,&quot;nickname&quot;:&quot;杰克船长&quot;,&quot;createdatetime&quot;:new Date(&quot;2019-08-06T01:05:06.321Z&quot;),&quot;likenum&quot;:NumberInt(666),&quot;state&quot;:&quot;1&quot;&#125;,<br>&#123;&quot;_id&quot;:&quot;4&quot;,&quot;articleid&quot;:&quot;100001&quot;,&quot;content&quot;:&quot;专家说不能空腹吃饭，影响健康。&quot;,&quot;userid&quot;:&quot;1003&quot;,&quot;nickname&quot;:&quot;凯撒&quot;,&quot;createdatetime&quot;:new Date(&quot;2019-08-06T08:18:35.288Z&quot;),&quot;likenum&quot;:NumberInt(2000),&quot;state&quot;:&quot;1&quot;&#125;,<br>&#123;&quot;_id&quot;:&quot;5&quot;,&quot;articleid&quot;:&quot;100001&quot;,&quot;content&quot;:&quot;研究表明，刚烧开的水千万不能喝，因为烫<br>嘴。&quot;,&quot;userid&quot;:&quot;1003&quot;,&quot;nickname&quot;:&quot;凯撒&quot;,&quot;createdatetime&quot;:new Date(&quot;2019-08-<br>06T11:01:02.521Z&quot;),&quot;likenum&quot;:NumberInt(3000),&quot;state&quot;:&quot;1&quot;&#125;<br>]);<br></code></pre></td></tr></table></figure><p>提示：</p><p>插入时指定了 _id ，则主键就是该值。</p><p>如果某条数据插入失败，将会终止插入，但已经插入成功的数据不会回滚掉。</p><p>因为批量插入由于数据较多容易出现失败，因此，可以使用try catch进行异常捕捉处理，测试的时候可以不处理。如：</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript"><span class="hljs-keyword">try</span> &#123;<br>db.comment.insertMany([<br>&#123;<span class="hljs-string">&quot;_id&quot;</span>:<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;articleid&quot;</span>:<span class="hljs-string">&quot;100001&quot;</span>,<span class="hljs-string">&quot;content&quot;</span>:<span class="hljs-string">&quot;我们不应该把清晨浪费在手机上，健康很重要，一杯温水幸福你我他。&quot;</span>,<span class="hljs-string">&quot;userid&quot;</span>:<span class="hljs-string">&quot;1002&quot;</span>,<span class="hljs-string">&quot;nickname&quot;</span>:<span class="hljs-string">&quot;相忘于江湖&quot;</span>,<span class="hljs-string">&quot;createdatetime&quot;</span>:<span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>(<span class="hljs-string">&quot;2019-08-05T22:08:15.522Z&quot;</span>),<span class="hljs-string">&quot;likenum&quot;</span>:NumberInt(<span class="hljs-number">1000</span>),<span class="hljs-string">&quot;state&quot;</span>:<span class="hljs-string">&quot;1&quot;</span>&#125;,<br>&#123;<span class="hljs-string">&quot;_id&quot;</span>:<span class="hljs-string">&quot;2&quot;</span>,<span class="hljs-string">&quot;articleid&quot;</span>:<span class="hljs-string">&quot;100001&quot;</span>,<span class="hljs-string">&quot;content&quot;</span>:<span class="hljs-string">&quot;我夏天空腹喝凉开水，冬天喝温开水&quot;</span>,<span class="hljs-string">&quot;userid&quot;</span>:<span class="hljs-string">&quot;1005&quot;</span>,<span class="hljs-string">&quot;nickname&quot;</span>:<span class="hljs-string">&quot;伊人憔悴&quot;</span>,<span class="hljs-string">&quot;createdatetime&quot;</span>:<span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>(<span class="hljs-string">&quot;2019-08-05T23:58:51.485Z&quot;</span>),<span class="hljs-string">&quot;likenum&quot;</span>:NumberInt(<span class="hljs-number">888</span>),<span class="hljs-string">&quot;state&quot;</span>:<span class="hljs-string">&quot;1&quot;</span>&#125;,<br>&#123;<span class="hljs-string">&quot;_id&quot;</span>:<span class="hljs-string">&quot;3&quot;</span>,<span class="hljs-string">&quot;articleid&quot;</span>:<span class="hljs-string">&quot;100001&quot;</span>,<span class="hljs-string">&quot;content&quot;</span>:<span class="hljs-string">&quot;我一直喝凉开水，冬天夏天都喝。&quot;</span>,<span class="hljs-string">&quot;userid&quot;</span>:<span class="hljs-string">&quot;1004&quot;</span>,<span class="hljs-string">&quot;nickname&quot;</span>:<span class="hljs-string">&quot;杰克船长&quot;</span>,<span class="hljs-string">&quot;createdatetime&quot;</span>:<span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>(<span class="hljs-string">&quot;2019-08-06T01:05:06.321Z&quot;</span>),<span class="hljs-string">&quot;likenum&quot;</span>:NumberInt(<span class="hljs-number">666</span>),<span class="hljs-string">&quot;state&quot;</span>:<span class="hljs-string">&quot;1&quot;</span>&#125;,<br>&#123;<span class="hljs-string">&quot;_id&quot;</span>:<span class="hljs-string">&quot;4&quot;</span>,<span class="hljs-string">&quot;articleid&quot;</span>:<span class="hljs-string">&quot;100001&quot;</span>,<span class="hljs-string">&quot;content&quot;</span>:<span class="hljs-string">&quot;专家说不能空腹吃饭，影响健康。&quot;</span>,<span class="hljs-string">&quot;userid&quot;</span>:<span class="hljs-string">&quot;1003&quot;</span>,<span class="hljs-string">&quot;nickname&quot;</span>:<span class="hljs-string">&quot;凯撒&quot;</span>,<span class="hljs-string">&quot;createdatetime&quot;</span>:<span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>(<span class="hljs-string">&quot;2019-08-06T08:18:35.288Z&quot;</span>),<span class="hljs-string">&quot;likenum&quot;</span>:NumberInt(<span class="hljs-number">2000</span>),<span class="hljs-string">&quot;state&quot;</span>:<span class="hljs-string">&quot;1&quot;</span>&#125;,<br>&#123;<span class="hljs-string">&quot;_id&quot;</span>:<span class="hljs-string">&quot;5&quot;</span>,<span class="hljs-string">&quot;articleid&quot;</span>:<span class="hljs-string">&quot;100001&quot;</span>,<span class="hljs-string">&quot;content&quot;</span>:<span class="hljs-string">&quot;研究表明，刚烧开的水千万不能喝，因为烫</span><br><span class="hljs-string">嘴。&quot;</span>,<span class="hljs-string">&quot;userid&quot;</span>:<span class="hljs-string">&quot;1003&quot;</span>,<span class="hljs-string">&quot;nickname&quot;</span>:<span class="hljs-string">&quot;凯撒&quot;</span>,<span class="hljs-string">&quot;createdatetime&quot;</span>:<span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>(<span class="hljs-string">&quot;2019-08-</span><br><span class="hljs-string">06T11:01:02.521Z&quot;</span>),<span class="hljs-string">&quot;likenum&quot;</span>:NumberInt(<span class="hljs-number">3000</span>),<span class="hljs-string">&quot;state&quot;</span>:<span class="hljs-string">&quot;1&quot;</span>&#125;<br>]);<br>&#125; <span class="hljs-keyword">catch</span> (e) &#123;<br><span class="hljs-built_in">print</span> (e);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="文档的基本查询"><a href="#文档的基本查询" class="headerlink" title="文档的基本查询"></a>文档的基本查询</h3><p>查询数据的语法格式如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">db.collection.find(&lt;query&gt;, [projection])<br></code></pre></td></tr></table></figure><p>参数：</p><table><thead><tr><th>Parameter</th><th>Type</th><th>Description</th></tr></thead><tbody><tr><td>query</td><td>document</td><td>可选。使用查询运算符指定选择筛选器。若要返回集合中的所有文档，请省略此参数或传递空文档({})</td></tr><tr><td>projection</td><td>document</td><td>可选。指定要在与查询筛选器匹配的文档中返回的字段（投影）。若要返回匹配文档中的所有字段，请忽略此参数。</td></tr></tbody></table><p>【示例】</p><p>（1）查询所有</p><p>如果我们要查询comment集合的所有文档，我们输入以下命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">db.comment.find()<br>或<br>db.comment.find(&#123;&#125;)<br></code></pre></td></tr></table></figure><p>这里你会发现每条文档会有一个叫_id的字段，这个相当于我们原来关系数据库中表的主键，当你在插入文档记录时没有指定该字段，MongoDB会自动创建，其类型是ObjectID类型。</p><p>如果我们在插入文档记录时指定该字段也可以，其类型可以是ObjectID类型，也可以是MongoDB支持的任意类型。</p><p>如果我想按一定条件来查询，比如我想查询userid为1003的记录，怎么办？很简单！只 要在find()中添加参数即可，参数也是json格式，如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">db.comment.fin(&#123;userid:&#x27;1003&#x27;&#125;)<br></code></pre></td></tr></table></figure><p>如果你只需要返回符合条件的第一条数据，我们可以使用findOne命令来实现，语法和find一样。</p><p>如：查询用户编号是1003的记录，但只最多返回符合条件的第一条记录：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">db.comment.findOne(&#123;userid:&#x27;1003&#x27;&#125;)<br></code></pre></td></tr></table></figure><p>（2）投影查询（Projection Query）：</p><p>如果要查询结果返回部分字段，则需要使用投影查询（不显示所有字段，只显示指定的字段）。</p><p>如：查询结果只显示 _id、userid、nickname :</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">db.comment.find(&#123;userid:&quot;1003&quot;&#125;,&#123;userid:1,nickname:1&#125;)<br>&#123; &quot;_id&quot; : &quot;4&quot;, &quot;userid&quot; : &quot;1003&quot;, &quot;nickname&quot; : &quot;凯撒&quot; &#125;<br>&#123; &quot;_id&quot; : &quot;5&quot;, &quot;userid&quot; : &quot;1003&quot;, &quot;nickname&quot; : &quot;凯撒&quot; &#125;<br></code></pre></td></tr></table></figure><p>默认 _id 会显示。</p><p>如：查询结果只显示 、userid、nickname ，不显示 _id ：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">db.comment.find(&#123;userid:&quot;1003&quot;&#125;,&#123;userid:1,nickname:1,_id:0&#125;)<br>&#123; &quot;userid&quot; : &quot;1003&quot;, &quot;nickname&quot; : &quot;凯撒&quot; &#125;<br>&#123; &quot;userid&quot; : &quot;1003&quot;, &quot;nickname&quot; : &quot;凯撒&quot; &#125;<br></code></pre></td></tr></table></figure><p>再例如：查询所有数据，但只显示 _id、userid、nickname :</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">db.comment.find(&#123;&#125;,&#123;userid:1,nickname:1&#125;)<br></code></pre></td></tr></table></figure><h3 id="文档的更新"><a href="#文档的更新" class="headerlink" title="文档的更新"></a>文档的更新</h3><p>更新文档的语法：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs shell">db.collection.update(query, update, options)<br>//或<br>db.collection.update(<br>&lt;query&gt;,<br>&lt;update&gt;,<br>&#123;<br>upsert: &lt;boolean&gt;,<br>multi: &lt;boolean&gt;,<br>writeConcern: &lt;document&gt;<br>&#125;<br>)<br></code></pre></td></tr></table></figure><p>参数：</p><table><thead><tr><th>Parameter</th><th>Type</th><th>Description</th></tr></thead><tbody><tr><td>query</td><td>document</td><td>update的查询条件，类似sql update查询的where子句。</td></tr><tr><td>update</td><td>document or pipeline</td><td>update的对象和一些更新的操作符（如$,$inc…）等，也可以理解为 sql update查询的set子句</td></tr><tr><td>upsert</td><td>boolean</td><td>可选。如果设置为true，则在没有与查询条件匹配的文档时创建新文档。默认值为false，如果找不到匹配项，则不会插入新文档。</td></tr><tr><td>multi</td><td>boolean</td><td>可选。如果设置为true，则更新符合查询条件的多个文档。如果设置为false，则更新一个文档。默认值为false。</td></tr><tr><td>writeConcern</td><td>document</td><td>可选。表示写问题的文档。抛出异常的级别。</td></tr></tbody></table><p>提示：</p><p>主要关注前四个参数即可。</p><p>【示例】</p><p>（1）覆盖的修改</p><p>如果我们想修改_id为1的记录，点赞量为1001，输入以下语句：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">db.comment.update(&#123;_id:&quot;1&quot;&#125;,&#123;likenum:NumberInt(1001)&#125;)<br></code></pre></td></tr></table></figure><p>执行后，我们会发现，这条文档除了likenum字段其它字段都不见了，</p><p>（2）局部修改</p><p>为了解决这个问题，我们需要使用修改器$set来实现，命令如下：</p><p>我们想修改_id为2的记录，浏览量为889，输入以下语句：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">db.comment.update(&#123;_id:&quot;2&quot;&#125;,&#123;$set:&#123;likenum:NumberInt(889)&#125;&#125;)<br></code></pre></td></tr></table></figure><p>这样就OK啦。</p><p>（3）批量的修改</p><p>更新所有用户为 1003 的用户的昵称为 凯撒大帝 。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">//默认只修改第一条数据<br>db.comment.update(&#123;userid:&quot;1003&quot;&#125;,&#123;$set:&#123;nickname:&quot;凯撒2&quot;&#125;&#125;)<br>//修改所有符合条件的数据<br>db.comment.update(&#123;userid:&quot;1003&quot;&#125;,&#123;$set:&#123;nickname:&quot;凯撒大帝&quot;&#125;&#125;,&#123;multi:true&#125;)<br></code></pre></td></tr></table></figure><p>提示：如果不加后面的参数，则只更新符合条件的第一条记录</p><p>（3）列值增长的修改</p><p>如果我们想实现对某列值在原有值的基础上进行增加或减少，可以使用 $inc 运算符来实现。</p><p>需求：对3号数据的点赞数，每次递增</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus">db<span class="hljs-selector-class">.comment</span><span class="hljs-selector-class">.update</span>(&#123;_id:<span class="hljs-string">&quot;3&quot;</span>&#125;,&#123;<span class="hljs-variable">$inc</span>:&#123;likenum:<span class="hljs-built_in">NumberInt</span>(<span class="hljs-number">1</span>)&#125;&#125;)<br></code></pre></td></tr></table></figure><h3 id="删除文档"><a href="#删除文档" class="headerlink" title="删除文档"></a>删除文档</h3><p>删除文档的语法结构：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">db.集合名称.remove(条件)<br></code></pre></td></tr></table></figure><p>以下语句可以将数据全部删除，请慎用</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">db.comment.remove(&#123;&#125;)<br></code></pre></td></tr></table></figure><p>如果删除_id&#x3D;1的记录，输入以下语句</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">db.comment.remove(&#123;_id:&quot;1&quot;&#125;)<br></code></pre></td></tr></table></figure><h2 id="2-5-文档的分页查询"><a href="#2-5-文档的分页查询" class="headerlink" title="2.5 文档的分页查询"></a>2.5 文档的分页查询</h2><h3 id="统计查询"><a href="#统计查询" class="headerlink" title="统计查询"></a>统计查询</h3><p>统计查询使用count()方法，语法如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">db.collection.count(query, options)<br></code></pre></td></tr></table></figure><p>参数：</p><table><thead><tr><th>Parameter</th><th>Type</th><th>Description</th></tr></thead><tbody><tr><td>query</td><td>document</td><td>查询选择条件</td></tr><tr><td>options</td><td>document</td><td>可选。用于修改计数的额外选项</td></tr></tbody></table><p>提示：</p><p>可选项暂时不使用。</p><p>【示例】</p><p>（1）统计所有记录数：</p><p>统计comment集合的所有记录数：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">db.comment.count()<br></code></pre></td></tr></table></figure><p>（2）按条件统计记录数</p><p>例如：统计userid为1003的记录条数</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">db.comment.count(&#123;userid:&quot;1003&quot;&#125;)<br></code></pre></td></tr></table></figure><p>提示：默认情况下 count()方法返回符合条件的全部记录条数。</p><h3 id="分页列表查询"><a href="#分页列表查询" class="headerlink" title="分页列表查询"></a>分页列表查询</h3><p>可以使用limit()方法来读取指定数量的数据，使用skip()方法来跳过指定数量的数据。</p><p>基本语法如下所示：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">db.COLLECTION_NAME.find().limit(NUMBER).skip(NUMBER)<br></code></pre></td></tr></table></figure><p>如果想返回指定条数的记录，可以在find方法后调用limit来返回结果（TopN），默认值20，例如：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">db.comment.find().limit(3)<br></code></pre></td></tr></table></figure><p>skip方法同样接收一个数字参数作为跳过的记录条数。（前N个不要）， 默认值是0</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">db.comment.find().skip(3)<br></code></pre></td></tr></table></figure><p>分页查询：需求： 每页2个，从第二页开始：跳过前两条数据，接着值显示3和4条数据</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell">//第一页<br>db.comment.find().skip(0).limit(2)<br>//第二页<br>db.comment.find().skip(2).limit(2)<br>//第三页<br>db.comment.find().skip(4).limit(2)<br></code></pre></td></tr></table></figure><h3 id="排序查询"><a href="#排序查询" class="headerlink" title="排序查询"></a>排序查询</h3><p>sort() 方法对数据进行排序，sort() 方法可以通过参数指定排序的字段，并使用1和-1来指定排序的方式，其中 1 为升序排列，而-1是用于降序排列。</p><p>语法如下所示：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">db.COLLECTION_NAME.find().sort(&#123;KEY:1&#125;)<br>或<br>db.集合名称.find().sort(排序方式)<br></code></pre></td></tr></table></figure><p>例如：</p><p>对userid降序排列，并对访问量进行升序排列</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">db.comment.find().sort(&#123;userid:-1,likenum:1&#125;)<br></code></pre></td></tr></table></figure><p>提示：</p><p>skip(), limilt(), sort()三个放在一起执行的时候，执行的顺序是先 sort(), 然后是 skip()，最后是显示的 limit()，和命令编写顺序无关。</p><h2 id="2-6-文档的更多查询"><a href="#2-6-文档的更多查询" class="headerlink" title="2.6 文档的更多查询"></a>2.6 文档的更多查询</h2><h3 id="正则的复杂条件查询"><a href="#正则的复杂条件查询" class="headerlink" title="正则的复杂条件查询"></a>正则的复杂条件查询</h3><p>MongoDB的模糊查询是通过<strong>正则表达式</strong>的方式实现的。格式为：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">db.collection.find(&#123;field:/正则表达式/&#125;)<br>或<br>db.集合.find(&#123;字段:/正则表达式/&#125;)<br></code></pre></td></tr></table></figure><p>提示：正则表达式是js的语法，直接量的写法。</p><p>例如，我要查询评论内容包含“开水”的所有文档，代码如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">db.comment.find(&#123;content:/开水/&#125;)<br></code></pre></td></tr></table></figure><p>如果要查询评论的内容中以“专家”开头的，代码如下：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus">db<span class="hljs-selector-class">.comment</span><span class="hljs-selector-class">.find</span>(&#123;<span class="hljs-attribute">content</span>:/^专家/&#125;)<br></code></pre></td></tr></table></figure><h3 id="比较查询"><a href="#比较查询" class="headerlink" title="比较查询"></a>比较查询</h3><p>&lt;, &lt;&#x3D;, &gt;, &gt;&#x3D; 这个操作符也是很常用的，格式如下:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">db.集合名称.find(&#123; &quot;field&quot; : &#123; $gt: value &#125;&#125;) // 大于: field &gt; value<br>db.集合名称.find(&#123; &quot;field&quot; : &#123; $lt: value &#125;&#125;) // 小于: field &lt; value<br>db.集合名称.find(&#123; &quot;field&quot; : &#123; $gte: value &#125;&#125;) // 大于等于: field &gt;= value<br>db.集合名称.find(&#123; &quot;field&quot; : &#123; $lte: value &#125;&#125;) // 小于等于: field &lt;= value<br>db.集合名称.find(&#123; &quot;field&quot; : &#123; $ne: value &#125;&#125;) // 不等于: field != value<br></code></pre></td></tr></table></figure><p>示例：查询评论点赞数量大于700的记录</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">db.comment.find(&#123;likenum:&#123;$gt:NumberInt(700)&#125;&#125;)<br></code></pre></td></tr></table></figure><h3 id="包含查询"><a href="#包含查询" class="headerlink" title="包含查询"></a>包含查询</h3><p>包含使用$in操作符。 示例：查询评论的集合中userid字段包含1003或1004的文档</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">db.comment.find(&#123;userid:&#123;$in:[&quot;1003&quot;,&quot;1004&quot;]&#125;&#125;)<br></code></pre></td></tr></table></figure><p>不包含使用$nin操作符。 示例：查询评论集合中userid字段不包含1003和1004的文档</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">db.comment.find(&#123;userid:&#123;$nin:[&quot;1003&quot;,&quot;1004&quot;]&#125;&#125;)<br></code></pre></td></tr></table></figure><h3 id="条件连接查询"><a href="#条件连接查询" class="headerlink" title="条件连接查询"></a>条件连接查询</h3><p>我们如果需要查询同时满足两个以上条件，需要使用$and操作符将条件进行关联。（相 当于SQL的and） 格式为：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$</span><span class="language-bash">and:[ &#123; &#125;,&#123; &#125;,&#123; &#125; ]</span><br></code></pre></td></tr></table></figure><p>示例：查询评论集合中likenum大于等于700 并且小于2000的文档：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">db.comment.find(&#123;$and:[&#123;likenum:&#123;$gte:NumberInt(700)&#125;&#125;,&#123;likenum:&#123;$lt:NumberInt(2000)&#125;&#125;]&#125;)<br></code></pre></td></tr></table></figure><p>如果两个以上条件之间是或者的关系，我们使用 操作符进行关联，与前面 and的使用方式相同 格式为：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$</span><span class="language-bash">or:[ &#123; &#125;,&#123; &#125;,&#123; &#125; ]</span><br></code></pre></td></tr></table></figure><p>示例：查询评论集合中userid为1003，或者点赞数小于1000的文档记录</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">db.comment.find(&#123;$or:[ &#123;userid:&quot;1003&quot;&#125; ,&#123;likenum:&#123;$lt:1000&#125; &#125;]&#125;)<br></code></pre></td></tr></table></figure><h2 id="2-7-常用命令小结"><a href="#2-7-常用命令小结" class="headerlink" title="2.7 常用命令小结"></a>2.7 常用命令小结</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs shell">选择切换数据库：use articledb<br>插入数据：db.comment.insert(&#123;bson数据&#125;)<br>查询所有数据：db.comment.find();<br>条件查询数据：db.comment.find(&#123;条件&#125;)<br>查询符合条件的第一条记录：db.comment.findOne(&#123;条件&#125;)<br>查询符合条件的前几条记录：db.comment.find(&#123;条件&#125;).limit(条数)<br>查询符合条件的跳过的记录：db.comment.find(&#123;条件&#125;).skip(条数)<br>修改数据：db.comment.update(&#123;条件&#125;,&#123;修改后的数据&#125;) 或db.comment.update(&#123;条件&#125;,&#123;$set:&#123;要修改部分的字段:数据&#125;)<br>修改数据并自增某字段值：db.comment.update(&#123;条件&#125;,&#123;$inc:&#123;自增的字段:步进值&#125;&#125;)<br>删除数据：db.comment.remove(&#123;条件&#125;)<br>统计查询：db.comment.count(&#123;条件&#125;)<br>模糊查询：db.comment.find(&#123;字段名:/正则表达式/&#125;)<br>条件比较运算：db.comment.find(&#123;字段名:&#123;$gt:值&#125;&#125;)<br>包含查询：db.comment.find(&#123;字段名:&#123;$in:[值1，值2]&#125;&#125;)或db.comment.find(&#123;字段名:&#123;$nin:[值1，值2]&#125;&#125;)<br>条件连接查询：db.comment.find(&#123;$and:[&#123;条件1&#125;,&#123;条件2&#125;]&#125;)或db.comment.find(&#123;$or:[&#123;条件1&#125;,&#123;条件2&#125;]&#125;)<br></code></pre></td></tr></table></figure><h2 id="2-8-聚合"><a href="#2-8-聚合" class="headerlink" title="2.8 聚合"></a>2.8 聚合</h2><p>MongoDB中聚合(aggregate)主要用于处理数据(诸如统计平均值,求和等)，并返回计算后的数据结果。有点类似sql语句中的 count(*)。</p><h3 id="aggregate-方法"><a href="#aggregate-方法" class="headerlink" title="aggregate() 方法"></a>aggregate() 方法</h3><p>MongoDB中聚合的方法使用 aggregate()。</p><p>语法如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">db.COLLECTION_NAME.aggregate(AGGREGATE_OPERATION)<br></code></pre></td></tr></table></figure><p>【实例】</p><p>集合中的数据如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs shell">&#123;<br>   _id: ObjectId(7df78ad8902c)<br>   title: &#x27;MongoDB Overview&#x27;, <br>   description: &#x27;MongoDB is no sql database&#x27;,<br>   by_user: &#x27;w3cschool.cn&#x27;,<br>   url: &#x27;http://www.w3cschool.cn&#x27;,<br>   tags: [&#x27;mongodb&#x27;, &#x27;database&#x27;, &#x27;NoSQL&#x27;],<br>   likes: 100<br>&#125;,<br>&#123;<br>   _id: ObjectId(7df78ad8902d)<br>   title: &#x27;NoSQL Overview&#x27;, <br>   description: &#x27;No sql database is very fast&#x27;,<br>   by_user: &#x27;w3cschool.cn&#x27;,<br>   url: &#x27;http://www.w3cschool.cn&#x27;,<br>   tags: [&#x27;mongodb&#x27;, &#x27;database&#x27;, &#x27;NoSQL&#x27;],<br>   likes: 10<br>&#125;,<br>&#123;<br>   _id: ObjectId(7df78ad8902e)<br>   title: &#x27;Neo4j Overview&#x27;, <br>   description: &#x27;Neo4j is no sql database&#x27;,<br>   by_user: &#x27;Neo4j&#x27;,<br>   url: &#x27;http://www.neo4j.com&#x27;,<br>   tags: [&#x27;neo4j&#x27;, &#x27;database&#x27;, &#x27;NoSQL&#x27;],<br>   likes: 750<br>&#125;,<br></code></pre></td></tr></table></figure><p>现在我们通过以上集合计算每个作者所写的文章数，使用<code>aggregate()</code>计算结果如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs shell">db.mycol.aggregate([&#123;$group : &#123;_id : &quot;$by_user&quot;, num_tutorial : &#123;$sum : 1&#125;&#125;&#125;])<br>&#123;<br>   &quot;result&quot; : [<br>      &#123;<br>         &quot;_id&quot; : &quot;w3cschool.cn&quot;,<br>         &quot;num_tutorial&quot; : 2<br>      &#125;,<br>      &#123;<br>         &quot;_id&quot; : &quot;Neo4j&quot;,<br>         &quot;num_tutorial&quot; : 1<br>      &#125;<br>   ],<br>   &quot;ok&quot; : 1<br>&#125;<br></code></pre></td></tr></table></figure><p>以上实例类似sql语句：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">select by_user, count(*) from mycol group by by_user<br></code></pre></td></tr></table></figure><p>在上面的例子中，我们通过字段by_user字段对数据进行分组，并计算by_user字段相同值的总和。</p><h3 id="管道"><a href="#管道" class="headerlink" title="管道"></a>管道</h3><p>MongoDB 的管道（Pipeline）是一个用于数据处理和分析的概念，它允许你通过一系列阶段（stages）来处理文档集合中的数据。每个阶段对输入文档执行操作，然后将结果传递到下一个阶段。最终，经过一系列操作后，管道输出处理后的结果。</p><p>管道在 MongoDB 中主要用于聚合框架，通过这种方式可以实现数据的过滤、转换、分组、排序、连接等复杂操作。整个管道的结构类似于 Unix 的管道命令，通过一系列简单的步骤，组合起来完成复杂的数据处理任务。</p><h4 id="管道的主要特点"><a href="#管道的主要特点" class="headerlink" title="管道的主要特点"></a>管道的主要特点</h4><ol><li><strong>逐步处理</strong>：数据经过一系列操作步骤，每个阶段只处理当前的数据并传递给下一个阶段。</li><li><strong>组合灵活</strong>：不同的阶段可以自由组合，以满足各种数据处理需求。</li><li><strong>高效执行</strong>：MongoDB 会对管道进行优化，尽量减少内存和计算资源的使用。</li></ol><h4 id="常用的管道阶段"><a href="#常用的管道阶段" class="headerlink" title="常用的管道阶段"></a>常用的管道阶段</h4><p><strong>$match</strong>：过滤文档。用于筛选文档，仅通过满足指定条件的文档。类似于 SQL 中的 <code>WHERE</code> 子句。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">&#123;<br><span class="hljs-meta prompt_">  $</span><span class="language-bash">match: &#123; status: <span class="hljs-string">&quot;A&quot;</span> &#125;</span><br>&#125;<br></code></pre></td></tr></table></figure><p>这将筛选出所有 <code>status</code> 字段为 “A” 的文档。</p><p><strong>$project</strong>：用于包括或排除文档中的特定字段，还可以创建新的字段。类似于 SQL 中的 <code>SELECT</code> 子句。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">&#123;<br><span class="hljs-meta prompt_">  $</span><span class="language-bash">project: &#123; item: 1, status: 1, total: &#123; <span class="hljs-variable">$multiply</span>: [<span class="hljs-string">&quot;<span class="hljs-variable">$price</span>&quot;</span>, <span class="hljs-string">&quot;<span class="hljs-variable">$quantity</span>&quot;</span>] &#125; &#125;</span><br>&#125;<br></code></pre></td></tr></table></figure><p>这会选择 <code>item</code> 和 <code>status</code> 字段，并创建一个 <code>total</code> 字段，其值是 <code>price</code> 和 <code>quantity</code> 的乘积。</p><p><strong>$group</strong>：用于将文档分组，并对每个组应用聚合操作。类似于 SQL 中的 <code>GROUP BY</code> 子句。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">&#123;<br><span class="hljs-meta prompt_">  $</span><span class="language-bash">group: &#123; _id: <span class="hljs-string">&quot;<span class="hljs-variable">$status</span>&quot;</span>, totalQuantity: &#123; <span class="hljs-variable">$sum</span>: <span class="hljs-string">&quot;<span class="hljs-variable">$quantity</span>&quot;</span> &#125; &#125;</span><br>&#125;<br></code></pre></td></tr></table></figure><p>这会根据 <code>status</code> 字段对文档进行分组，并计算每个组的 <code>quantity</code> 字段总和。</p><p><strong>$sort</strong>：用于对文档进行排序。类似于 SQL 中的 <code>ORDER BY</code> 子句。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">&#123;<br><span class="hljs-meta prompt_">  $</span><span class="language-bash"><span class="hljs-built_in">sort</span>: &#123; totalQuantity: -1 &#125;</span><br>&#125;<br></code></pre></td></tr></table></figure><p>这会按 <code>totalQuantity</code> 字段降序排列文档。</p><p><strong>$limit</strong>：用于限制返回的文档数量。类似于 SQL 中的 <code>LIMIT</code> 子句。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">&#123;<br><span class="hljs-meta prompt_">  $</span><span class="language-bash"><span class="hljs-built_in">limit</span>: 5</span><br>&#125;<br></code></pre></td></tr></table></figure><p>这会限制返回的文档数量为 5。</p><p><strong>$skip</strong>：用于跳过指定数量的文档。通常与 <code>$limit</code> 一起使用，实现分页功能。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">&#123;<br><span class="hljs-meta prompt_">  $</span><span class="language-bash">skip: 10</span><br>&#125;<br></code></pre></td></tr></table></figure><p>这会跳过前 10 个文档。</p><p><strong>$unwind</strong>：用于将数组字段拆分为多个文档，每个数组元素对应一个文档。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">&#123;<br><span class="hljs-meta prompt_">  $</span><span class="language-bash">unwind: <span class="hljs-string">&quot;<span class="hljs-variable">$items</span>&quot;</span></span><br>&#125;<br></code></pre></td></tr></table></figure><p>这会将 <code>items</code> 数组字段中的每个元素拆分为单独的文档。</p><p><strong>$lookup</strong>：联表查询。用于在集合之间进行左外连接，类似于 SQL 中的 <code>JOIN</code> 操作。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs shell">&#123;<br><span class="hljs-meta prompt_">  $</span><span class="language-bash">lookup:</span><br>    &#123;<br>      from: &quot;otherCollection&quot;,<br>      localField: &quot;itemId&quot;,<br>      foreignField: &quot;id&quot;,<br>      as: &quot;itemDetails&quot;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这会将当前集合中的 <code>itemId</code> 字段与 <code>otherCollection</code> 中的 <code>id</code> 字段进行匹配，并将匹配结果存储在 <code>itemDetails</code> 字段中。</p><p><strong>$addFields</strong>：添加新字段。用于向文档添加新的字段。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">&#123;<br><span class="hljs-meta prompt_">  $</span><span class="language-bash">addFields: &#123; totalPrice: &#123; <span class="hljs-variable">$multiply</span>: [<span class="hljs-string">&quot;<span class="hljs-variable">$price</span>&quot;</span>, <span class="hljs-string">&quot;<span class="hljs-variable">$quantity</span>&quot;</span>] &#125; &#125;</span><br>&#125;<br></code></pre></td></tr></table></figure><p>这会添加一个 <code>totalPrice</code> 字段，其值为 <code>price</code> 和 <code>quantity</code> 的乘积。</p><p><strong>$replaceRoot</strong>：替换根文档。用于用指定的文档替换输入文档。通常用于嵌套文档。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">&#123;<br><span class="hljs-meta prompt_">  $</span><span class="language-bash">replaceRoot: &#123; newRoot: <span class="hljs-string">&quot;<span class="hljs-variable">$itemDetails</span>&quot;</span> &#125;</span><br>&#125;<br></code></pre></td></tr></table></figure><p>这会用 <code>itemDetails</code> 字段的内容替换当前文档。</p><p><strong>$count</strong>：计算文档数量。用于计算通过管道的文档数量，并返回结果。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">&#123;<br><span class="hljs-meta prompt_">  $</span><span class="language-bash">count: <span class="hljs-string">&quot;total&quot;</span></span><br>&#125;<br><br></code></pre></td></tr></table></figure><p>这会返回一个包含文档总数的字段 <code>total</code>。</p><p><strong>$facet</strong>：允许在单个聚合管道中同时运行多个子管道。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs shell">&#123;<br><span class="hljs-meta prompt_">  $</span><span class="language-bash">facet: &#123;</span><br>    &quot;categorizedByStatus&quot;: [<br>      &#123; $match: &#123; status: &#123; $exists: true &#125; &#125; &#125;,<br>      &#123; $group: &#123; _id: &quot;$status&quot;, count: &#123; $sum: 1 &#125; &#125; &#125;<br>    ],<br>    &quot;categorizedByPrice&quot;: [<br>      &#123; $match: &#123; price: &#123; $exists: true &#125; &#125; &#125;,<br>      &#123; $group: &#123; _id: &#123; $cond: &#123; if: &#123; $gte: [&quot;$price&quot;, 100] &#125;, then: &quot;expensive&quot;, else: &quot;cheap&quot; &#125; &#125;, count: &#123; $sum: 1 &#125; &#125; &#125;<br>    ]<br>  &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>这会分别计算按 <code>status</code> 和 <code>price</code> 分类的文档数量。</p><p><strong>$out</strong>：将聚合结果输出到一个指定的集合。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">&#123;<br><span class="hljs-meta prompt_">  $</span><span class="language-bash">out: <span class="hljs-string">&quot;outputCollection&quot;</span></span><br>&#125;<br></code></pre></td></tr></table></figure><p>这会将聚合结果保存到 <code>outputCollection</code> 集合中。</p><p><strong>$merge</strong>：合并结果到指定集合。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">&#123;<br><span class="hljs-meta prompt_">  $</span><span class="language-bash">merge: &#123; into: <span class="hljs-string">&quot;outputCollection&quot;</span>, whenMatched: <span class="hljs-string">&quot;merge&quot;</span>, whenNotMatched: <span class="hljs-string">&quot;insert&quot;</span> &#125;</span><br>&#125;<br></code></pre></td></tr></table></figure><p>【示例】</p><p>假设有一个包含销售数据的集合 <code>sales</code>，我们想要查询销售状态为 “A” 的文档，并计算每个商品的总销售量，最后按总销售量降序排列，并只取前 5 个结果。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell">db.sales.aggregate([<br>  &#123; $match: &#123; status: &quot;A&quot; &#125; &#125;,<br>  &#123; $group: &#123; _id: &quot;$item&quot;, totalQuantity: &#123; $sum: &quot;$quantity&quot; &#125; &#125; &#125;,<br>  &#123; $sort: &#123; totalQuantity: -1 &#125; &#125;,<br>  &#123; $limit: 5 &#125;<br>]);<br></code></pre></td></tr></table></figure><h4 id="管道的作用"><a href="#管道的作用" class="headerlink" title="管道的作用"></a>管道的作用</h4><p>管道使得 MongoDB 的聚合框架非常强大和灵活。通过管道，你可以：</p><ul><li><strong>清洗数据</strong>：过滤和转换原始数据，得到更干净的数据集。</li><li><strong>聚合分析</strong>：进行复杂的统计分析，比如求和、平均值、最大值、最小值等。</li><li><strong>数据转换</strong>：对数据进行格式化、计算新字段、展开数组等操作。</li><li><strong>数据集成</strong>：通过联表查询将多个集合的数据合并起来。</li></ul><h1 id="3-MongoDB索引"><a href="#3-MongoDB索引" class="headerlink" title="3. MongoDB索引"></a>3. MongoDB索引</h1><h2 id="3-1-概述"><a href="#3-1-概述" class="headerlink" title="3.1 概述"></a>3.1 概述</h2><p>索引支持在MongoDB中高效地执行查询。如果没有索引，MongoDB必须执行全集合扫描，即扫描集合中的每个文档，以选择与查询语句匹配的文档。这种扫描全集合的查询效率是非常低的，特别在处理大量的数据时，查询可以要花费几十秒甚至几分钟，这对网站的性能是非常致命的。</p><p>如果查询存在适当的索引，MongoDB可以使用该索引限制必须检查的文档数。</p><p>索引是特殊的数据结构，它以易于遍历的形式存储集合数据集的一小部分。索引存储特定字段或一组字段的值，按字段值排序。索引项的排序支持有效的相等匹配和基于范围的查询操作。此外，MongoDB还可以使用索引中的排序返回排序结果。</p><p>官网文档：<a href="https://docs.mongodb.com/manual/indexes/">https://docs.mongodb.com/manual/indexes/</a></p><p>MongoDB索引使用B树数据结构（确切的说是B-Tree，MySQL是B+Tree）</p><h2 id="3-2-索引的类型"><a href="#3-2-索引的类型" class="headerlink" title="3.2 索引的类型"></a>3.2 索引的类型</h2><h3 id="单字段索引"><a href="#单字段索引" class="headerlink" title="单字段索引"></a>单字段索引</h3><p>MongoDB支持在文档的单个字段上创建用户定义的升序&#x2F;降序索引，称为单字段索引（Single Field Index）。</p><p>对于单个字段索引和排序操作，索引键的排序顺序（即升序或降序）并不重要，因为MongoDB可以在任何方向上遍历索引。</p><h3 id="复合索引"><a href="#复合索引" class="headerlink" title="复合索引"></a>复合索引</h3><p>MongoDB还支持多个字段的用户定义索引，即复合索引（Compound Index）。</p><p>复合索引中列出的字段顺序具有重要意义。例如，如果复合索引由 { userid: 1, score: -1 } 组成，则索引首先按userid正序排序，然后在每个userid的值内，再在按score倒序排序。</p><h3 id="其他索引"><a href="#其他索引" class="headerlink" title="其他索引"></a>其他索引</h3><p>地理空间索引（Geospatial Index）、文本索引（Text Indexes）、哈希索引（Hashed Indexes）。</p><p>地理空间索引（Geospatial Index）</p><p>为了支持对地理空间坐标数据的有效查询，MongoDB提供了两种特殊的索引：返回结果时使用平面几何的二维索引和返回结果时使用球面几何的二维球面索引。</p><p>文本索引（Text Indexes）</p><p>MongoDB提供了一种文本索引类型，支持在集合中搜索字符串内容。这些文本索引不存储特定于语言的停止词（例如“the”、“a”、“or”），而将集合中的词作为词干，只存储根词。</p><p>哈希索引（Hashed Indexes）</p><p>为了支持基于散列的分片，MongoDB提供了散列索引类型，它对字段值的散列进行索引。这些索引在其范围内的值分布更加随机，但只支持相等匹配，不支持基于范围的查询。</p><h2 id="3-3-索引的管理操作"><a href="#3-3-索引的管理操作" class="headerlink" title="3.3 索引的管理操作"></a>3.3 索引的管理操作</h2><h3 id="索引的查看"><a href="#索引的查看" class="headerlink" title="索引的查看"></a>索引的查看</h3><p>说明：</p><p>返回一个集合中的所有索引的数组。</p><p>语法：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">db.collection.getIndexes()<br></code></pre></td></tr></table></figure><p>【示例】</p><p>查看comment集合中所有的索引情况</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs shell">db.comment.getIndexes()<br>[<br>&#123;<br>&quot;v&quot; : 2,<br>&quot;key&quot; : &#123;<br>&quot;_id&quot; : 1<br>&#125;,<br>&quot;name&quot; : &quot;_id_&quot;,<br>&quot;ns&quot; : &quot;articledb.comment&quot;<br>&#125;<br>]<br></code></pre></td></tr></table></figure><p>结果中显示的是默认 _id 索引。</p><p>默认_id索引：</p><p>MongoDB在创建集合的过程中，在 _id 字段上创建一个唯一的索引，默认名字为 <em>id</em> ，该索引可防止客户端插入两个具有相同值的文档，您不能在_id字段上删除此索引。</p><p>注意：该索引是唯一索引，因此值不能重复，即 _id 值不能重复的。在分片集群中，通常使用 _id 作为片键。</p><h3 id="索引的创建"><a href="#索引的创建" class="headerlink" title="索引的创建"></a>索引的创建</h3><p>说明：</p><p>在集合上创建索引。</p><p>语法：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">db.collection.createIndex(keys, options)<br></code></pre></td></tr></table></figure><p>参数：</p><table><thead><tr><th><strong>Parameter</strong></th><th><strong>Type</strong></th><th><strong>Description</strong></th></tr></thead><tbody><tr><td>keys</td><td>document</td><td>包含字段和值对的文档，其中字段是索引键，值描述该字段的索引类型。对于字段上的升序索引，请指定值1；对于降序索引，请指定值-1。比如： {字段:1或-1} ，其中1 为指定按升序创建索引，如果你想按降序来创建索引指定为 -1 即可。另外，MongoDB支持几种不同的索引类型，包括文本、地理空间和哈希索引。</td></tr><tr><td>options</td><td>document</td><td>可选。包含一组控制索引创建的选项的文档。有关详细信息，请参见选项详情列表。</td></tr></tbody></table><p>options（更多选项）列表：</p><table><thead><tr><th align="left">Parameter</th><th align="left">Type</th><th align="left">Description</th></tr></thead><tbody><tr><td align="left">background</td><td align="left">Boolean</td><td align="left">建索引过程会阻塞其它数据库操作，background可指定以后台方式创建索引，即增加 “background” 可选参数。 “background” 默认值为<strong>false</strong>。</td></tr><tr><td align="left">unique</td><td align="left">Boolean</td><td align="left">建立的索引是否唯一。指定为true创建唯一索引。默认值为<strong>false</strong>.</td></tr><tr><td align="left">name</td><td align="left">string</td><td align="left">索引的名称。如果未指定，MongoDB的通过连接索引的字段名和排序顺序生成一个索引名称。</td></tr><tr><td align="left">dropDups</td><td align="left">Boolean</td><td align="left">在建立唯一索引时是否删除重复记录,指定 true 创建唯一索引。默认值为 <strong>false</strong>.</td></tr><tr><td align="left">sparse</td><td align="left">Boolean</td><td align="left">对文档中不存在的字段数据不启用索引；这个参数需要特别注意，如果设置为true的话，在索引字段中不会查询出不包含对应字段的文档.。默认值为 <strong>false</strong>.</td></tr><tr><td align="left">expireAfterSeconds</td><td align="left">integer</td><td align="left">指定一个以秒为单位的数值，完成 TTL设定，设定集合的生存时间。</td></tr><tr><td align="left">v</td><td align="left">index version</td><td align="left">索引的版本号。默认的索引版本取决于mongod创建索引时运行的版本。</td></tr><tr><td align="left">weights</td><td align="left">document</td><td align="left">索引权重值，数值在 1 到 99,999 之间，表示该索引相对于其他索引字段的得分权重。</td></tr><tr><td align="left">default_language</td><td align="left">string</td><td align="left">对于文本索引，该参数决定了停用词及词干和词器的规则的列表。 默认为英语</td></tr><tr><td align="left">language_override</td><td align="left">string</td><td align="left">对于文本索引，该参数指定了包含在文档中的字段名，语言覆盖默认的language，默认值为 language.</td></tr></tbody></table><p>提示：</p><p>注意在 3.0.0 版本前创建索引方法为 db.collection.ensureIndex() ，之后的版本使用了 db.collection.createIndex() 方法，ensureIndex() 还能用，但只是 createIndex() 的别名。</p><p>【示例】</p><p>（1）单字段索引示例：对 userid 字段建立索引：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell">db.comment.createIndex(&#123;userid:1&#125;)<br>&#123;<br>&quot;createdCollectionAutomatically&quot; : false,<br>&quot;numIndexesBefore&quot; : 1,<br>&quot;numIndexesAfter&quot; : 2,<br>&quot;ok&quot; : 1<br>&#125;<br></code></pre></td></tr></table></figure><p>参数1：按升序创建索引</p><p>可以查看一下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs shell">db.comment.getIndexes()<br>[<br>&#123;<br>&quot;v&quot; : 2,<br>&quot;key&quot; : &#123;<br>&quot;_id&quot; : 1<br>&#125;,<br>    &quot;name&quot; : &quot;_id_&quot;,<br>    &quot;ns&quot; : &quot;articledb.comment&quot;<br>&#125;,<br>&#123;<br>    &quot;v&quot; : 2,<br>    &quot;key&quot; : &#123;<br>    &quot;userid&quot; : 1<br>  &#125;,<br>    &quot;name&quot; : &quot;userid_1&quot;,<br>    &quot;ns&quot; : &quot;articledb.comment&quot;<br>  &#125;<br>]<br></code></pre></td></tr></table></figure><p>索引名字为 userid_1</p><p>（2）复合索引：对 userid 和 nickname 同时建立复合（Compound）索引：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell">db.comment.createIndex(&#123;userid:1,nickname:-1&#125;)<br>&#123;<br>  &quot;createdCollectionAutomatically&quot; : false,<br>  &quot;numIndexesBefore&quot; : 2,<br>  &quot;numIndexesAfter&quot; : 3,<br>  &quot;ok&quot; : 1<br>&#125;<br></code></pre></td></tr></table></figure><p>查看一下索引：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs shell">db.comment.getIndexes()<br>[<br>  &#123;<br>    &quot;v&quot; : 2,<br>    &quot;key&quot; : &#123;<br>    &quot;_id&quot; : 1<br>  &#125;,<br>    &quot;name&quot; : &quot;_id_&quot;,<br>    &quot;ns&quot; : &quot;articledb.comment&quot;<br>&#125;,<br>  &#123;<br>    &quot;v&quot; : 2,<br>    &quot;key&quot; : &#123;<br>    &quot;userid&quot; : 1<br>  &#125;,<br>    &quot;name&quot; : &quot;userid_1&quot;,<br>    &quot;ns&quot; : &quot;articledb.comment&quot;<br>  &#125;,<br>  &#123;<br>    &quot;v&quot; : 2,<br>    &quot;key&quot; : &#123;<br>    &quot;userid&quot; : 1,<br>    &quot;nickname&quot; : -1<br>  &#125;,<br>    &quot;name&quot; : &quot;userid_1_nickname_-1&quot;,<br>    &quot;ns&quot; : &quot;articledb.comment&quot;<br>&#125;<br>]<br></code></pre></td></tr></table></figure><h3 id="索引的移除"><a href="#索引的移除" class="headerlink" title="索引的移除"></a>索引的移除</h3><p>说明：可以移除指定的索引，或移除所有索引</p><p>一、指定索引的移除</p><p>语法：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">db.collection.dropIndex(index)<br></code></pre></td></tr></table></figure><p>参数：</p><table><thead><tr><th>Parameter</th><th>Type</th><th>Description</th></tr></thead><tbody><tr><td>index</td><td>string or document</td><td>指定要删除的索引。可以通过索引名称或索引规范文档指定索引。若要删除文本索引，请指定索引名称。</td></tr></tbody></table><p>【示例】</p><p>删除 comment 集合中 userid 字段上的升序索引：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">db.comment.dropIndex(&#123;userid:1&#125;)<br>&#123; &quot;nIndexesWas&quot; : 3, &quot;ok&quot; : 1 &#125;<br></code></pre></td></tr></table></figure><p>查看已经删除了。</p><p>二、所有索引的移除</p><p>语法：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">db.collection.dropIndexes()<br></code></pre></td></tr></table></figure><p>【示例】</p><p>删除 spit 集合中所有索引。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell">db.comment.dropIndexes()<br>&#123;<br>  &quot;nIndexesWas&quot; : 2,<br>  &quot;msg&quot; : &quot;non-_id indexes dropped for collection&quot;,<br>  &quot;ok&quot; : 1<br>&#125;<br></code></pre></td></tr></table></figure><p>提示： _id 的字段的索引是无法删除的，只能删除非 _id 字段的索引。</p><h2 id="3-4-索引的使用"><a href="#3-4-索引的使用" class="headerlink" title="3.4 索引的使用"></a>3.4 索引的使用</h2><h3 id="执行计划"><a href="#执行计划" class="headerlink" title="执行计划"></a>执行计划</h3><p>分析查询性能（Analyze Query Performance）通常使用执行计划（解释计划、Explain Plan）来查看查询的情况，如查询耗费的时间、是否基于索引查询等。</p><p>那么，通常，我们想知道，建立的索引是否有效，效果如何，都需要通过执行计划查看。</p><p>语法</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">db.collection.find(query,options).explain(options)<br></code></pre></td></tr></table></figure><p>【示例】</p><p>查看根据userid查询数据的情况：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs shell">db.comment.find(&#123;userid:&quot;1003&quot;&#125;).explain()<br>&#123;<br>    &quot;queryPlanner&quot; : &#123;<br>    &quot;plannerVersion&quot; : 1,<br>    &quot;namespace&quot; : &quot;articledb.comment&quot;,<br>    &quot;indexFilterSet&quot; : false,<br>    &quot;parsedQuery&quot; : &#123;<br>    &quot;userid&quot; : &#123;<br>    &quot;$eq&quot; : &quot;1003&quot;<br>  &#125;<br>  &#125;,<br>    &quot;winningPlan&quot; : &#123;<br>    &quot;stage&quot; : &quot;COLLSCAN&quot;,<br>    &quot;filter&quot; : &#123;<br>    &quot;userid&quot; : &#123;<br>    &quot;$eq&quot; : &quot;1003&quot;<br>  &#125;<br>  &#125;,<br>    &quot;direction&quot; : &quot;forward&quot;<br>  &#125;,<br>    &quot;rejectedPlans&quot; : [ ]<br>  &#125;,<br>    &quot;serverInfo&quot; : &#123;<br>    &quot;host&quot; : &quot;9ef3740277ad&quot;,<br>    &quot;port&quot; : 27017,<br>    &quot;version&quot; : &quot;4.0.10&quot;,<br>    &quot;gitVersion&quot; : &quot;c389e7f69f637f7a1ac3cc9fae843b635f20b766&quot;<br>  &#125;,<br>    &quot;ok&quot; : 1<br>&#125;<br></code></pre></td></tr></table></figure><p>关键点看： “stage” : “COLLSCAN”, 表示全集合扫描</p><p>下面对userid建立索引</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell">db.comment.createIndex(&#123;userid:1&#125;)<br>&#123;<br>  &quot;createdCollectionAutomatically&quot; : false,<br>  &quot;numIndexesBefore&quot; : 1,<br>  &quot;numIndexesAfter&quot; : 2,<br>  &quot;ok&quot; : 1<br>&#125;<br></code></pre></td></tr></table></figure><p>再次查看执行计划：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs shell">db.comment.find(&#123;userid:&quot;1013&quot;&#125;).explain()<br>&#123;<br>  &quot;queryPlanner&quot; : &#123;<br>  &quot;plannerVersion&quot; : 1,<br>  &quot;namespace&quot; : &quot;articledb.comment&quot;,<br>  &quot;indexFilterSet&quot; : false,<br>  &quot;parsedQuery&quot; : &#123;<br>    &quot;userid&quot; : &#123;<br>    &quot;$eq&quot; : &quot;1013&quot;<br>    &#125;<br>  &#125;,<br>  &quot;winningPlan&quot; : &#123;<br>    &quot;stage&quot; : &quot;FETCH&quot;,<br>    &quot;inputStage&quot; : &#123;<br>      &quot;stage&quot; : &quot;IXSCAN&quot;,<br>      &quot;keyPattern&quot; : &#123;<br>      &quot;userid&quot; : 1<br>  &#125;,<br>      &quot;indexName&quot; : &quot;userid_1&quot;,<br>      &quot;isMultiKey&quot; : false,<br>      &quot;multiKeyPaths&quot; : &#123;<br>      &quot;userid&quot; : [ ]<br>      &#125;,<br>      &quot;isUnique&quot; : false,<br>      &quot;isSparse&quot; : false,<br>      &quot;isPartial&quot; : false,<br>      &quot;indexVersion&quot; : 2,<br>      &quot;direction&quot; : &quot;forward&quot;,<br>      &quot;indexBounds&quot; : &#123;<br>        &quot;userid&quot; : [<br>        &quot;[\&quot;1013\&quot;, \&quot;1013\&quot;]&quot;<br>  ]<br>  &#125;<br>  &#125;<br>  &#125;,<br>  &quot;rejectedPlans&quot; : [ ]<br>  &#125;,<br>  &quot;serverInfo&quot; : &#123;<br>    &quot;host&quot; : &quot;9ef3740277ad&quot;,<br>    &quot;port&quot; : 27017,<br>    &quot;version&quot; : &quot;4.0.10&quot;,<br>    &quot;gitVersion&quot; : &quot;c389e7f69f637f7a1ac3cc9fae843b635f20b766&quot;<br>  &#125;,<br>  &quot;ok&quot; : 1<br>&#125;<br></code></pre></td></tr></table></figure><p>关键点看： “stage” : “IXSCAN” ,基于索引的扫描</p><h3 id="涵盖的查询"><a href="#涵盖的查询" class="headerlink" title="涵盖的查询"></a>涵盖的查询</h3><p>Covered Queries</p><p>当查询条件和查询的投影仅包含索引字段时，MongoDB直接从索引返回结果，而不扫描任何文档或将文档带入内存。 这些覆盖的查询可以非常有效。</p><p><a href="https://www.mongodb.com/docs/manual/core/query-optimization/#read-operations-covered-query">https://www.mongodb.com/docs/manual/core/query-optimization/#read-operations-covered-query</a></p>]]></content>
    
    
    <categories>
      
      <category>MongoDB</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据库</tag>
      
      <tag>MongoDB</tag>
      
      <tag>NoSQL</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
