<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>高频Linux命令</title>
    <link href="/2024/09/09/%E9%AB%98%E9%A2%91Linux%E5%91%BD%E4%BB%A4/"/>
    <url>/2024/09/09/%E9%AB%98%E9%A2%91Linux%E5%91%BD%E4%BB%A4/</url>
    
    <content type="html"><![CDATA[<h1 id="Linux目录结构介绍"><a href="#Linux目录结构介绍" class="headerlink" title="Linux目录结构介绍"></a>Linux目录结构介绍</h1><ul><li><strong>bin</strong>：是binary的缩写，主要存放一些常用的命令，比如ls、cp、mv之类</li><li>boot：主要存放一些linux启动时需要用到的核心文件</li><li><strong>dev</strong>：是device的缩写，主要存放一些linux的设备文件</li><li><strong>etc</strong>：主要存放系统用户所需要的配置文件和子目录</li><li><strong>home</strong>；主要存放用户目录</li><li><strong>lib</strong>：是library的缩写，主要存放一些动态库，供应用程序调用</li><li>lost+found：一般是空的，当系统非法关机后，相关文件会存在此目录</li><li><strong>media</strong>：自动挂在一些linux系统自动识别的设备，比如U盘，光驱等</li><li><strong>mnt</strong>：提供给用户的用于挂载临时别的文件系统（手动挂载），比如另外的硬盘</li><li>opt：提供给主机额外安装软件所需要的目录</li><li>proc：虚拟的目录，是系统内存的映射，我们可以通过直接访问这个目录来获取系统信息</li><li><strong>root</strong>：超级用户的主目录</li><li>sbin：s是super user的简称，此目录主要存放一些系统管理员所用到的系统管理程序</li><li>srv：主要存放一些系统启动之后要用的数据</li><li>run：主要存放一些系统运行时所需要的一些文件</li><li><strong>usr</strong>：主要存放一些用户的应用程序及文件，类似windows下的program files。bin 存放系统用户所使用的应用程序、sbin 存放超级用户所使用的高级程序及系统守护程序、src 内核源代码默认的放置目录</li><li>tmp：存放一些临时文件</li><li>var：存放一些经常被修改的文件，比如日志文件、电子邮件。</li><li>…</li></ul><h1 id="Linux系统文件或目录颜色的含义"><a href="#Linux系统文件或目录颜色的含义" class="headerlink" title="Linux系统文件或目录颜色的含义"></a>Linux系统文件或目录颜色的含义</h1><ul><li>白色——普通文件</li><li>蓝色——目录</li><li>绿色——可执行文件</li><li>青色——链接文件</li><li>红色——压缩文件</li><li>黄色——设备文件</li><li>灰色——其他文件</li></ul><h1 id="Linux系统常用终端快捷键"><a href="#Linux系统常用终端快捷键" class="headerlink" title="Linux系统常用终端快捷键"></a>Linux系统常用终端快捷键</h1><ul><li>ctrl + f 向前移动光标</li><li>ctrl + b 向后移动光标</li><li>ctrl + a 光标移动到行首</li><li>ctrl + e 光标移动到行位</li><li>ctrl +p 向上翻页，相当于pageUp</li><li>ctrl + n 向下翻页，相当于pageDown</li><li>ctrl + h 删除光标前一个字符</li><li>ctrl + d 删除光标所在字符</li><li>ctrl + u 删除光标至开始全部内容（不包括光标所在字符）</li><li>ctrl + k 删除光标至末尾全部内容（包括光标所在字符）</li><li>ctrl + w 删除光标前单词</li><li>ctrl + y 粘贴使用 ctrl + w、ctrl + u、ctrl + k快捷删除的文本</li></ul><h1 id="Tab键的作用"><a href="#Tab键的作用" class="headerlink" title="Tab键的作用"></a>Tab键的作用</h1><h2 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h2><p>提示可能要输入的命令&#x2F;路径</p><p>补全命令&#x2F;路径</p><h2 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h2><p>如果命令&#x2F;路径是唯一的，则敲击一次tab键自动补全</p><p>如果命令&#x2F;路径不唯一，则敲击两次，将全部可能结果列出来</p><h1 id="通配符介绍"><a href="#通配符介绍" class="headerlink" title="通配符介绍"></a>通配符介绍</h1><ul><li>*：匹配0个或多个字符串</li><li>?：匹配1个字符</li><li>[abcd]：匹配abcd中任意一个字符</li><li>[a-z]：匹配a-z范围里的任意一个字符</li><li>[!abc]：不匹配方括号内任何字符，与[^abc]一致</li></ul><h1 id="touch"><a href="#touch" class="headerlink" title="touch"></a>touch</h1><p>创建空文件与修改时间戳命令</p><h2 id="作用-1"><a href="#作用-1" class="headerlink" title="作用"></a>作用</h2><ol><li>改变已有文件的时间戳属性「注意：在修改文件的时间属性的时候，用户必须是文件的属主，或拥有文件的访问权限」</li><li>创建新的空文件</li></ol><h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><p>touch [OPTION] FILE</p><p>OPTION:</p><ul><li>-a：改变文件的读取时间记录</li><li>-m：改变文件的修改时间记录</li><li>-r：使用参考文件的时间记录，与 –file的效果一样</li><li>-c：不创建新文件</li><li>-d：使用指定字符串表示时间式</li><li>-t：设定文件的时间格式，格式与date命令相同</li><li>–no-create：不创建新文件</li></ul><h2 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h2><p>创建一个空文件 <code>touch file.txt</code> 「前提：file.txt文件不存在」</p><p>创建多个空文件 <code>touch file1.txt file2.txt file3.txt 、touch file&#123;1..3&#125;.txt</code></p><p>修改已有文件的时间戳为当前系统时间（包括修改时间及访问时间）<code>touch file.txt</code></p><p>修改文件的access时间 <code>touch -a file.txt</code></p><p>修改文件的modify时间 <code>touch -m file.txt</code></p><p>强制避免创建新文件 <code>touch -c nofile.txt 、touch --no-create nofile.txt</code></p><p>将访问和修改时间从一个文件复制到另一个文件 <code>touch file -r ref_file.txt</code></p><p>修改文件时间为明天 <code>touch -d &quot;tomorrow&quot; file.txt</code></p><p>修改文件时间为任意时间 <code>touch -t 202409101010 file.txt</code> </p><h1 id="mkdir"><a href="#mkdir" class="headerlink" title="mkdir"></a>mkdir</h1><p>创建目录「注意：默认状态下，如果要创建的目录已经存在，则提示已存在，而不会继续创建目录，新建的目录与它所在目录下的文件有重名也不行」</p><h2 id="语法-1"><a href="#语法-1" class="headerlink" title="语法"></a>语法</h2><p>mkdir [OPTION] DIRECTORY</p><p>OPTION:</p><ul><li>-p：递归创建多级目录</li><li>-m：简历目录的同时设置目录的权限</li><li>-v：显示目录的创建过程</li></ul><h2 id="案例-1"><a href="#案例-1" class="headerlink" title="案例"></a>案例</h2><p>在当前目录下创建一个名为 dir1的目录 <code>mkdir dir1</code></p><p>创建多个目录<code>mkdir dir2 dir3 dir4 、mkdir dir&#123;5..7&#125;</code></p><p>在dir1目录下建立子目录dir10，并设置文件权限700 <code>mkdir -m 700 dir1/dir10</code></p><p>显示目录创建过程 <code>mkdir -v dir&#123;11..13&#125;</code></p><h1 id="rm"><a href="#rm" class="headerlink" title="rm"></a>rm</h1><p>删除文件或目录</p><h2 id="语法-2"><a href="#语法-2" class="headerlink" title="语法"></a>语法</h2><p>rm [OPTION] [FILE]</p><p>OPTION：</p><ul><li>-f：忽略不存在的文件，不会出现警告信息</li><li>-i：删除前会询问用户是否操作</li><li>-r&#x2F;R：递归删除</li><li>-v：显示指令执行详细执行过程</li></ul><h2 id="案例-2"><a href="#案例-2" class="headerlink" title="案例"></a>案例</h2><p>删除一个文件 <code>rm file.txt</code></p><p>删除一个目录 <code>rm -r dir</code></p><p>强制删除文件&#x2F;目录（不带提示） <code>rm -f file.txt</code></p><p>删除当前目录下所有文件 <code>rm -rf *</code></p><p>删除前注意询问 <code>rm -i file1.txt file2.txt file3.txt</code></p><h1 id="rmdir"><a href="#rmdir" class="headerlink" title="rmdir"></a>rmdir</h1><p>删除空目录</p><h2 id="语法-3"><a href="#语法-3" class="headerlink" title="语法"></a>语法</h2><p>rmdir [OPTION] DIRECTORY</p><p>OPTION：</p><ul><li>-p：用递归的方式删除指定的目录路径中的所有父级目录，非空则报错</li><li>-v：显示命令的详细执行过程</li></ul><h2 id="案例-3"><a href="#案例-3" class="headerlink" title="案例"></a>案例</h2><p>删除空目录 <code>rmdir dir</code></p><p>递归删除多重目录 <code>rmdir -p dir1/dir2/dir3</code></p><p>显示指令详细执行过程 <code>rmdir -v dir</code></p><h1 id="mv"><a href="#mv" class="headerlink" title="mv"></a>mv</h1><p>移动文件、重命名文件</p><h2 id="语法-4"><a href="#语法-4" class="headerlink" title="语法"></a>语法</h2><p>mv [OPTION] [-T] SOURCE DEST</p><p>mv [OPTION] SOURCE DIRECTORY</p><p>mv [OPTION] -t DIRECTORY SOURCE </p><p>OPTION：</p><ul><li>-i：若存在同名文件，则向用户询问是否覆盖</li><li>-f：覆盖已有文件，不进行任何提示</li><li>-b：当文件存在时，覆盖前为其创建一个备份</li><li>-u：当源文件比目标文件新，或者目标文件不存在时，才执行移动此操作</li></ul><h2 id="案例-4"><a href="#案例-4" class="headerlink" title="案例"></a>案例</h2><p>将文件file.txt移动到目录dir中 <code>mv file.txt /dir</code></p><p>将file.txt重命名为newfile.txt <code>mv file.txt newfile.txt</code></p><p>将目录dir1移动到目录dir2中（前提是目录dir2已经存在，若不存在则改名） <code>mv dir1 dir2</code></p><p>将文件file1.txt改名为file2.txt，如果file2.txt已经存在，则询问是否覆盖<code>mv -i file1.txt file2.txt</code></p><p>将文件file1.txt改名为file2.txt，如果file2.txt已经存在，则直接覆盖 <code>mv -f file1.txt file2.txt</code></p><p>文件覆盖前做备份 <code>mv -b file1.txt file2.txt</code></p><p>源文件比目标文件新时才执行更新 <code>mv -u file1.txt file2.txt</code></p><p>移动当前文件夹下的所有文件到上一级目录 <code>mv * ../</code></p><p>将当前目录的一个子目录里的文件移动到另一个子目录 <code>mv dir3/* dir2</code></p><h1 id="cp"><a href="#cp" class="headerlink" title="cp"></a>cp</h1><p>复制文件或者目录</p><h2 id="语法-5"><a href="#语法-5" class="headerlink" title="语法"></a>语法</h2><p>cp [OPTION] [-T] SOURCE DEST</p><p>cp [OPTION] SOURCE DIRECTORY</p><p>cp [OPTION] -t DIRECTORY SOURCE</p><p>OPTION:</p><ul><li>-f：若目标文件已存在，则会直接覆盖</li><li>-i：若目标文件已存在，则会询问是否覆盖</li><li>-a：通常在复制目录时使用，它保留链接、文件属性，并复制目录下所有内容</li><li>-r：递归复制文件和目录</li><li>-b：覆盖已存在目标文件前将目标文件备份</li><li>-v：详细显示cp命令的执行过程</li></ul><h2 id="案例-5"><a href="#案例-5" class="headerlink" title="案例"></a>案例</h2><p>复制文件 <code>cp file1.txt file2.txt</code></p><p>复制目录 <code>cp -r dir1 dir2</code></p><p>复制文件，若目标文件已存在，则询问是否覆盖 <code>cp -i file1.txt file2.txt</code></p><p>复制文件，若目标文件已存在，则直接覆盖，不提示 <code>cp -f file1.txt file2.txt</code></p><p>复制文件，若目标文件已存在，则先进行备份 <code>cp -b file1.txt file2.txt</code></p><p>复制目录，并且保留目录所有属性都一致 <code>cp -a dir1 dir2</code></p><h1 id="cd"><a href="#cd" class="headerlink" title="cd"></a>cd</h1><p>切换目录</p><h2 id="语法-6"><a href="#语法-6" class="headerlink" title="语法"></a>语法</h2><p>cd [参数] 目录</p><h3 id="特殊目录"><a href="#特殊目录" class="headerlink" title="特殊目录"></a>特殊目录</h3><ul><li>~：用户家目录</li><li>.：当前目录</li><li>..：当前目录的上一级目录</li><li>&#x2F;：根目录</li><li>-：上次所在目录</li></ul><h3 id="相对路径和绝对路径"><a href="#相对路径和绝对路径" class="headerlink" title="相对路径和绝对路径"></a>相对路径和绝对路径</h3><p>起始路径为 &#x2F; 的称为绝对路径</p><p>起始路径不是 &#x2F; 的称为相对路径</p><h2 id="案例-6"><a href="#案例-6" class="headerlink" title="案例"></a>案例</h2><p>切换到dir目录 <code>cd dir</code></p><p>切换到上两级目录 <code>cd ./..</code></p><p>切换到家目录 <code>cd ~ 或者cd </code></p><p>切换到上一次所在目录 <code>cd -</code></p><h1 id="pwd"><a href="#pwd" class="headerlink" title="pwd"></a>pwd</h1><p>显示当前路径</p><h2 id="语法-7"><a href="#语法-7" class="headerlink" title="语法"></a>语法</h2><p>pwd</p><h1 id="ls"><a href="#ls" class="headerlink" title="ls"></a>ls</h1><p>显示目录信息</p><h2 id="语法-8"><a href="#语法-8" class="headerlink" title="语法"></a>语法</h2><p>ls [OPTION] [FILE]</p><p>OPTION：</p><ul><li>-a：显示所有文件及目录（包括以.开头的隐藏文件）</li><li>-i：使用长格式列出文件及目录信息</li><li>-r：将文件以相反次序显示（默认以英文字母次序）</li><li>-t：根据最后修改时间排序</li><li>-h：以人类可读的格式显示数字大小</li><li>-A：同-a，但不列出 .（当前目录）及 ..（父目录）</li><li>-S：根据文件大小排序</li><li>-R：递归列出所有子目录</li><li>-F：在列出的文件名称后加一符号，例如可执行的加 *，目录则加 &#x2F;</li></ul><h2 id="案例-7"><a href="#案例-7" class="headerlink" title="案例"></a>案例</h2><p>列出当前目录所有文件（包括隐藏文件） <code>ls -a</code></p><p>列出当前目录文件的详细信息 <code>ls -l</code></p><p>列出根目录 &#x2F; 下的所有文件 <code>ls /</code></p><p>列出当前目录下所有文件和目录的详细信息（包括子目录内容）<code>ls -lR</code></p><p>列出当前目录下所有f开头的文件的详细信息 <code>ls -l f*</code></p><p>列出当前目录下所有文件，并根据修改时间倒序排列 <code>ls -ltr</code></p><p>列出目前工作目录下所有文件及目录，目录于名称后加 &#x2F;，可执行文件于名称后加 * <code>ls -AF</code></p><p>列出档期啊内目录详细信息并以可读大小显示文件大小 <code>ls -lh</code></p><h1 id="tree"><a href="#tree" class="headerlink" title="tree"></a>tree</h1><p>以树状图列出目录内容</p><h2 id="语法-9"><a href="#语法-9" class="headerlink" title="语法"></a>语法</h2><p>tree [参数]</p><p>参数：</p><ul><li>-a：显示所有文件和目录</li><li>-L：层级显示</li><li>-t：用文件和目录的更改时间排序</li><li>-r：用文件和目录的更改时间倒序排序</li><li>-f：在每个文件或目录之前，显示完整的相对路径名称</li><li>-d：显示目录名称而非内容</li></ul><h2 id="案例-8"><a href="#案例-8" class="headerlink" title="案例"></a>案例</h2><p>显示以当前目录下的文件和目录 <code>tree</code></p><p>显示所有文件和目录 <code>tree -a</code></p><p>只显示目录 <code>tree -d</code></p><p>只显示n层目录（n为数字，假设n为2） <code>tree -L 2</code></p><p>显示权限信息 <code>tree -p</code></p><p>用文件和目录的更改时间排序 <code>tree -t</code></p><p>以相反次序排序 <code>tree -r</code></p><p>显示完整的相对路径 <code>tree -f</code></p><h1 id="stat"><a href="#stat" class="headerlink" title="stat"></a>stat</h1><p>显示文件或文件系统的详细信息</p><h2 id="语法-10"><a href="#语法-10" class="headerlink" title="语法"></a>语法</h2><p>stat [OPTION]  FILE</p><p>OPTION：</p><ul><li>-L：支持符号链接</li><li>-f：显示文件系统的信息</li><li>-t：以简洁的方式输出</li></ul><h2 id="三种时间"><a href="#三种时间" class="headerlink" title="三种时间"></a>三种时间</h2><p>atime：access time 访问时间，读取文件（more、less、cat、tail）、修改文件（vim、nano）时改变</p><p>mtime：modify time 修改时间，修改文件（vim&#x2F;nano）时改变</p><p>ctime：change time状态改变时间，修改文件（vim、nano）、文件属性变化（chmod、chown）时改变</p><h2 id="案例-9"><a href="#案例-9" class="headerlink" title="案例"></a>案例</h2><p>查看文件file.txt的信息 <code>stat file.txt</code></p><p>查看file.txt文件所在文件系统信息 <code>stat -f file.txt</code></p><p>以简洁方式输出信息 <code>stat -t file.txt</code></p><h1 id="rename"><a href="#rename" class="headerlink" title="rename"></a>rename</h1><p>用字符串替换的方式批量改变文件名</p><h2 id="语法-11"><a href="#语法-11" class="headerlink" title="语法"></a>语法</h2><p>rename ‘s&#x2F;old-name&#x2F;new-name&#x2F;‘ files</p><p>元字符串：将文件名需要替换的字符串</p><p>目标字符串：将文件名中含有的原字符串替换成目标字符串</p><p>文件：指定要改变文件名的文件列表</p><h3 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h3><ul><li>-n：模拟运行，实际命令没进行重命名</li><li>-v：输出每步执行信息</li><li>-f：强制改写</li></ul><h3 id="通配符"><a href="#通配符" class="headerlink" title="通配符"></a>通配符</h3><p>？可替代单个字符</p><p>* 可替代多个字符</p><h2 id="案例-10"><a href="#案例-10" class="headerlink" title="案例"></a>案例</h2><p>将myfile.txt 改为 myfile.doc <code>rename &#39;s/.txt/.doc&#39; myfile.txt</code></p><p>模拟将file1.txt，file2.txt，file3.txt改为file01.txt，file02.txt，file03.txt  <code>rename -n &#39;s/file/file0/ file*&#39;</code></p><p>实际更改上一步，并输出执行过程信息 <code>rename -v &#39;s/file/file0/&#39; myfile.txt</code></p><h1 id="basename"><a href="#basename" class="headerlink" title="basename"></a>basename</h1><p>提取文件路径名的文件名</p><h2 id="语法-12"><a href="#语法-12" class="headerlink" title="语法"></a>语法</h2><p>basename NAME [SUFFIX]</p><p>basename OPTION NAME</p><p>参数：</p><ul><li>-a：支持处理多个文件</li><li>-s：删除指定后缀</li></ul><h2 id="案例-11"><a href="#案例-11" class="headerlink" title="案例"></a>案例</h2><p>提取文件名 <code>basename /etc/passwd</code></p><p>提取目录名（删除最后的&#x2F;） <code>basename /usr/local/</code></p><p>提取多个输入 <code>basename -a /etc/passwd /usr/local</code></p><p>删除指定后缀 <code>basename /etc/sysctl.conf .conf 或 base -s .conf /etc/sysctl.conf</code></p><h1 id="dirname"><a href="#dirname" class="headerlink" title="dirname"></a>dirname</h1><p>去除文件名中的非目录部分</p><h2 id="语法-13"><a href="#语法-13" class="headerlink" title="语法"></a>语法</h2><p>dirname [OPTION] NAME</p><h2 id="案例-12"><a href="#案例-12" class="headerlink" title="案例"></a>案例</h2><p>提取文件的路径 <code>dirname /usr/bin/cat</code></p><p>提取目录的路径 <code>dirname /home/work/test</code></p><h1 id="file"><a href="#file" class="headerlink" title="file"></a>file</h1><p>识别文件类型</p><h2 id="语法-14"><a href="#语法-14" class="headerlink" title="语法"></a>语法</h2><p>file [参数] 文件</p><p>参数：</p><ul><li>-b：列出文件类型，不显示文件名称</li><li>-c：详细显示指令执行过程</li><li>-f：指定名称文件，显示多个文件类型信息</li><li>-L：直接显示符号链接所指向的文件类型</li><li>-m：指定魔法数字文件</li><li>-z：尝试去解读压缩文件的内容</li><li>-i：显示MIME类别</li></ul><h2 id="案例-13"><a href="#案例-13" class="headerlink" title="案例"></a>案例</h2><p>查看文件的类型 <code>file file.txt   file dir   file /dev/sda</code></p><p>查看文件类型，但不显示文件名 <code>file -b file.txt</code></p><p>查看某个符号链接文件（快捷方式）的类型 <code>file /dev/cdrom</code></p><p>直接查看某个符号链接文件（快捷方式）所对应的目标文件的文件类型 <code>file -L /dev/cdrom</code></p><h1 id="md5sum"><a href="#md5sum" class="headerlink" title="md5sum"></a>md5sum</h1><p>生成和校验文件的md5值</p><h2 id="语法-15"><a href="#语法-15" class="headerlink" title="语法"></a>语法</h2><p>md5sum [OPTION] [FILE]</p><p>OPTION：</p><ul><li>-b：以二进制模式读取文件</li><li>-t：以文本模式读入文件内容</li><li>-c：根据已生成的md5值，对现存文件进行校验</li><li>–status：校验完成后，不生成错误或正确的提示信息，可以通过命令的返回值来判断</li></ul><h2 id="案例-14"><a href="#案例-14" class="headerlink" title="案例"></a>案例</h2><p>生成file.txt文件的md5值 <code>md5sum file.txt</code></p><p>不同模式计算同一个文件的md5值 <code>md5sum -b file.txt  md5sum -t file.txt</code></p><p>将生成md5值重定向到指定的文件 <code>md5sum file.txt &gt; file.md5</code></p><p>md5校验 <code>md5sum -c file.md5</code></p><p>md5校验，不显示任何输出，用返回码表示成功与否 <code>md5sum -c --status file.md5   然后 echo $?</code></p><h1 id="find"><a href="#find" class="headerlink" title="find"></a>find</h1><p>搜索指定文件</p><h2 id="语法-16"><a href="#语法-16" class="headerlink" title="语法"></a>语法</h2><p>find [路径] [参数] [条件] </p><p>参数：</p><ul><li>-name name，-iname name：文件名符合name的文件，iname会忽略大小写</li><li>-perm 匹配权限（mode为完全匹配-mode为包含即可）</li><li>-user 匹配所有者</li><li>-group 匹配所有组</li><li>-mtime -n +n 匹配修改内容的时间（-n指n天以内，+n指n天以前）</li><li>-atime -n +n 匹配访问文件的时间（-n指n天以内，+n指n天以前）</li><li>-ctime -n +n 匹配修改文件权限的时间（-n指n天以内，+n指n天以前）</li><li>-nouser 匹配无所有者的文件</li><li>-nogroup 匹配无所有组的文件</li><li>-newer f1 !f2 匹配比文件f1新但比f2旧的文件</li><li>-type b&#x2F;d&#x2F;c&#x2F;p&#x2F;l&#x2F;f 匹配文件类型（后面的字母依次表示 块设备、目录、字符设备、管道、链接文件、文本文件）</li><li>-size 匹配文件的大小（+50KB为查找超过50KB的文件，而-50KB为查找小于50KB的文件）</li><li>-prune 忽略某个目录</li><li>-exec ….{}; 后面可跟用于进一步处理搜索结果的命令</li></ul><h2 id="案例-15"><a href="#案例-15" class="headerlink" title="案例"></a>案例</h2><p>全盘搜索系统中所有以 .conf 结尾的文件 <code>find / -name *.conf</code></p><p>在&#x2F;etc 目录中搜索所有大约 1k 大小的文件 <code>find /etc -size +1k</code></p><p>在 &#x2F;home 目录中搜索所有属于指定用户的文件 <code>find /home -user xxx</code></p><p>搜索当前目录下所有的文件 <code>find . -type f</code></p><p>搜索当前目录下所有权限为 664的文件，并列出 <code>find . -perm 664 -exec ls -l &#123;&#125;\;</code></p><p>列出当前工作目录中的所有文件、目录以及子文件信息 <code>find .</code></p><p>在当前目录下搜索所有指定后缀的文件，后缀不需要大小写 <code>find . -name &quot;*.txt&quot;</code></p><p>在当前目录下下搜索所有后缀不是 .txt的文件 <code>find . ! -name &quot;*.txt&quot;</code></p><p>搜索当前工作目录的所有7天内被修改过的文件，并删除  <code>find . -mtime -7 -exec rm --i &#123;&#125;\;</code></p><h1 id="which"><a href="#which" class="headerlink" title="which"></a>which</h1><p>查找命令文件所在位置</p><h2 id="语法-17"><a href="#语法-17" class="headerlink" title="语法"></a>语法</h2><p>which [-a] filename </p><h2 id="案例-16"><a href="#案例-16" class="headerlink" title="案例"></a>案例</h2><p>查找文件所在位置 <code>which bash  which is  which fdisk</code></p><h1 id="chown"><a href="#chown" class="headerlink" title="chown"></a>chown</h1><p>改变文件或目录的用户和用户组</p><h2 id="语法-18"><a href="#语法-18" class="headerlink" title="语法"></a>语法</h2><p>chown [参数] 所属主:所属组 文件</p><p>参数：</p><ul><li>-R 对目前目录下的所有文件与目录进行相同的变更</li><li>-c 显示所属信息变更信息</li></ul><h2 id="案例-17"><a href="#案例-17" class="headerlink" title="案例"></a>案例</h2><p>改变file.txt文件的所属主与所属组 <code>sudo chown xxx:xxx file.txt</code></p><p>只改变file.txt文件的所属主 <code>sudo chown xxx file.txt</code></p><p>只改变file.txt文件的所属组 <code>sudo chowm :xxx file.txt</code></p><p>改变指定文件的所属主与所属组，并显示过程 <code>chown -c xxx:xxx file.txt</code></p><p>改变指定目录及其所有子文件的所属主与所属组 <code>sudo chown -R xxx:xxx dir</code></p><h1 id="chgrp"><a href="#chgrp" class="headerlink" title="chgrp"></a>chgrp</h1><p>更改文件用户组</p><h2 id="语法-19"><a href="#语法-19" class="headerlink" title="语法"></a>语法</h2><p>chgrp [参数] [目录]</p><p>参数：</p><ul><li>-v：显示指令执行过程</li><li>-R：递归处理，并将指定目录下的所有文件及子目录一并处理</li><li>–reference：把指定文件或目录的所属群组全部设成参考文件或目录的所属群组</li></ul><h2 id="案例-18"><a href="#案例-18" class="headerlink" title="案例"></a>案例</h2><p>改变文件的用户组 <code>sudo chgrp xxx file.txt</code></p><p>改变文件的用户组，并显示命令执行过程 <code>sudo chgrp -v xxx file.txt</code></p><p>根据参照文件改变文件的用户组 <code>sudo chgrp --reference=reffile.txt file.txt</code></p><p>将dir及其子目录下的所有文件的用户组改为xxx <code>sudo -R xxx dir</code></p><h1 id="chmod"><a href="#chmod" class="headerlink" title="chmod"></a>chmod</h1><p>改变文件或目录的权限（只有自己是文件或目录的属主、或者是root用户才能执行）</p><h2 id="语法-20"><a href="#语法-20" class="headerlink" title="语法"></a>语法</h2><p>chomd [OPTION] MODE[MODE] FILE</p><p>chmod [OPTION] OCTAL -MODE FILE</p><p>chmod [OPTION] –reference&#x3D;RFILE FILE</p><h3 id="两种模式"><a href="#两种模式" class="headerlink" title="两种模式"></a>两种模式</h3><ol><li><p>符号模式</p><p>格式： [ugoa][+-&#x3D;] [rwx]</p><p>对象：</p><table><thead><tr><th>对象</th><th>用户类型</th><th>说明</th></tr></thead><tbody><tr><td>u</td><td>user</td><td>文件所有者</td></tr><tr><td>g</td><td>group</td><td>文件所有者所在组</td></tr><tr><td>o</td><td>other</td><td>所有其他用户</td></tr><tr><td>a</td><td>all</td><td>所有用户，相当于ugo</td></tr></tbody></table><p>操作：</p><table><thead><tr><th>操作</th><th>说明</th></tr></thead><tbody><tr><td>+</td><td>为指定的用户类型增加权限</td></tr><tr><td>-</td><td>为指定的用户类型去除权限</td></tr><tr><td>&#x3D;</td><td>设置指定用户权限的设置，即将用户类型的所有权限重新设置</td></tr></tbody></table><p>权限：</p><table><thead><tr><th>权限</th><th>名字</th><th>说明</th></tr></thead><tbody><tr><td>r</td><td>读</td><td>设置为读权限</td></tr><tr><td>w</td><td>写</td><td>设置为写权限</td></tr><tr><td>x</td><td>执行</td><td>设置为可执行权限</td></tr></tbody></table></li><li><p>数字模式</p><p><img src="https://gxc-hexo-blog.oss-cn-beijing.aliyuncs.com/blog/linux_cmd_chmod.png"></p></li></ol><p>参数：</p><ul><li>-R：对当前目录下的所有文件与子目录进行相同的权限变更（即以递归的方式逐个变更）</li></ul><h2 id="案例-19"><a href="#案例-19" class="headerlink" title="案例"></a>案例</h2><p>将文件file.txt设置为所有人都可读取 <code>chmod a+r file.txt</code></p><p>将当前目录下所有文件及递归目录文件设置为所有人可读取 <code>dhmod -R a+r *</code></p><p>将file.txt设置为只有该文件拥有者才可以执行 <code>chmod -u+x file.txt</code></p><p>将file.txt设置为文件拥有者及其同组人员可写入，但其他人不可写入 <code>chmod ug+w, o-w file.txt</code></p><p>将file.txt设置为所有人都可读可写可执行 <code>chmod a+r,a+w,a+x file.txt  chmod 777 file.txt</code></p><p>将file.txt设置为文件拥有者可读可写可执行 <code>chmod 755 file.txt</code></p><p>将file.txt设置为文件拥有者可读可写可执行，此外其他人都没任何权限 <code>chmod u=rw, go= file.txt</code></p><h1 id="grep"><a href="#grep" class="headerlink" title="grep"></a>grep</h1><p>文本搜索工具</p><h2 id="语法-21"><a href="#语法-21" class="headerlink" title="语法"></a>语法</h2><p>grep [参数] 文件</p><p>参数：</p><ul><li>-i：忽略大小写</li><li>-c：只输出匹配行的数量</li><li>-l：只列出匹配的文件名，不列出具体的匹配行</li><li>-n：列出所有的匹配行，显示行号</li><li>-h：查询多文件时不显示文件名</li><li>-s：不显示不存在、没有匹配文本的错误信息</li><li>-v：显示不包含匹配文本的所有行</li><li>-w：匹配整词</li><li>-x：匹配整行</li><li>-r：递归搜索</li><li>-q：禁止输出任何结果，已退出状态表示搜索是否成功</li><li>-b：打印匹配行距文件头部的偏移量，以字节为单位</li><li>-o：与-b结合使用，打印匹配的词距文件头部的偏移量，以字节为单位</li><li>-F：匹配固定字符串的内容</li><li>-E：支持扩展的正则表达式</li></ul><h2 id="案例-20"><a href="#案例-20" class="headerlink" title="案例"></a>案例</h2><p>搜索某个文件中，包含某个关键词的内容 <code>grep xxx /etc/passwd</code></p><p>搜索多个文件中，包含某个关键词的内容 <code>grep xxx /etc/passwd /etc/shadow</code></p><p>搜索多个文件中，包含某个关键词的内容，不显示文件名称 <code>grep -h xxx /etc/passwd /etc/shadow</code></p><p>递归搜索，不仅搜索指定目录，还搜索其子目录内是否有关键词文件 <code>grep -r hello *</code></p><p>输出在某个文件中，包含某个关键词行的数量 <code>grep -c root /etc/passwd /etc/shadow</code></p><p>忽略大小写 <code>grep -i XXX /etc/passwd</code></p><p>在文件中查找要搜索的内容，并显示行号 <code>grep -n xxx /etc/passwd</code></p><p>反向查找 <code>grep -v xxx /etc/passwd</code></p><p>搜索当前工作目录中，包含某个关键词内容的文件，未找到的则提示 <code>grep -l hello *</code></p><p>搜索某个文件中，精准匹配到某个关键词的内容 <code>grep -x hello file1.txt</code></p><p>判断某个文件中，是否包含某个关键词，通过返回状态输出结果（0未包含，1未不包含），方便在shell脚本中判断和调用<code>grep -q hello file1.txt</code></p><h1 id="egrep"><a href="#egrep" class="headerlink" title="egrep"></a>egrep</h1><p>查找指定的字符串</p><h2 id="语法-22"><a href="#语法-22" class="headerlink" title="语法"></a>语法</h2><p>egrep [参数] [文件]</p><p>参数 同grep</p><h2 id="案例-21"><a href="#案例-21" class="headerlink" title="案例"></a>案例</h2><p>查找包含一个或一个以上 “a” 的内容 <code>egrep &#39;a+&#39; file.txt</code></p><p>查找包含linux或xxx的内容 <code>egrep &#39;linux|xxx&#39; file.txt</code></p><p>查找包含linux整体的内容 <code>egrep &#39;(linux)&#39; file.txt</code></p><p>查找包含一个或多个linux整体的内容 <code>egrep &#39;(linux)+&#39; file.txt</code></p><p>查找以#开头的内容 <code>egrep &#39;^#&#39; file.txt</code></p><p>查找以linux结尾的内容 <code>egrep &#39;linux$&#39; file.txt</code></p><p>查找连续出现3次ab的内容 <code>egrep &#39;(ab)&#123;3&#125;&#39; file.txt</code></p><p>查找包括abc或abd的内容 <code>egrep &#39;ab[cd]&#39; file.txt</code></p><h1 id="cat"><a href="#cat" class="headerlink" title="cat"></a>cat</h1><p>在终端上显示文件内容</p><h2 id="语法-23"><a href="#语法-23" class="headerlink" title="语法"></a>语法</h2><p>cat [OPTION] [FILE]</p><p>OPTION：</p><ul><li>-n：显示行数（空行也编号）</li><li>-s：去除重复的行</li><li>-b：显示行数（空行不编号）</li><li>-E：每行结束处显示$符号</li><li>-T：将TAB字符显示为 ^| 符号</li></ul><h2 id="案例-22"><a href="#案例-22" class="headerlink" title="案例"></a>案例</h2><p>查看file.txt文件内容 <code>cat file.txt</code></p><p>查看多个文件内容 <code>cat file1.txt file2.txt</code></p><p>查看file.txt文件内容，并显示行数编号 <code>cat -n file.txt</code></p><p>去除重复的空行 <code>cat -s file.txt</code></p><p>重定向文件内容 <code>cat file.txt &gt; file.txt</code></p><p>将file1.txt和file2.txt合并为一个文件 <code>cat file1.txt file2.txt &gt; combinedifile.txt</code></p><p>使用cat创建文件 <code>cat &gt; file.txt</code></p><h1 id="more"><a href="#more" class="headerlink" title="more"></a>more</h1><p>分页显示文本文件内容</p><h2 id="语法-24"><a href="#语法-24" class="headerlink" title="语法"></a>语法</h2><p>more [OPTION] file</p><p>基本操作：回车 下滚一行 空格 下翻一页</p><p>OPTION：</p><ul><li>-num：指定每屏显示的行数</li><li>+num：从第nun行开始显示</li><li>-p：先清除屏幕再显示文本文件的剩余内容</li><li>-c：与-p相似，不滚屏，先显示内容再清楚旧内容</li><li>-s：多个空行压缩成一行显示</li></ul><h2 id="案例-23"><a href="#案例-23" class="headerlink" title="案例"></a>案例</h2><p>分页显示指定的文本文件内容<code>more ~/.bashrc</code></p><p>先进行清屏操作，随后以每次10行内容的格式显示指定的文本文件内容 <code>more -c 10 ~/.bashrc</code></p><p>分页显示指定的文本文件内容，遇到连续两行以上空白行的情况，则以一行空白行显示 <code>more -s ~/.bashrc</code></p><p>从第10行开始，分页显示指定的文本文件内容 <code>more +10 ~/.bashrc</code></p><h1 id="less"><a href="#less" class="headerlink" title="less"></a>less</h1><p>分页显示文本内容</p><h2 id="语法-25"><a href="#语法-25" class="headerlink" title="语法"></a>语法</h2><p>less [参数] 文件</p><p>参数：</p><ul><li>-N：显示每行的行号。</li><li>-i：忽略大小写进行搜索。</li><li>-R：以原始格式显示文件内容，不解释特殊字符。</li><li>-F：强制less一次性显示整个文件，不进行分页。</li><li>&#x2F;：用于搜索指定的字符串。</li><li>?：用于向后搜索指定的字符串。</li><li>h：显示帮助信息。</li></ul><p>快捷操作</p><ul><li>空格键：下翻一页</li><li>回车键：下滚一行</li><li>j：下滚一行</li><li>k：上滚一行</li><li>b：回翻一页</li><li>f：下翻一页</li><li>q：退出</li><li>&#x2F;word：搜索word关键词</li><li>n：跳转下一个搜索匹配项</li><li>N：跳转上一个搜索匹配项</li><li>g：跳转到文件开头</li><li>G：跳转到文件末尾</li></ul><h2 id="案例-24"><a href="#案例-24" class="headerlink" title="案例"></a>案例</h2><p>查看文件 <code>less ~/.bashrc</code></p><p>查看多个文件 <code>less ~/.bashrc ~/.bash_history</code> :n浏览下一个文件 :p浏览前一个文件</p><p>查看历史命令并使用less命令分页显示 <code>history | less</code></p><h1 id="head"><a href="#head" class="headerlink" title="head"></a>head</h1><p>显示文件开头的内容</p><p>参数：</p><ul><li>-n：加数字，定义显示行数</li><li>-c：加数字，指定显示头部内容的字符数</li></ul><h2 id="案例-25"><a href="#案例-25" class="headerlink" title="案例"></a>案例</h2><p>显示文件的前10行内容（默认） <code>head ~/.bashrc</code></p><p>显示文件的前5行内容<code>head -n ~/.bashrc </code></p><p>显示文件除了最后6行的全部内容 <code>head -n -6 ~/.bashrc</code></p><p>显示文件前20个字符 <code>head -c 20 ~/.bashrc</code></p><p>显示文件除了最后30个字符的全部内容<code>head -c -30 ~/.bashrc</code></p><h1 id="tail"><a href="#tail" class="headerlink" title="tail"></a>tail</h1><p>查看文件尾部内容</p><h2 id="语法-26"><a href="#语法-26" class="headerlink" title="语法"></a>语法</h2><p>tail [OPTION] [FILE]</p><p>参数：</p><ul><li>-c：N输出文件尾部N个字节内容</li><li>-f：显示文件最新追加的内容</li><li>-n：N输出文件的尾部N行内容</li></ul><h2 id="案例-26"><a href="#案例-26" class="headerlink" title="案例"></a>案例</h2><p>显示file.txt文件的最后10行内容 <code>tail file.txt</code></p><p>显示file.txt文件的最后20行内容 <code>tail -n 20 file.txt</code></p><p>动态显示文件的最后10行内容 <code>tail -f file.txt</code></p><h1 id="tac"><a href="#tac" class="headerlink" title="tac"></a>tac</h1><p>反向显示文件的内容，与cat相反，先显示倒数第一行，依次到第一行</p><h2 id="语法-27"><a href="#语法-27" class="headerlink" title="语法"></a>语法</h2><p>tac [参数] [FILE]</p><h2 id="案例-27"><a href="#案例-27" class="headerlink" title="案例"></a>案例</h2><p><code>tac file.txt</code></p><h1 id="nl"><a href="#nl" class="headerlink" title="nl"></a>nl</h1><p>添加行号</p><h2 id="语法-28"><a href="#语法-28" class="headerlink" title="语法"></a>语法</h2><p>nl [OPTION] [FILE]</p><p>OPTION：</p><ul><li>-b a：也给空行添加行号(类似cat -n)</li><li>-b t：空行不显示行号</li><li>-n：列出行号表示的方法。「-n nl 行号显示在屏幕的左方显示」「-n rn 行号显示在自己栏位的最右方显示，且不加0」「-n rz 行号在自己栏位的最右方显示，且加0」</li><li>-w：行号栏位的占用位数</li></ul><h2 id="案例-28"><a href="#案例-28" class="headerlink" title="案例"></a>案例</h2><p>用nl列出file.txt的内容 <code>nl file.txt</code></p><p>用nl列出file.txt的内容，空行也加上行号 <code>nl -b a file.txt</code></p><p>行号在自己栏位的最右方显示，且加0对齐格式 <code>nl -b a -n rz file.txt</code></p><p>行号宽度设置为3 <code>nl -b -a -n rz -w 3 file.txt</code></p><p>空行不显示行号 <code>nl -b file.txt</code></p><h1 id="WC"><a href="#WC" class="headerlink" title="WC"></a>WC</h1><p>统计文本信息</p><h2 id="语法-29"><a href="#语法-29" class="headerlink" title="语法"></a>语法</h2><p>wc [OPTION] [FILE]</p><p>OPTION：</p><ul><li>-w：统计字数，或–words，只显示字数，一个字被定义为由空白、跳格或换行字符分隔的字符串</li><li>-c：统计字节数，或–bytes或–chars，只显示Bytes数</li><li>-l：统计行数，或–lines，只显示行数</li><li>-m：统计字符数</li><li>-L：打印最长行的长度（不包含不可见字符）</li></ul><h2 id="案例-29"><a href="#案例-29" class="headerlink" title="案例"></a>案例</h2><p>统计file.txt文件的行数、字数、以及字节数 <code>wc file.txt</code></p><p>统计file.txt文件的字数 <code>wc -w file.txt</code></p><p>统计file.txt文件的字符数 <code>wc -m file.txt</code></p><p>统计file.txt文件的字节数 <code>wc -c file.txt</code></p><p>统计file.txt文件的行数 <code>wc -l file.txt</code></p><p>打印file.txt文件最长行的长度 <code>wc -L file.txt</code></p><p>使用管道符统计文本行数 <code>cat file.txt | wc -l</code></p><h1 id="split"><a href="#split" class="headerlink" title="split"></a>split</h1><p>文件分割</p><h2 id="语法-30"><a href="#语法-30" class="headerlink" title="语法"></a>语法</h2><p>split [OPTION] [FILE [PREFIX]]</p><p>OPTION:</p><ul><li>-&lt;行数&gt; 或 -l 行数：指定每多少行切成一个小文件</li><li>-b&lt;字节&gt;：指定每多少个字节切成一个小文件</li><li>-d：使用数字作为后缀</li><li>-a：指定后缀长度（默认为2）</li><li>[输出文件名]设置切割后文件的前置文件名，split会自动在前置文件名后再加上编号</li></ul><h2 id="案例-30"><a href="#案例-30" class="headerlink" title="案例"></a>案例</h2><p>将file.txt每2行切割成一个小文件 <code>split -2 file.txt</code></p><p>将file.txt每10kb切割成一个小文件 <code>split -b 10k file.txt</code></p><p>以数字作为后缀，并指定后缀宽度为3 <code>split -b 10k -d -a 3 file.txt</code></p><p>为分割后的文件指定文件名前缀 <code>split -b 10k -d -a 3 file.txt split_file</code></p><h1 id="cut"><a href="#cut" class="headerlink" title="cut"></a>cut</h1><p>从文件中提取文本的一部分</p><h2 id="语法-31"><a href="#语法-31" class="headerlink" title="语法"></a>语法</h2><p>cut [OPTION] [FILE]</p><p>OPTION:</p><ul><li>-b：以字节为单位进行分割，仅显示行中指定直接范围的内容</li><li>-c：以字符为单位进行分割，进现实行中指定范围的字符</li><li>-d：自动以分隔符，默认为制表符”TAB”</li><li>-f：显示指定字段的内容，与-d一起使用</li><li>-n：取消分割多字节字符</li><li>–complement：补足被选择的字节、字符或字段</li><li>–out-delimiter：指定输出内容是字段分隔符</li></ul><h2 id="案例-31"><a href="#案例-31" class="headerlink" title="案例"></a>案例</h2><p>提取file1.txt第2列的内容 <code>cut -f 2 file.txt  或  cut -f2 file.txt</code></p><p>提取filt.txt除第2行之外的其他内容 <code>cut -f2 --complement file.txt</code></p><p>使用-d选项指定字段分隔符 <code>cut -f2 -d&quot;.&quot; file.txt</code></p><p>提取第2,3,4,6个字符 <code>cut -b 2-4, 6 file.txt</code></p><p>提取指定数量字符：</p><pre><code class="hljs">- 提取第一个到第三个字符 `cut -c1-3 file.txt`- 提取前两个字符 `cut -c -2 file.txt`- 提取第4个之后的字符 `cut -c4- file.txt`</code></pre><h1 id="paste"><a href="#paste" class="headerlink" title="paste"></a>paste</h1><p>合并两个或多个文件</p><h2 id="语法-32"><a href="#语法-32" class="headerlink" title="语法"></a>语法</h2><p>paste [OPTION] [FILE]</p><p>OPTION：</p><ul><li>-d：默认域的分隔符是空格或者tab键，设置行的域分隔符</li><li>-s：将每个文件粘贴成一行</li><li>-：从标准输入中读取数据</li></ul><h2 id="案例-32"><a href="#案例-32" class="headerlink" title="案例"></a>案例</h2><p>将file1.txt和file2.txt粘贴成一个新的文件 <code>paste file1.txt file2.txt</code></p><p>顺序不一样，结果不一样 <code>paste file2.txt file1.txt</code></p><p>多文件拼接 <code>paste file1.txt file2.txt file3.txt</code></p><p>设置域分隔符为”:” 粘贴成新的文件 <code>paste -d&quot;:&quot; file1.txt file2.txt</code></p><p>将每个文件粘贴成一行 <code>paste -d&quot;:&quot; -s file1.txt file2.txt</code></p><p>从标准输入中读取数据，每行显示3个文件名 <code>ls | paste -d &quot;&quot; - - - -</code></p><h1 id="sort"><a href="#sort" class="headerlink" title="sort"></a>sort</h1><p>对文件内容进行排序</p><h2 id="语法-33"><a href="#语法-33" class="headerlink" title="语法"></a>语法</h2><p>sort [参数] 文件</p><p>参数：</p><ul><li>-n：依照数值的大小排序</li><li>-t &lt;分隔字符&gt;：指定排序时所用的栏位分割字符</li><li>-k：指定需要排序的栏位</li><li>-f：以相反的顺序来排序</li></ul><h2 id="案例-33"><a href="#案例-33" class="headerlink" title="案例"></a>案例</h2><p>按照字母顺序排序 <code>sort file.txt</code></p><p>反向排序 <code>sort -r file.txt</code></p><p>按照数字大小排序 <code>sort -n file.txt</code></p><p>以冒号为间隔符，对指定的文件内容按照数字大小对第三列进行排序 <code>sort -t : -k 3 -n file.txt</code></p><h1 id="uniq"><a href="#uniq" class="headerlink" title="uniq"></a>uniq</h1><p>去除文件中的重复行</p><h2 id="语法-34"><a href="#语法-34" class="headerlink" title="语法"></a>语法</h2><p>uniq [OPTION] [INPUT] [OUTPUT]</p><p>OPTION：</p><ul><li>-c：打印每行在文本中重复出现的次数</li><li>-d：只显示有重复的记录，每个重复记录只出现一次</li><li>-u：只显示没有重复的记录</li></ul><h2 id="案例-34"><a href="#案例-34" class="headerlink" title="案例"></a>案例</h2><p>删除连续文件中连续的重复行 <code>uniq file.txt</code></p><p>打印每行在文件中出现重复的次数 <code>uniq -c file.txt</code></p><p>只显示有重复的记录，且每个记录只出现一次 <code>uniq -d file.txt</code></p><p>只显示没有重复的记录 <code>uniq -u file.txt</code></p><h1 id="diff"><a href="#diff" class="headerlink" title="diff"></a>diff</h1><p>比较文件的差异</p><h2 id="语法-35"><a href="#语法-35" class="headerlink" title="语法"></a>语法</h2><p>diff [OPTION] FILES</p><p>OPTION：</p><ul><li>y：以并列的方式显示文件的异同之处</li><li>c：显示全部内文：并标出不同之处</li><li>u：以合并的方式来显示文件内容的不同</li><li>-W：设置宽度</li></ul><p>显示提示：</p><ul><li>a - add</li><li>c - change</li><li>d - delete</li><li>| 前后2个文件内容有不同</li><li>&lt; 后面文件比前面文件少了1行内容</li><li>&gt; 后面文件比前面文件多了1行内容</li><li>+ 比较的文件的后者比前者多一行</li><li>- 比较的文件的后者比前者少一行</li><li>! 比较的文件两者有差别的行</li></ul><h2 id="案例-35"><a href="#案例-35" class="headerlink" title="案例"></a>案例</h2><p>比较两个文件 <code>diff file1.txt file2.txt</code></p><p>并排格式输出 <code>diff -y -W 50 file1.txt file2.txt</code></p><p>上下文格式输出 <code>diff -c file1.txt file2.txt</code></p><p>统一格式输出 <code>diff -u file1.txt file2.txt</code></p><p>生成补丁 <code>diff file1.txt file2.txt &gt; file.patch</code></p><p>打补丁 <code>patch file1.txt file.patch</code></p><h1 id="join"><a href="#join" class="headerlink" title="join"></a>join</h1><p>连接两个文件</p><h2 id="语法-36"><a href="#语法-36" class="headerlink" title="语法"></a>语法</h2><p>join [OPTION] FILE1 FILE2</p><p>OPTION：</p><ul><li>-a1或-a2：-a1或-a2除了显示共同域的记录之外，-a1显示第一个文件没有共同域的记录，-a2显示第二个文件中没有共同域的记录</li><li>-o：设置结果显示的格式</li><li>-t：改变域的分隔符</li><li>-v1或-v2：-v1或-v2不显示共同域的记录之外，-v1显示第一个文件没有共同域的记录，-v2显示第二个文件中没有共同域的记录</li><li>-j：指定一个域作为匹配字段</li></ul><h2 id="案例-36"><a href="#案例-36" class="headerlink" title="案例"></a>案例</h2><ul><li><p>连接两个文件：</p><ul><li><p>默认以第一列作为连接字段 <code>join file1.txt file2.txt</code></p></li><li><p>显示左边文件中的所有记录(右边文件中没有匹配的不显示) <code>join -a1 file1.txt file2.txt</code></p></li><li><p>显示右边文件中的所有记录(左边文件中没有匹配的不显示) <code>join -a2 file1.txt file2.txt</code></p></li><li><p>全连接(显示左边和右边所有记录) <code>join -a1 -a2 file1.txt file2.txt</code></p></li></ul></li><li><p>指定输出字段(第一个文件第二列、第三列 第二个文件第三列) <code>join -o 1.2 1.3 2.3 file1.txt file2.txt</code></p></li><li><p>指定分隔符（默认情况分隔符是空格） <code>join -t &#39;&#39; file1.txt file2.txt</code></p></li><li><p>只显示第1个文件中没有相同栏位的行 <code>join -v1 file1.txt file2.txt</code></p></li><li><p>指定了以两个文件里第2行做匹配字段 <code>join -j 2 file1.txt file2.txt</code></p></li></ul><h1 id="tr"><a href="#tr" class="headerlink" title="tr"></a>tr</h1><p>转换或删除文件中的字符</p><h2 id="语法-37"><a href="#语法-37" class="headerlink" title="语法"></a>语法</h2><p>tr [OPTION] SET1 [SET2]</p><p>OPTION：</p><ul><li>-c：反选设定字符，也就是符合SET1的部分不做处理，不符合的剩余部分才进行转换</li><li>-d：删除字集合中出现的所有字符</li><li>-s：缩减连续重复的字符成指定的单个字符</li></ul><p>可是使用的字符类：</p><ul><li>字母和数字 [“alnum”]</li><li>字母 [:alpha:]</li><li>控制（非打印）字符 [:cntr:]</li><li>数字 [:digit:]</li><li>图形字符 [:graph:]</li><li>小写字母 [:lower:]</li><li>可打印字符 [:print:]</li><li>标点符号 [:punct:]</li><li>空白字符 [:space:]</li><li>大写字母 [:upper:]</li><li>十六进制字符 [:xdigit:]</li></ul><h2 id="案例-37"><a href="#案例-37" class="headerlink" title="案例"></a>案例</h2><ul><li>大小写转换<ul><li><code>tr &quot;[a-z]&quot; &quot;[A-Z]&quot; &lt; file.txt</code></li><li><code>cat file.txt | tr a-z A-Z</code></li><li><code>echo &quot;hello world&quot;| tr [:lower:] [:upper:]</code></li><li>大小写互换<code>echo &quot;Hello World&quot;| tr &#39;[A-Za-z]&#39;&#39;[a-zA-Z]</code></li></ul></li><li>删除字符<ul><li>删除小写字母 <code>echo &quot;abcABdefCD&quot;| tr -d &quot;[a-z]&quot;</code></li><li>删除数字 <code>echo &quot;abc123def888hello&quot; | tr -d 0-9</code></li><li>删除空格和tab符号 <code>echo &quot; Hello World&quot; | tr -d &quot;[ \t]&quot;</code></li><li>删除不在指定集合中的字符(不加-e会认为\n是普通字符不是转义) <code>echo -e &quot;abc123*&amp;\n def888&quot;| tr -d -c &#39;0-9\n&#39;</code></li></ul></li><li>删除重复字符，只保留一个<ul><li>压缩重复的空白行 <code>echo -e &quot;1\n\n2\n\n3&quot; | tr -s &#39;\n&#39;</code></li><li>删除字符集中的重复字符 <code>echo &quot;Hellooo Linuxxxxxx&quot; | tr -s &quot;[xo]&quot;</code></li><li>将多个连续空格合并为一个空格，并将空格替换为破折号’-‘ <code>echo &quot;2024      10 01&quot; | tr -s &#39; &#39; &#39;-&#39;</code></li></ul></li><li>将制表符转换为空格 <code>echo -e &quot;hello\tworld&quot;| tr &#39;\t&#39; &#39; &#39;</code></li></ul><h1 id="sed"><a href="#sed" class="headerlink" title="sed"></a>sed</h1><p>批量编辑文本文件</p><h2 id="语法-38"><a href="#语法-38" class="headerlink" title="语法"></a>语法</h2><p>sed [选项] [动作] 文件名</p><p>选项：</p><ul><li>-n：仅显示script处理后的结果</li><li>-e：以选项中指定的script来处理输入的文本文件</li><li>-i：此选项会直接修改源文件，要慎用</li></ul><p>动作：</p><ul><li>a：新增</li><li>c：取代</li><li>d：删除</li><li>i：插入</li><li>p：打印</li><li>s：取代</li></ul><h2 id="案例-38"><a href="#案例-38" class="headerlink" title="案例"></a>案例</h2><ul><li>输出文件内容<ul><li>仅输出第2行 <code>sed -n &#39;2p&#39; file.txt</code></li><li>输出3-5行 <code>sed -n &#39;3,5p&#39; file.txt</code></li><li>搜索含有an关键字的行 <code>sed -n &#39;/an/p&#39; file.txt</code></li></ul></li><li>删除文件内容<ul><li>删除第2-4行内容 <code>sed &#39;2,4d&#39; file.txt</code></li><li>删除含有an关键字的行 <code>sed &#39;/an/d&#39; file.txt</code></li></ul></li><li>在第二行后追加nice <code>sed &#39;2a nice&#39; file.txt</code></li><li>在第二行前插入一行数据 <code>sed &#39;2i 123456789&#39; file.txt</code></li><li>整行替换数据<ul><li><code>sed &#39;2c asdfhg&#39; file.txt</code></li><li><code>sed &#39;2,5c data changed&#39; file.txt</code></li></ul></li><li>字符串替换<ul><li>全局替换，把xiaoming改为xiaohong <code>sed &#39;s/xiaoming/xiaohong/g&#39; file.txt</code></li><li>只替换第三行 <code>sed &#39;3s/xiaoming/xiaohong/g&#39; file.txt</code></li><li>多个条件(-e不要漏了) <code>sed -e &#39;s/xiaoming//g;s/xiaohong//g&#39; file.txt</code></li><li>将操作写入文件 <code>sed -i &#39;3s/xiaoming/xiaohong/g&#39; file.txt</code></li></ul></li></ul><h1 id="awk"><a href="#awk" class="headerlink" title="awk"></a>awk</h1><p>文本和数据进行处理的变成语言。（命令是三个创始人姓的缩写）</p><h2 id="语法-39"><a href="#语法-39" class="headerlink" title="语法"></a>语法</h2><p>awk ‘条件1 {动作1} 条件2 {动作2} …’ file.txt</p><p>参数：</p><ul><li>-F：指定输入时用到的字段分隔符</li><li>-v：自定义变量</li><li>-f：从脚本中读取awk命令</li><li>-m：对val值设置内在限制</li></ul><h2 id="案例-39"><a href="#案例-39" class="headerlink" title="案例"></a>案例</h2><p>显示第一和第三列的内容 <code>df -h | awk &#39;&#123;print $1 &quot;\t&quot; $3&#125;&#39;</code></p><p>指定冒号为分隔符，显示第1和第3列的内容 <code>awk -F : &#39;&#123;print $1 &quot;\t&quot; $3&#125;&#39; /etc/passwd</code></p><p>指定冒号为分隔符，显示系统中所有UID号码大于500的用户信息（第三列） <code>awk -F : &#39;$3&gt;=500&#39; /etc/passwd</code></p><p>搜索 &#x2F;etc&#x2F;passwd 有xxx关键字的所有行 <code>awk -F : &#39;/xxx/&#39; /etc/passwd</code></p><p>搜索 &#x2F;etc&#x2F;passwd 有xxx关键字的所有行，并显示对应的shell <code>awk -F : &#39;/xxx/&#123;print $7&#125;&#39; /etc/passwd</code></p><p>BEGIN与END的使用 <code>head /etc/passwd | awk -F : &#39;BEGIN&#123;print &quot;name\tuid&quot;&#125;&#123;print $1 &quot;\t&quot; $3&#125;END&#123;print &quot;from file /etc/passwd&quot;&#125;&#39;</code></p><h1 id="du"><a href="#du" class="headerlink" title="du"></a>du</h1><p>查看磁盘使用空间</p><h2 id="语法-40"><a href="#语法-40" class="headerlink" title="语法"></a>语法</h2><p>du [OPTION]…[FILE]…</p><p>du [OPTION]…–files0-from&#x3D;F</p><p>参数：</p><ul><li>-a：显示目录中所有文件大小</li><li>-h：以易读方式显示文件大小</li></ul><h2 id="案例-40"><a href="#案例-40" class="headerlink" title="案例"></a>案例</h2><p>列出当前目录下所有文件和目录的容量大小 <code>du</code></p><p>以易读方式显示dir文件夹及其子文件夹大小 <code>du -h dir</code></p><p>以易读方式显示dir文件夹内所有文件大小 <code>du -ah dir</code></p><p>显示文件 file.txt 所占用的磁盘空间<code>du file.txt</code></p><p>进现实目录的总大小 <code>du -s dir   du --max-depth=0 dir</code></p><p>显示指定目录下每个文件或目录的容量大小，并且以易读方式显示 <code>du -sh dir</code></p><h1 id="df"><a href="#df" class="headerlink" title="df"></a>df</h1><p>显示磁盘空间使用情况</p><h2 id="语法-41"><a href="#语法-41" class="headerlink" title="语法"></a>语法</h2><p>df [OPTION]…[FILE]…</p><p>参数：</p><ul><li>-a：显示所有文件系统，包含所有的具有0 Blocks的文件系统</li><li>-h：以容易阅读的方式显示</li><li>-i：显示inode信息</li><li>-t：&lt;文件系统类型&gt;只显示指定类型的文件系统</li><li>-T：输出时显示文件系统类型</li></ul><h2 id="案例-41"><a href="#案例-41" class="headerlink" title="案例"></a>案例</h2><p>显示磁盘空间使用情况 <code>df</code></p><p>以易于阅读的方式显示磁盘空间使用情况 <code>df -h</code></p><p>显示指定文件&#x2F;目录所在分区的磁盘使用情况 <code>df /home</code></p><p>显示指定文件类型的磁盘使用情况 <code>df -t squashfs</code></p><p>以inde模式来显示磁盘使用情况 <code>df -i</code></p><p>显示所有信息 <code>df -a</code></p><p>列出文件系统的类型 <code>df -T</code></p><h1 id="mount"><a href="#mount" class="headerlink" title="mount"></a>mount</h1><p>把文件系统挂载到目录</p><h2 id="语法-42"><a href="#语法-42" class="headerlink" title="语法"></a>语法</h2><p>mount [参数] [设备] [挂载点]</p><p>参数：</p><ul><li>-o<ul><li>loop：用来把一个文件当成硬盘分区挂接上系统</li><li>ro：采用只读方式挂接设备</li><li>rw：采用读写方式挂接设备</li><li>iocharset：指定访问文件系统所有字符集</li></ul></li><li>-t：指定挂载类型</li></ul><h2 id="案例-42"><a href="#案例-42" class="headerlink" title="案例"></a>案例</h2><p>查看当前系统中挂载的所有文件系统信息 <code>mount</code></p><p>查看指定类型挂载的文件系统 <code>mount -t tmpfs</code></p><p>将U盘挂载到指定目录，先使用fdisk -l查看系统有哪些磁盘<code>sudo fdisk -l</code> <code> sudo mount /dev/sdb/mnt/udisk</code></p><p>只读模式挂载 <code>sudo mount -o ro /dev/sdb /mnt/udisk</code></p><p>将iso镜像挂载到 &#x2F;mnt&#x2F;iso 目录 <code>sudo mount -o loop /home/xxx/ command/mount/mydisk/iso /mnt/iso</code></p><h1 id="umount"><a href="#umount" class="headerlink" title="umount"></a>umount</h1><p>写在文件系统</p><h2 id="语法-43"><a href="#语法-43" class="headerlink" title="语法"></a>语法</h2><p>umount [参数]</p><ul><li>-v：执行时显示详细的信息</li></ul><h2 id="案例-43"><a href="#案例-43" class="headerlink" title="案例"></a>案例</h2><p>通过设备名卸载 <code>umount -v /dev/sdb</code></p><p>通过挂载点卸载 <code>umount -v /media/xxx</code></p><h1 id="dd"><a href="#dd" class="headerlink" title="dd"></a>dd</h1><p>拷贝及转换文件</p><h2 id="语法-44"><a href="#语法-44" class="headerlink" title="语法"></a>语法</h2><p>dd 参数 对象</p><h2 id="基本格式"><a href="#基本格式" class="headerlink" title="基本格式"></a>基本格式</h2><p>dd if&#x3D;path&#x2F;to&#x2F;input_file of&#x3D;&#x2F;path&#x2F;to&#x2F;output_file bs&#x3D;block_size count&#x3D;number_of_blocks</p><p>参数：</p><ul><li>if&#x3D;文件名：输入文件名，默认为标准输入，即指定源文件</li><li>of&#x3D;文件名：输出文件名，默认为标准输出。即指定目的文件</li><li>ibs&#x3D;bytes：一次读入bytes个字节，即指定一个块大小为bytes个字节</li><li>obs&#x3D;bytes：一次输出bytes个字节，即指定一个块大小为bytes个字节</li><li>bs&#x3D;bytes：同时设置读入&#x2F;输出的快大小为bytes个字节</li><li>cbs&#x3D;bytes：一次转换bytes个字节，即指定转换缓冲区大小</li><li>skip&#x3D;blocks：从输入文件开头跳过blocks个块后再开始复制</li><li>seek&#x3D;blocks：从输出文件开头跳过blocks个块后开始复制</li><li>count&#x3D;blocks：仅拷贝blocks个块，块大小等于 ibs&#x2F;obs 指定的字节数</li><li>conv&#x3D;&lt;关键字&gt;：指定关键字<ul><li>conversion：用指定的参数转换文件</li><li>ascii：转换为ebcdic 为 ascii</li><li>ebcdic：转换ascii为 ebcdic</li><li>ibm：转换ascii 为 alternate ebcdic</li><li>block：把每一行转换为长度 cbs，不足部分用空格填充</li><li>unblock：使每一行的长度都为 cbs，不足部分用空格填充</li><li>lcase：把大写字符转换为小写字符</li><li>ucase：把小写字符转换为大写字符</li><li>swab：交换输入的没对字节</li><li>noerror：出错时不停止</li><li>notrunc：不截断输出文件</li><li>sync：将每个输入块填充到ibs个字节，不足部分用空（NULL）字符补齐</li><li>conversion：用指定的参数转换文件</li></ul></li></ul><h2 id="案例-44"><a href="#案例-44" class="headerlink" title="案例"></a>案例</h2><p>生成一个指定大小（500M）的新文件 <code>dd if=/dev/zero of=file.txt bs=500M count=1</code></p><p>拷贝指定文件的前50个字节 <code>dd if=file.txt of=file2.txt bs=50 count=1</code></p><p>拷贝指定文件的内容，并将所有字符转换成大写后输出到新文件中 <code>dd if=file.txt of=file3.txt conv=ucase</code></p><p>由标准输入设备读入字符串，并将字符串转换成大写后，再输出到标准输出设备 <code>dd conv=ucase (按ctrl+d结束)</code></p><h1 id="tar"><a href="#tar" class="headerlink" title="tar"></a>tar</h1><p>打包&#x2F;解压工具</p><p>参数：</p><ul><li>-c：新建打包文件</li><li>-x：解压文件，配合-C解压到对应的文件目录</li><li>-f：(压缩或解压缩时)指定要处理的文件</li><li>-j：通过bzip2方式压缩或解压，最后以tar.br2为后缀。压缩后大小小于tar.gz</li><li>-z：通过gzip方式压缩或解压，最后以tar.gz为后缀</li><li>-v：显示操作过程</li><li>-t：查看打包文件中内容</li><li>-C dir：指定压缩&#x2F;解压缩的目录，若无指定，默认是当前目录</li></ul><h2 id="案例-45"><a href="#案例-45" class="headerlink" title="案例"></a>案例</h2><p>将当前目录下所有.txt文件打包(未压缩)，丙烯那是操作过程 <code>tar -cvf files.tar *.txt</code></p><p>打包文件之后，使用 gzip 方式压缩 <code>tar -zcvf files.tar.gz *.txt</code></p><p>解压文件到当前目录 <code>tar -zxvf files.tar.gz</code></p><p>解压文件到家目录下 <code>tar -zxvf files.tar.gz -C dir</code></p><p>列出压缩包里的内容 <code>tar -tf file.tar.gz</code></p><h1 id="zip-unzip"><a href="#zip-unzip" class="headerlink" title="zip&#x2F;unzip"></a>zip&#x2F;unzip</h1><p>压缩&#x2F;解压缩文件</p><h2 id="语法-45"><a href="#语法-45" class="headerlink" title="语法"></a>语法</h2><p>zip 参数 文件</p><p>unzip 参数 文件</p><p>参数：</p><p>​zip：</p><pre><code class="hljs">- -v：显示指令执行过程- -d：更新压缩包内文件- -r：递归处理，将指定目录下的所有文件和子目录一并处理</code></pre><p>​unzip</p><pre><code class="hljs">- -l：显示压缩文件内所包含的文件- -v：显示指令执行过程- -d &lt;目录&gt;：指定文件解压缩后所要存储的目录</code></pre><h2 id="案例-46"><a href="#案例-46" class="headerlink" title="案例"></a>案例</h2><p>将指定目录机器内全部文件都打包成zip格式压缩包文件 <code>zip -r dir.zip dir</code></p><p>将当前目录下所有txt文件全部压缩成file.zip <code>zip files.zip *.txt</code></p><p>将newfile.txt添加到files.zip压缩包 <code>zip -dv files.zip newfile.txt</code></p><p>查看压缩文件中包含的文件 <code>unzip -l files.zip</code></p><p>查看显示的文件列表还包含压缩比率 <code>unzip -v files.zip</code></p><p>检查zip文件是否损坏 <code>unzip -t files.zip</code></p><p>解压files.zip到当前目录 <code>unzip files.zip</code></p><p>解压files.zip到指定目录 <code>unzip files.zip -d udir/</code></p><h1 id="gzip-gunzip"><a href="#gzip-gunzip" class="headerlink" title="gzip&#x2F;gunzip"></a>gzip&#x2F;gunzip</h1><p>压缩&#x2F;解压文件</p><h2 id="语法-46"><a href="#语法-46" class="headerlink" title="语法"></a>语法</h2><p>gzip [参数] 文件 </p><p>gunzip [参数] 压缩包</p><p>参数：</p><ul><li>-d：解开压缩文件</li><li>-k：保留源文件</li><li>-l：列出压缩文件的相关信息</li><li>-r：递归处理，将指定目录下的所有文件及子目录一并处理</li><li>-v：显示指令执行过程</li><li>-t：测试压缩文件是否正确无误</li></ul><h2 id="案例-47"><a href="#案例-47" class="headerlink" title="案例"></a>案例</h2><p>压缩指定的文件，原文件将被删除 <code>gzip file.txt</code></p><p>压缩指定的目录 <code>gzip -r dir</code></p><p>显示指定压缩包的压缩信息 <code>gzip -l file.txt.gz</code></p><p>解压指定的压缩包文件 <code>gzip -dv file.txt.gz  gunzip -v file.txt.gz</code></p><p>递归解压目录 <code>gzip -dr dir.gz   gunzip -r dir.gz</code></p><p>压缩指定的文件，源文件不被删除 <code>gzip -k file.txt</code></p><p>测试指定的压缩包文件内容是否损坏，能够正常解压 <code>gunzip -t file.txt.gz</code></p><h1 id="uname"><a href="#uname" class="headerlink" title="uname"></a>uname</h1><p>显示系统信息</p><h2 id="语法-47"><a href="#语法-47" class="headerlink" title="语法"></a>语法</h2><p>uname [OPTION] …</p><p>参数：</p><ul><li>-a：显示系统所有相关信息</li><li>-m：显示计算机硬件架构</li><li>-n：显示主机名称</li><li>-r：显示内核发行版本号</li><li>-s：显示内核名称</li><li>-v：显示内核版本</li><li>-p：显示主机处理器类型</li><li>-o：显示操作系统名称</li><li>-i：显示硬件平台</li></ul><h2 id="案例-48"><a href="#案例-48" class="headerlink" title="案例"></a>案例</h2><p>显示系统主机名、内核版本、硬件架构等信息 <code>uname -a</code></p><p>仅显示主机名 <code>uname -n</code></p><p>仅显示内核发行版本   <code>uname -r</code></p><p>仅显示内核名称 <code>uname -s</code></p><p>仅显示当前系统的硬件平台 <code>uname -i</code></p><p>打印操作系统类型 <code>uname -o</code></p><h1 id="hostname"><a href="#hostname" class="headerlink" title="hostname"></a>hostname</h1><p>显示和设置系统的主机名</p><h2 id="语法-48"><a href="#语法-48" class="headerlink" title="语法"></a>语法</h2><p>hostname [参数]</p><p>参数：</p><ul><li>-a：显示主机别名</li><li>-d：显示DNS域名</li><li>-f：显示FQDN名称</li><li>-i：显示主机的ip地址</li><li>-s：显示单主机名称，在第一个点处截断</li><li>-y：显示NIS域名</li></ul><h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><p>环境变量HOSTNAME也保存了当前的主机名 <code>echo $HOSTANME</code></p><p>使用hostname可临时设置主机名</p><p>永久修改主机名：</p><ol><li>修改配置文件 &#x2F;etc&#x2F;hostname   &#x2F;etc&#x2F;hosts</li><li>hostnamectl命令 <code>sudo hostnamectl set-hostname &lt;newhostname&gt;</code> 一定要修改 &#x2F;etc&#x2F;hosts</li></ol><h2 id="案例-49"><a href="#案例-49" class="headerlink" title="案例"></a>案例</h2><p>显示主机名 <code>hostname</code></p><p>临时改变主机名 <code>hostname newname</code></p><p>显示主机的所有IP地址 <code>hostname -l</code></p><h1 id="dmesg"><a href="#dmesg" class="headerlink" title="dmesg"></a>dmesg</h1><p>显示开机信息</p><h2 id="语法-49"><a href="#语法-49" class="headerlink" title="语法"></a>语法</h2><p>dmesg [参数]</p><p>参数：</p><ul><li>-c：显示信息后，清除ring buffer中的内容</li><li>-s &lt;缓冲区大小&gt;：预设为8196，刚好等于ring buffer的大小</li><li>-n：设置记录信息的层级</li></ul><h2 id="案例-50"><a href="#案例-50" class="headerlink" title="案例"></a>案例</h2><p>显示开机信息 <code>dmesg   dmesg | less</code></p><p>显示和内存、硬盘、USB、TTY相关的信息 </p><pre><code class="hljs">- `dmesg | grep -i memory`- `dmesg | grep -i dma`- `dmesg | grep -i usb`- `dmesg | grep -i tty`</code></pre><p>显示信息级别 <code>dmesg -x</code> emerg\alert\crit\err\warn\notice\info\debug，只查看错误信息 <code>dmesg --level=err</code></p><p>只输出特定级别的信息<code>dmesg --level=err,warn</code></p><p>显示时间戳 <code>dmesg -T</code></p><p>显示原始数据 <code>dmesg -r</code></p><p>清空dmesg环形缓冲区的日志 <code>sudo dmesg -c</code></p><h1 id="uptime"><a href="#uptime" class="headerlink" title="uptime"></a>uptime</h1><p>查看系统启动时间及负载信息</p><h2 id="语法-50"><a href="#语法-50" class="headerlink" title="语法"></a>语法</h2><p>uptime [OPTION]</p><p>OPTION：</p><ul><li>-p：显示机器正常运行的时间</li><li>-s：系统启动时间，格式为 uuuu-mm-dd hh:mm:ss</li></ul><h2 id="案例-51"><a href="#案例-51" class="headerlink" title="案例"></a>案例</h2><p>显示当前系统运行负载信息 <code>uptime</code></p><p>显示系统正常运行时间 <code>uptime -p</code></p><p>显示系统启动时间 <code>uptiome -s</code></p><h1 id="free"><a href="#free" class="headerlink" title="free"></a>free</h1><p>显示系统内存使用量情况</p><h2 id="语法-51"><a href="#语法-51" class="headerlink" title="语法"></a>语法</h2><p>free [参数]</p><p>参数：</p><ul><li>-b：以Byte显示内存使用情况</li><li>-k：以kb为单位显示内存使用情况</li><li>-m：以mb为单位显示内存使用情况</li><li>-g：以gb为单位显示内存使用情况</li><li>-s：持续显示内存</li><li>-t：显示内存使用总合</li><li>-h：以易读的单位显示内存使用情况</li></ul><p>输出内容介绍</p><ul><li>Mem 行（第二行）是内存的使用情况</li><li>Swap行（第三行）是交换空间的使用情况</li><li>total列：显示系统总的物理内存和交换空间大小</li><li>used列：显示已经被使用的物理内存和交换空间大小</li><li>free列：显示还有多少物理内存和交换空间可以使用</li><li>shared列：显示被共享使用的物理内存大小</li><li>buff&#x2F;cache列：显示被buffer和cache使用的物理内存大小</li><li>available列：显示还可以被应用程序使用的物理内存大小</li></ul><h2 id="案例-52"><a href="#案例-52" class="headerlink" title="案例"></a>案例</h2><p>以默认的容量单位显示内存使用量信息 <code>free</code></p><p>以MB为单位显示内存使用量信息 <code>free -m</code></p><p>以易读的单位显示内存使用量信息 <code>free -h</code></p><p>以易读的单位显示内存使用量信息，每个3秒刷新一次 <code>free -hs 3</code></p><h1 id="ulimit"><a href="#ulimit" class="headerlink" title="ulimit"></a>ulimit</h1><p>是shell的内嵌命令，控制shell程序的资源，通过对资源的控制，达到系统调优的的用作</p><h2 id="语法-52"><a href="#语法-52" class="headerlink" title="语法"></a>语法</h2><p>ulimit [参数]</p><p>参数：</p><ul><li>-a：显示目前资源限制的设定</li><li>-c&lt;core文件上限&gt;：设定core文件的最大值，单位为区块</li><li>-d&lt;数据节区大小&gt;：程序数据节区的最大值，单位为KB</li><li>-f&lt;文件大小&gt;：shell所能建立的最大文件，单位为区块</li><li>-H：设定资源的硬性限制，也就是管理员所设下的限制</li><li>-m&lt;内存大小&gt;：指定可使用的内存的上线，单位为KB</li><li>-n&lt;文件数目&gt;：指定同一时间最多可开启的文件数</li><li>-p&lt;缓冲区大小&gt;：指定管道缓冲区的大小，单位512字节</li><li>-s&lt;堆叠大小&gt;：制定堆叠的上线，单位为KB</li><li>-S：设定资源的弹性限制</li><li>-t&lt;CPU时间&gt;：指定CPU使用时间的上线，单位为秒</li><li>-u&lt;程序数目&gt;：用户最多可开启的程序数目</li><li>-v&lt;虚拟内存大小&gt;：指定可使用的虚拟内存上线，单位为KB</li></ul><h2 id="案例-53"><a href="#案例-53" class="headerlink" title="案例"></a>案例</h2><p>显示系统资源的设置 <code>ulimit -a</code></p><p>设置单一用户程序数目上线 <code>ulimit -u 500</code></p><p>将每个进程可以打开的文件数目加大到4096 <code>ulimit -n 4096</code></p><p>指定可使用的虚拟内存上线为12800KB <code>ulimit -v 12800</code></p><p>指定CPU使用时间的上限位2s <code>ulimit -t 2</code></p><h1 id="init"><a href="#init" class="headerlink" title="init"></a>init</h1><p>切换系统运行级别</p><h2 id="案例-54"><a href="#案例-54" class="headerlink" title="案例"></a>案例</h2><p>关机 <code>init 0</code></p><p>单用户模式 <code>init 1</code></p><p>多用户，没有NFS不联网 <code>init 2</code></p><p>切换到多用户-命令行模式 <code>init 3</code></p><p>没有用到 <code>init 4</code></p><p>图形化界面模式 <code>init 5</code></p><p>重新启动 <code>init 6</code></p><h1 id="service"><a href="#service" class="headerlink" title="service"></a>service</h1><p>控制系统服务</p><h2 id="语法-53"><a href="#语法-53" class="headerlink" title="语法"></a>语法</h2><p>service [参数]</p><p>参数：</p><ul><li>–status-all ：显示所有服务的状态</li><li>start：启动服务</li><li>stop：停止服务</li><li>restart：重新启动服务</li><li>status：查看服务运行状态</li><li>reload：重新载入服务配置</li></ul><h2 id="案例-55"><a href="#案例-55" class="headerlink" title="案例"></a>案例</h2><p>查看系统中所有服务现在的运行状态 <code>service --status-all</code></p><p>查看sshd运行状态<code>service sshd status</code></p><p>启动sshd服务 <code>service sshd start</code></p><p>停止sshd服务 <code>service sshd stop</code></p><p>重启sshd服务 <code>service sshd restart</code></p><h1 id="vmstat"><a href="#vmstat" class="headerlink" title="vmstat"></a>vmstat</h1><p>显示虚拟内存状态</p><h2 id="语法-54"><a href="#语法-54" class="headerlink" title="语法"></a>语法</h2><p>vmstat [选项] [时间间隔] [次数]</p><p>参数：</p><ul><li>-a：显示活跃和非活跃内存</li><li>-f：显示从系统启动至今的fork数量</li><li>-m：显示slab信息</li><li>-n：只在开始时显示一次各字段名称</li><li>-s：显示内存相关统计信息及多种系统活动数量</li><li>delay：刷新时间间隔。如果不指定，只显示一条结果</li><li>count：刷新次数。如果不指定刷新次数，但指定了刷新时间间隔，这时刷新次数为无穷</li><li>-d：显示磁盘相关统计信息</li><li>-p：显示指定磁盘分区统计信息</li><li>-S：使用指定单位显示。参数有k、K、m、M，分别代表1000、1024、1000000、1048576字节(byte)。默认单位为K(1024bytes)</li></ul><h2 id="案例-56"><a href="#案例-56" class="headerlink" title="案例"></a>案例</h2><p>显示虚拟内存的使用情况<code>vmstat</code></p><p>指定状态信息刷新的时间间隔为1秒 <code>vmstat 1</code></p><p>显示活跃和非活跃内存统计信息 <code>vmstat -a</code></p><p>显示从系统启动以来的fork数量 <code>vmstat -f</code></p><p>显示内存使用的详细信息 <code>vmstat -s</code></p><p>显示磁盘相关统计信息(磁盘的读&#x2F;写情况) <code>vmstat -d</code></p><p>查看&#x2F;dev&#x2F;sda1磁盘分区的读&#x2F;写情况 <code>vmstat -p /dev/sba1</code></p><p>显示系统的slabinfo <code>sudo vmstat -m</code></p><h1 id="iostat"><a href="#iostat" class="headerlink" title="iostat"></a>iostat</h1><p>监视系统输入输出设备和CPU的使用情况</p><h2 id="语法-55"><a href="#语法-55" class="headerlink" title="语法"></a>语法</h2><p>iostat [参数] [设备]</p><p>参数：</p><ul><li>-c：仅显示CPU使用情况</li><li>-d：仅显示设备利用率</li><li>-k：显示状态以千字节每秒为单位，而不使用块每秒</li><li>-m：显示状态以兆字节每秒为单位</li><li>-p：仅显示块设备和所有被使用的其他分区的状态</li><li>-t：显示每个报告产生时的时间</li><li>-x：显示扩展状态</li></ul><h2 id="案例-57"><a href="#案例-57" class="headerlink" title="案例"></a>案例</h2><p>显示所有设备负载情况 <code>iostat</code></p><p>每隔2秒显示一次，总共显示3次 <code>iostat 2 3</code></p><p>显示指定磁盘信息<code>iostat -d sda1</code></p><p>显示tty和cpu信息 <code>iostat -t</code></p><p>以M为单位显示所有信息 <code>iostat -m</code></p><p>查看TPS和吞吐量信息 <code>iostat -d -k 11</code></p><p>查看磁盘I&#x2F;O的详细情况 <code>iostat -x /dev/sda1</code></p><p>查看设备使用率(%utiol)、响应时间(await) <code>iostat -d -x -k 11</code></p><p>查看cpu状态 <code>iostat -c 1 3</code></p><h1 id="ipcs"><a href="#ipcs" class="headerlink" title="ipcs"></a>ipcs</h1><p>显示进程间通讯设备的信息</p><h2 id="语法-56"><a href="#语法-56" class="headerlink" title="语法"></a>语法</h2><p>ipcs [参数]</p><p>参数：</p><ul><li>-a：默认的输出信息</li><li>-m：打印出使用共享内存进行进程间通信的信息</li><li>-q：打印出使用消息队列进行进程间通信的信息</li><li>-s：打印出使用信号进行进程间通信的信息</li></ul><h2 id="案例-58"><a href="#案例-58" class="headerlink" title="案例"></a>案例</h2><p>显示所有的IPC <code>ipcs  ipcs -a</code></p><p>输出信息的详细变化时间 <code>ipcs -t</code></p><p>输出ipc方式的进程ID <code>ipcs -p</code></p><p>输出ipc方式的创建者&#x2F;拥有者 <code>ipcs -c</code></p><p>输出当前系统下ipc各种方式的状态信息 <code>ipcs -u</code></p><p>查看各个资源的系统限制信息 <code>ipcs -l</code></p><h1 id="ipcrm"><a href="#ipcrm" class="headerlink" title="ipcrm"></a>ipcrm</h1><p>删除一个或更多的消息队列、信号量集或者共享内存标识</p><h2 id="语法-57"><a href="#语法-57" class="headerlink" title="语法"></a>语法</h2><p>ipcrm [options]</p><p>ipcrm &lt;shm | msg | sem&gt; &lt;id&gt; […]</p><p>参数：</p><ul><li>-m，–shmem-id &lt;id&gt;：按id号移除共享内存段</li><li>-M，–shmem-id &lt;id&gt;：按键值移除共享内存段</li><li>-q，–queue-id &lt;id&gt;：按id号移除消息队列</li><li>-Q，–queue-key &lt;键&gt;：按键值移除消息队列</li><li>-s，–semaphore-id &lt;id&gt;：按id号移除信号量</li><li>-S，–semaphore-key &lt;键&gt;：按键值移除信号量</li><li>-a，–all[&#x3D;&lt;shm | msg | sem&gt;] 全部移除</li><li>-v，–verbose：解释正式进行的操作</li></ul><h2 id="案例-59"><a href="#案例-59" class="headerlink" title="案例"></a>案例</h2><p>通过id删除共享内存 <code>ipcrm -m 262133</code></p><p>通过key删除共享内存 <code>ipcrm -M 0x55</code></p><p>通过id删除消息队列 <code>iprm -q 252432</code></p><p>通过key删除消息队列 <code>iprm -Q 0x88</code></p><p>通过id删除信号量 <code>iprm -S 0x65</code></p><p>删除所有共享内存、信号量和消息队列<code>iprm -a</code></p><p>删除所有共享内存、信号量和消息队列，并且显示过程 <code>iprm -v -a</code></p><h1 id="route"><a href="#route" class="headerlink" title="route"></a>route</h1><p>显示并设置路由</p><h2 id="语法-58"><a href="#语法-58" class="headerlink" title="语法"></a>语法</h2><p>route [-f] [-p] [Command [Destination] [mask Netmask] [Gateway] [metric Metric]] [if Interface]</p><h2 id="参数-1"><a href="#参数-1" class="headerlink" title="参数"></a>参数</h2><ul><li>-n：不要使用通讯协定或主机名称，直接使用IP 或 port number</li><li>-net：标识后边接的路由为一个网域</li><li>-host：标识后面接的为连接到单部主机的路由</li><li>netmask：与网域有关，可以设定 netmask 决定网域的大小</li><li>gw：gateway的简写，后续接的是IP的数值，与dev不同</li><li>dev：如果只是要指定由那一块网路卡连线出去，则使用这个设定，后面接 eth0 等</li></ul><p>flag：</p><pre><code class="hljs">- U：up表示此路由当前为启动状态- H：Host，表示此网关为一主机- G：Gateway，表示此网关为一路由器- R：Reinstate Route，使用动态路由重新初始化的路由- D：Dynamically，此路由是动态性写入- M：Modified，此路由是由路由守护程序或导向器动态修改- !：表示此路由当前为关闭状态</code></pre><h2 id="案例-60"><a href="#案例-60" class="headerlink" title="案例"></a>案例</h2><p>显示当前路由 <code>route  route -n</code></p><p>添加网关&#x2F;设置网关 <code>route add -net 224.0.0.0 netmask 240.0.0.0 dev ens33</code></p><p>屏蔽一条路由 <code>route add -net 224.-.-.- netmask 240.0.0.0 reject</code></p><p>删除路由记录 <code>route del -net 224.0.0.0 netmask 240.0.0.0</code>  <code>route del -net 224.0.0. netmask 240.0.0.0 reject</code></p><h1 id="ping"><a href="#ping" class="headerlink" title="ping"></a>ping</h1><p>测试主机间网络连通性</p><h2 id="语法-59"><a href="#语法-59" class="headerlink" title="语法"></a>语法</h2><p>ping [参数] 目标主机</p><p>参数：</p><ul><li>-c：指定发送报文的次数</li><li>-i：指定收发信息的间隔时间</li><li>-s：设置数据包的大小</li><li>-t：设置存活数值TTL的大小 <ul><li>Linux系统的TTL的值为64或255</li><li>Windows NT&#x2F;2000&#x2F;XP系统的TTL值为128</li><li>Windows 98系统的TTL值为32</li><li>Unix主机的TTL值为255</li></ul></li></ul><h2 id="案例-61"><a href="#案例-61" class="headerlink" title="案例"></a>案例</h2><p>测试与 <a href="http://www.baidu.com/">www.baidu.com</a> 网站的连通性 <code>ping www.baidu.com</code></p><p>连续ping 4次 <code>ping -c 4 www.baidu.com</code></p><p>连续ping 4次，间隔3秒 <code>ping -c 4 -i 3 www.baidu.com</code></p><p>测试局域网连通性 <code>ping 192.168.107.128</code></p><p>设置数据包为1024字节，TTL为255 <code>ping -s 1024 -t 255 www.baidu.com</code></p><h1 id="traceroute"><a href="#traceroute" class="headerlink" title="traceroute"></a>traceroute</h1><p>追踪数据包在网络上的传输时的全部路径</p><h2 id="语法-60"><a href="#语法-60" class="headerlink" title="语法"></a>语法</h2><p>traceroute [参数] [域名或者IP]</p><p>参数：</p><ul><li>-m &lt;存活数值&gt;：设置检测数据包的最大存活数值TTL的大小</li><li>-n：直接使用IP地址而非主机名换</li><li>-p&lt;通信端口&gt;：设置UDP传输协议的通信端口</li><li>-q：探测包个数设置</li><li>-r：忽略普通的Routing Table，直接将数据包送到远端主机上</li><li>-w：设置等待远端主机回报的时间</li></ul><h2 id="案例-62"><a href="#案例-62" class="headerlink" title="案例"></a>案例</h2><p>追踪本地数据包到百度的传输路径 <code>traceroute www.baidu.com</code></p><p>跳数设置 <code>traceroute -m 7 www.baidu.com</code></p><p>显示IP地址，不查主机名 <code>traceroute -n www.baidu.com</code></p><p>把探测包的个数设置为4 <code>traceroute -q 4 www.baidu.com</code></p><p>把对外发探测包的等待响应时间设置为3秒 <code>traceroute -w 3 www.baidu.com</code></p><p>探测包使用的基本UDP端口设置为6888 <code>traceroute -p 6888 www.baidu.com</code></p><p>绕过正常的路由表，直接发送到网络相连的主机  <code>traceroute -r www.baidu.com</code></p><h1 id="netstat"><a href="#netstat" class="headerlink" title="netstat"></a>netstat</h1><p>显示网络状态</p><h2 id="语法-61"><a href="#语法-61" class="headerlink" title="语法"></a>语法</h2><p>netstat [参数]</p><p>参数：</p><ul><li>-a：显示所有连线中的socket</li><li>-p：显示正在使用套接字的程序识别码和程序名称</li><li>-l：仅列出在监听的服务状态</li><li>-t：显示TCP传输协议的连线状况</li><li>-u：显示UDP传输协议的连线状态</li><li>-i：显示网络界面信息表单</li><li>-r：显示路由表信息</li><li>-n：直接使用IP地址，不通过域名服务器</li></ul><h2 id="案例-63"><a href="#案例-63" class="headerlink" title="案例"></a>案例</h2><p>显示系统网络状态中的所有连接信息 <code>netstat -a</code></p><p>显示系统网络状态中的TCP连接信息 <code>netstat -at</code></p><p>显示系统网络状态中的UDP连接信息 <code>netstat -au</code></p><p>输出中显示PID和进程名称 <code>netstat -p</code></p><p>只显示监听端口 <code>netstat -l</code></p><p>只列出所有监听TCP端口 <code>netstat -lt</code></p><p>只列出所有监听UDP端口 <code>netstat -lu</code></p><p>列出所有监听 UNIX 端口 <code>netstat -lx</code></p><p>显示所有端口的统计信息 <code>netstat -s</code></p><p>显示TCP或UDP端口的统计信息 <code>netstat -st  netstat -su</code></p><p>显示系统网络状态中的UDP连接端口号使用信息 <code>netstat -apu</code></p><p>显示网卡当前状态信息 <code>netstat -i</code></p><p>显示网络路由表状态信息 <code>netstat -r</code></p><p>找到某个服务所对应的连接信息 <code>netstat -ap | grep ssh</code></p><h2 id="ss"><a href="#ss" class="headerlink" title="ss"></a>ss</h2><p>显示活动套接字信息</p><h2 id="语法-62"><a href="#语法-62" class="headerlink" title="语法"></a>语法</h2><p>ss [参数]</p><h2 id="案例-64"><a href="#案例-64" class="headerlink" title="案例"></a>案例</h2><p>显示TCP套接字 <code>ss -at</code></p><p>显示UDP套接字 <code>ss -au</code></p><p>显示套接字使用概况 <code>ss -s</code></p><p>列出所有打开的网络连接端口 <code>ss -l</code></p><p>查看进程使用的socket <code>ss -pl</code></p><p>找出打开套接字&#x2F;端口应用程序 <code>ss -lp | grep 6010</code></p><p>查看主机监听的端口 <code>ss -tnl</code></p><p>解析IP和端口号 <code>ss -tlr</code></p><h1 id="telnet"><a href="#telnet" class="headerlink" title="telnet"></a>telnet</h1><p>远程登入服务器</p><h2 id="语法-63"><a href="#语法-63" class="headerlink" title="语法"></a>语法</h2><p>telnet [参数] [主机] [端口]</p><h2 id="案例-65"><a href="#案例-65" class="headerlink" title="案例"></a>案例</h2><p>登录远程主机 <code>telnet 192.168.107.133</code></p><p>指定端口 <code>telnet 192.168.107.133 6379</code></p><h1 id="ssh"><a href="#ssh" class="headerlink" title="ssh"></a>ssh</h1><p>远程连接工具</p><h2 id="语法-64"><a href="#语法-64" class="headerlink" title="语法"></a>语法</h2><p>ssh [参数] [主机]</p><p>参数：</p><ul><li>-l &lt;登录名&gt;：指定连接远程服务器的登录用户名</li><li>-p &lt;端口&gt;：指定远程服务器上的端口</li></ul><p>配置文件 <code>/etc/ssh/sshd_config</code></p><h2 id="案例-66"><a href="#案例-66" class="headerlink" title="案例"></a>案例</h2><p>登录远程服务器 <code>ssh 192.168.0.10</code></p><p>以xx身份远程等于服务器 <code>ssh -l xxx 192.168.0.10   ssh xxx@192.168.0.10</code></p><p>指定端口及用户名登录服务器 <code>ssh -p 2222 xxx@192.168.0.10</code></p><p>远程执行命令 <code>ssh 192.168.0.10 date</code></p><h1 id="ftp"><a href="#ftp" class="headerlink" title="ftp"></a>ftp</h1><p>文件传输协议客户端</p><h2 id="语法-65"><a href="#语法-65" class="headerlink" title="语法"></a>语法</h2><p>ftp [参数] [主机名或IP]</p><h2 id="常用ftp命令"><a href="#常用ftp命令" class="headerlink" title="常用ftp命令"></a>常用ftp命令</h2><ul><li>‌<strong>open</strong>‌：与FTP服务器相连接。</li><li>‌**send (put)**‌：上传文件。</li><li>‌<strong>get</strong>‌：下载文件。</li><li>‌<strong>mget</strong>‌：下载多个文件。</li><li>‌<strong>cd</strong>‌：切换目录。</li><li>‌<strong>mkdir</strong>‌：在服务器上创建目录。</li><li>‌<strong>rmdir</strong>‌：删除远程目录。</li><li>‌<strong>delete</strong>‌：删除文件。</li><li>‌<strong>quit</strong>‌：结束与服务器的FTP会话并退出。</li><li>‌<strong>help</strong>‌：显示帮助信息。</li><li>‌<strong>pwd</strong>‌：显示当前目录的路径。</li><li>‌<strong>lpwd</strong>‌：列出本地当前目录。</li><li>‌<strong>status</strong>‌：请求服务器返回当前目录的状态信息‌。</li></ul><h2 id="增加ftp写权限"><a href="#增加ftp写权限" class="headerlink" title="增加ftp写权限"></a>增加ftp写权限</h2><p>第一步： <code>sudo gedit /etc/vsftpd.conf</code></p><p>第二步：<code>去除#write_enable=YES前的#</code></p><p>第三步：<code>sudo service vsftpd restart</code></p><h2 id="案例-67"><a href="#案例-67" class="headerlink" title="案例"></a>案例</h2><p>安装ftp <code>sudo apt install vsftpd</code></p><p>建立FTP连接 <code>ftp 192.168.107.133</code></p><p>下载一个文件 <code>get file.txt</code></p><p>下载多个文件 <code>mget file1.txt file2.txt</code></p><p>上传一个文件 <code>put newfile.txt</code></p><p>上传多个文件 <code>mput newfile1.txt newfile2.txt</code></p><h1 id="sftp"><a href="#sftp" class="headerlink" title="sftp"></a>sftp</h1><p>交互式的文件传输程序</p><h2 id="语法-66"><a href="#语法-66" class="headerlink" title="语法"></a>语法</h2><p>sftp [参数] [IP或主机名]</p><h2 id="案例-68"><a href="#案例-68" class="headerlink" title="案例"></a>案例</h2><p>使用SFTP进行客户端连接 <code>stfp xxx@192.168.107.120</code></p><p>指定端口连接 <code>sftp -P 30 xxx@192.168.107.120</code></p><p>查看sftp支持的命令 <code>help   ?</code></p><p>从远程服务器下载文件到本地 <code>get file.txt</code></p><p>从远程服务器下载目录到本地 <code>get -r dir</code></p><p>从本地上传文件到远程服务器 <code>put newfile.txt</code></p><p>从本地上传目录到远程服务器 <code>put -r newdir</code></p><p>执行本地Shell命令(在命令前加叹号) <code>!command   !echo hello world</code></p><p>退出 <code>bye  exit</code></p><h1 id="lftp"><a href="#lftp" class="headerlink" title="lftp"></a>lftp</h1><p>文件客户端程序</p><h2 id="语法-67"><a href="#语法-67" class="headerlink" title="语法"></a>语法</h2><p>lftp [参数]</p><h2 id="案例-69"><a href="#案例-69" class="headerlink" title="案例"></a>案例</h2><p>登录远程服务器 <code>lftp xxx@192.168.107.133</code></p><p>查看lftp支持的命令 <code>help   ?</code></p><p>从远程服务器下载文件到本地 <code>get file.txt   mget file*.txt   mget -c *.txt</code></p><p>从远程服务器下载目录到本地 <code>mirror dir</code></p><p>从本地上传文件到远程服务器 <code>put newfile.txt   mput newfile*.txt</code></p><p>从本地上传目录到远程服务器 <code>mirror -R newdir</code></p><p>退出 <code>bye   exit</code></p><h1 id="wget"><a href="#wget" class="headerlink" title="wget"></a>wget</h1><p>文件下载</p><h2 id="语法-68"><a href="#语法-68" class="headerlink" title="语法"></a>语法</h2><p>wget [OPTION] [URL]</p><p>OPTION：</p><ul><li>-i：下载指定文件里列出的地址</li><li>-O：下载后重命名文件</li><li>-c：打开断点续传</li><li>-b：启动后转入后台执行</li><li>-P：指定保存路径</li></ul><h2 id="案例-70"><a href="#案例-70" class="headerlink" title="案例"></a>案例</h2><p>使用wget下载单个文件 <code>wget xxxurl</code></p><p>使用wget下载多个文件 <code>vim rullist.txt   wget -i urllist.txt</code></p><p>下载后以不同的文件名保存 <code>wget -O xx.zip xxx.com/x.zip</code></p><p>下载后保存到指定目录 <code>wget -P dir xxxurl</code></p><p>wget限速下载 <code>wget --limit-rate=300k xxxurl</code></p><p>打开断点续传功能 <code>wget -c xxxurl</code></p><p>使用wget后台下载 <code>wget -b xxxurl</code> 查看下载进度 <code>tail -f wget-log</code></p><h1 id="scp"><a href="#scp" class="headerlink" title="scp"></a>scp</h1><p>远程拷贝文件</p><h2 id="语法-69"><a href="#语法-69" class="headerlink" title="语法"></a>语法</h2><p>scp [-346BCpqrTV] [-c cipher] [-F ssh_config] [-i identity_file] [-J destination] [-l limit] [-o ssh_option] [-P port] [-S program] source … target</p><p>参数：</p><ul><li>-r：递归复制整个目录</li><li>-p：保留原文件的修改时间，访问时间和模式</li><li>-P：指定数据传输用到的端口号</li></ul><h2 id="案例-71"><a href="#案例-71" class="headerlink" title="案例"></a>案例</h2><p>从远程复制文件到本地 <code>scp xxx@192.168.107.128:/home/xxx/file.txt ~</code></p><p>从远程复制目录到本地 <code>scp -r xxx@192.168.107.128:/home/xxx/dir/ ~</code></p><p>上传本地文件到远程机器指定目录 <code>scp ~/newfile.txt xxx@192.168.107.128:/home/xxx/</code></p><p>上传本地目录到远程机器指定目录 <code>scp -r ~/newdir xxx@192.168.107.128:/home/xxx/</code></p><p>使用指定的端口号传输数据 <code>scp -P 2222 xxx@192.168.107.128:/home/xxx/file.txt ~</code></p><p>保留文件的最后修改时间及访问时间 <code>scp -p xxx@192.168.107.128:/home/xxx/file.txt ~</code></p><h1 id="curl"><a href="#curl" class="headerlink" title="curl"></a>curl</h1><p>文件传输工具</p><h2 id="语法-70"><a href="#语法-70" class="headerlink" title="语法"></a>语法</h2><p>curl [参数] 网址</p><p>参数：</p><ul><li>-o：指定新的本地文件名</li><li>-O：保留远程文件的原始名</li><li>-u：通过服务端配置的用户名和密码授权访问</li><li>-l：打印HTTP响应头信息</li><li>-u：指定登录账户密码信息</li><li>-A：设置用户代理标头信息</li><li>-b：设置用户cookie信息</li><li>-C：支持断点续传</li><li>-s：静默模式，不输出任何信息</li><li>-T：上传文件</li></ul><h2 id="案例-72"><a href="#案例-72" class="headerlink" title="案例"></a>案例</h2><p>获取指定网站的网页源码 <code>curl www.baidu.com</code></p><p>保存网页 <code>curl -o baidu.html www.baidu.com</code></p><p>下载指定网站中的文件 <code>curl -O xxx.com/xx.zip</code></p><p>下载文件并重命名 <code>curl -o newname.zip xxx.com/xx.zip</code></p><p>断点续传 <code>curl -C --O xxx.com/xx.zip</code></p><p>打印指定网站的HTTP响应头信息 <code>curl -l xxx.com/xx.zip</code></p><p>通过ftp下载指定文件服务器中的文件 <code>curl -u xxx:pwsswd ftp://baidu.com/file.txt</code></p><p>上传文件 <code>curl -T newfile.txt -u 用户名:密码 ftp://www.baidu.com/dir/</code></p><h1 id="host"><a href="#host" class="headerlink" title="host"></a>host</h1><p>域名查询</p><h2 id="语法-71"><a href="#语法-71" class="headerlink" title="语法"></a>语法</h2><p>host [参数] [域名]</p><p>参数：</p><ul><li>-a：显示详细的DNS信息</li><li>-v：显示指令执行的详细信息</li></ul><h2 id="案例-73"><a href="#案例-73" class="headerlink" title="案例"></a>案例</h2><p>查询域名对应的ip地址 <code>host www.baidu.com</code></p><p>显示执行域名查询的详细信息 <code>host -v www.baidu.com</code></p><p>显示详细的DNS信息 <code>host -a www.baidu.com</code></p><h1 id="tcpdump"><a href="#tcpdump" class="headerlink" title="tcpdump"></a>tcpdump</h1><p>监听网络流量，需要管理员权限</p><h2 id="案例-74"><a href="#案例-74" class="headerlink" title="案例"></a>案例</h2><p>监视第一个网络接口上所有流过的数据包 <code>tcpdump</code></p><p>监视指定网络接口的数据包 <code>tcpdump -i ens33</code></p><p>显示指定数据包 <code>tcp -c 20</code></p><p>精简模式显示10个包 <code>tcpdump -c 10 -q</code></p><p>监视指定主机的数据包（主机名）<code>tcpdump host www.baidu.com</code></p><p>监听指定主机的数据包（ip地址）<code>tcpdump -i any port 22 -A</code></p><h1 id="useradd"><a href="#useradd" class="headerlink" title="useradd"></a>useradd</h1><p>创建并设置用户信息</p><h2 id="语法-72"><a href="#语法-72" class="headerlink" title="语法"></a>语法</h2><p>useradd [参数] 用户名</p><p>参数：</p><ul><li>-d&lt;登入目录&gt;：指定用户登入时的目录</li><li>-g&lt;群组&gt;：初始群组</li><li>-G&lt;群组&gt;：非初始群组</li><li>-m：自动创建用户的家目录</li><li>-M：不要创建用户的家目录</li><li>-N：不要创建以用户名称为名的群组</li><li>-s：指定用户登入后所使用的shell</li></ul><h2 id="四个重要配置文件"><a href="#四个重要配置文件" class="headerlink" title="四个重要配置文件"></a>四个重要配置文件</h2><ul><li>&#x2F;etc&#x2F;passwd</li><li>&#x2F;etc&#x2F;shadow</li><li>&#x2F;etc&#x2F;group</li><li>&#x2F;ect&#x2F;gshadow</li></ul><h2 id="案例-75"><a href="#案例-75" class="headerlink" title="案例"></a>案例</h2><p>直接创建新用户 <code>useradd user1</code></p><p>床用创建方法 <code>useradd -m -s /bin/bash user2</code></p><p>自动创建家目录 <code>useradd -m username</code></p><p>指定家目录 <code>useradd -m -d /new/dir username</code></p><p>指定用户ID <code>useradd -u 1500 username</code></p><p>指定组ID <code>useradd -g group username</code></p><p>分配多个组 <code>useradd -g group -G group1,group2 username</code></p><p>指定登录shell <code>useradd -s /bin/bash username</code></p><p>自定义注释 <code>useradd -c &quot;Test User Account&quot; username</code></p><h1 id="passwd"><a href="#passwd" class="headerlink" title="passwd"></a>passwd</h1><p>修改用户的密码</p><h2 id="语法-73"><a href="#语法-73" class="headerlink" title="语法"></a>语法</h2><p>passwd [参数] 用户名</p><p>参数：</p><ul><li>-d：删除已有密码</li><li>-l：锁定用户的密码值，不允许修改</li><li>-U：解锁用户的密码值，允许修改</li><li>-e：下次登录强制修改密码</li><li>-k：用户在期满后仍能使用</li><li>-S：查询密码状态</li></ul><h2 id="案例-76"><a href="#案例-76" class="headerlink" title="案例"></a>案例</h2><p>修改当前登录用户密码 <code>passwd</code></p><p>修改指定用户的密码值 <code>passwd xxx</code></p><p>锁定指定用户的密码值，不允许其进行修改 <code>passwd -l xxx</code></p><p>解锁指定用户的密码值，允许其进行修改 <code>passwd -u xxx</code></p><p>强制指定的用户在下次登录时必须重置其密码 <code>passwd -e xxx</code></p><p>删除指定用户的密码值 <code>passwd -d xxx</code></p><p>查看指定用户的密码状态 <code>passwd -S xxx</code></p><h1 id="userdel"><a href="#userdel" class="headerlink" title="userdel"></a>userdel</h1><p>删除用户账户</p><h2 id="语法-74"><a href="#语法-74" class="headerlink" title="语法"></a>语法</h2><p>userdel [参数] 用户名</p><p>参数：</p><ul><li>-r：删除用户主目录及其中的任何文件</li></ul><h2 id="案例-77"><a href="#案例-77" class="headerlink" title="案例"></a>案例</h2><p>删除指定的用户账户信息 <code>userdel xxx</code></p><p>删除指定的用户账户信息及其家目录 <code>userdel -r xxx</code></p><h1 id="su"><a href="#su" class="headerlink" title="su"></a>su</h1><p>切换用户身份</p><h2 id="语法-75"><a href="#语法-75" class="headerlink" title="语法"></a>语法</h2><p>su [参数] 用户名</p><p>参数：</p><ul><li>-：完全身份变更</li><li>-c：执行完指定的指令后，即恢复原来的身份</li><li>-f：适用于csh与tsch，使shell不用去读取启动文件</li><li>-l：改变身份时，也同事变更工作目录</li><li>-m：变更身份时，不要变更环境变量</li><li>-s：指定要执行的shell</li></ul><h2 id="案例-78"><a href="#案例-78" class="headerlink" title="案例"></a>案例</h2><p>切换超级用户 <code>su</code>   <code>su root</code></p><p>变更账号为xxx并执行whomai指令后退出变回原使用者 <code>su -c whoami xxx</code></p><p>变更账号为xxx并保留在当前工作目录 <code>su xxx</code></p><p>变更账号为xxx并改变工作目录至xxx的家目录 <code>su - xxx</code></p><h1 id="sudo"><a href="#sudo" class="headerlink" title="sudo"></a>sudo</h1><p>以系统管理员的身份执行指令</p><h2 id="语法-76"><a href="#语法-76" class="headerlink" title="语法"></a>语法</h2><p>sudo [参数]</p><p>参数：</p><ul><li>-l：显示当前用户的权限</li><li>-u&lt;用户&gt;：以指定的用户作为新的身份。若不加上此参数，则预设以root作为新的身份</li></ul><h2 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h2><p>&#x2F;etc&#x2F;sudoers  授权用户&#x2F;组 主机&#x3D;[(切换到哪些用户或组)] 命令</p><p>查看配置文件  <code>sudo visudo</code> <code>sudo vim /etc/sudoers</code></p><h2 id="案例-79"><a href="#案例-79" class="headerlink" title="案例"></a>案例</h2><p>列出当前用户的权限 <code>sudo -l</code></p><p>指定用户身份执行命令 <code>sudo -u xxx whoami</code></p><p>以root权限执行上一条命令 <code>sudo !!</code></p><h2 id="id"><a href="#id" class="headerlink" title="id"></a>id</h2><p>显示用户ID和组ID</p><h2 id="语法-77"><a href="#语法-77" class="headerlink" title="语法"></a>语法</h2><p>id [参数] [用户名]</p><p>参数：</p><ul><li>-g：显示用户所属群组的ID</li><li>-G：显示用户所属附加群组的ID</li><li>-n：显示用户，所属群组或附加群组的名称</li><li>-r：显示实际ID</li><li>-u：显示用户ID</li></ul><h2 id="案例-80"><a href="#案例-80" class="headerlink" title="案例"></a>案例</h2><p>显示当前用户的所有信息 <code>id</code></p><p>显示指定用户信息 <code>id xxx</code></p><p>显示用户所属群组的ID <code>id -g xxx</code></p><p>显示用户所属附加群组的ID <code>id -G xxx</code></p><h2 id="usermod"><a href="#usermod" class="headerlink" title="usermod"></a>usermod</h2><p>修改用户账号信息</p><h2 id="语法-78"><a href="#语法-78" class="headerlink" title="语法"></a>语法</h2><p>usermod [参数] 用户名</p><p>参数：</p><ul><li>-c&lt;备注&gt;：修改用户账号的备注文字</li><li>-d&lt;登入目录&gt;：修改用户登入时的家目录</li><li>-e&lt;有效期&gt;：修改账号的有效期限</li><li>-f&lt;缓冲天数&gt;：修改在密码过期后多少天即关闭该账号</li><li>-g&lt;群组&gt;：修改用户所属的群组</li><li>-G&lt;群组&gt;：修改用户所属的附加群组</li><li>-l&lt;账号名称&gt;：修改用户账号名称</li><li>-L：锁定用户密码，使密码无效</li><li>-s&lt;shell&gt;：修改用户登入后所使用的shell</li><li>-u&lt;uid&gt;：修改用户ID</li><li>-U：解除密码锁定</li></ul><h2 id="案例-81"><a href="#案例-81" class="headerlink" title="案例"></a>案例</h2><p>修改指定用户的家目录路径 <code>usermode -d /home/hometest xxx</code></p><p>修改指定用户的UID号码 <code>usermode -u 1234 xxx</code></p><p>修改指定用户的名称 <code>usermode -l xxx aaa</code></p><p>锁定指定用户的账户 <code>usermode -L xxx</code></p><p>解锁指定用户的账户 <code>usermode -U xxx</code></p><h1 id="group"><a href="#group" class="headerlink" title="group"></a>group</h1><p>显示一个用户所加入的所有用户组</p><h2 id="语法-79"><a href="#语法-79" class="headerlink" title="语法"></a>语法</h2><p>groups用户</p><h2 id="案例-82"><a href="#案例-82" class="headerlink" title="案例"></a>案例</h2><p>显示xxx用户所加入的所有组 <code>groups xxx</code></p><h1 id="groupadd"><a href="#groupadd" class="headerlink" title="groupadd"></a>groupadd</h1><p>创建新的用户组</p><h2 id="语法-80"><a href="#语法-80" class="headerlink" title="语法"></a>语法</h2><p>groupadd [参数] 用户组</p><p>参数：</p><ul><li>-g：指定新建工作组的id</li><li>-r：创建系统工作组</li></ul><h2 id="案例-83"><a href="#案例-83" class="headerlink" title="案例"></a>案例</h2><p>创建一个新的用户组 <code>groupadd work</code></p><p>创建一个新的用户组，并指定GID号码 <code>groupadd -g 1234 family</code></p><p>创建一个新的用户组，设定为系统工作组 <code>groupadd -r grouptest</code></p><h1 id="groupdel"><a href="#groupdel" class="headerlink" title="groupdel"></a>groupdel</h1><p>删除用户组</p><h2 id="语法-81"><a href="#语法-81" class="headerlink" title="语法"></a>语法</h2><p>groupdel [参数] [群组名称]</p><h2 id="案例-84"><a href="#案例-84" class="headerlink" title="案例"></a>案例</h2><p>删除指定用户组 <code>groupdel family</code></p><h1 id="whoami"><a href="#whoami" class="headerlink" title="whoami"></a>whoami</h1><p>打印当前登录用户</p><h2 id="语法-82"><a href="#语法-82" class="headerlink" title="语法"></a>语法</h2><p>whoami</p><h2 id="案例-85"><a href="#案例-85" class="headerlink" title="案例"></a>案例</h2><p>查询当前登录的用户名 <code>whoami</code></p><h1 id="who"><a href="#who" class="headerlink" title="who"></a>who</h1><p>查看当前登录用户信息</p><h2 id="语法-83"><a href="#语法-83" class="headerlink" title="语法"></a>语法</h2><p>who [参数]</p><p>参数</p><ul><li>-a：全面信息</li><li>-b：系统最近启动时间</li><li>-l：系统登录进程</li><li>-H：带有列标题打印用户名，终端和时间</li><li>-t：系统上次锁定时间</li><li>-u：已登录用户列表</li><li>-q：列出所有已登录的用户的名称和数量</li></ul><h2 id="案例-86"><a href="#案例-86" class="headerlink" title="案例"></a>案例</h2><p>查看当前登录用户信息 <code>who</code></p><p>查看当前登录用户信息，并加上标题栏 <code>who -H</code></p><p>查看当前全部的登录用户信息 <code>who -H -a</code></p><p>查看系统的最近启动时间 <code>who -b</code></p><p>显示终端属性 <code>who -T -H</code></p><p>精简模式显示 <code>who -q</code></p><h1 id="w"><a href="#w" class="headerlink" title="w"></a>w</h1><p>显示已登录用户</p><h2 id="语法-84"><a href="#语法-84" class="headerlink" title="语法"></a>语法</h2><p>w [参数]</p><p>参数：</p><ul><li>-h：不打印头信息</li><li>-u：当显示当前进程和CPU时间时忽略用户名</li><li>-s：使用短输出格式</li><li>-f：显示用户从哪登录</li><li>-o：老式输出</li><li>-i：显示IP地址而不是主机名</li></ul><h2 id="案例-87"><a href="#案例-87" class="headerlink" title="案例"></a>案例</h2><p>显示目前登入系统的用户信息 <code>w</code></p><p>不打印头信息 <code>w -h</code></p><p>显示用户从哪登录 <code>w -f</code></p><p>使用短输出格式 <code>w -s</code></p><h1 id="last"><a href="#last" class="headerlink" title="last"></a>last</h1><p>显示用户或终端的登录情况</p><h2 id="语法-85"><a href="#语法-85" class="headerlink" title="语法"></a>语法</h2><p>last [选项]</p><p>参数：</p><ul><li>-R：省略hostname的栏位</li><li>-a：把从何处登入系统的主机名或IP地址，显示在最后一行</li><li>-n &lt;显示行数&gt; 或 -&lt;显示行数&gt;：显示名单的行数</li><li>-i：显示ip地址而不是主机名</li></ul><h2 id="案例-88"><a href="#案例-88" class="headerlink" title="案例"></a>案例</h2><p>显示近期用户或终端的登录情况 <code>last</code></p><p>简略显示，并指定显示的个数 <code>last -n 5 -R</code> <code>last -5 -R</code></p><p>最后一列显示主机IP地址 <code>last -n 5 -a -i</code> </p><h1 id="top"><a href="#top" class="headerlink" title="top"></a>top</h1><p>实时显示进程动态</p><h2 id="语法-86"><a href="#语法-86" class="headerlink" title="语法"></a>语法</h2><p>top -hv|-bcEHiOSs1 -d secs -n max -u|U user -p pid -o fld -w [cols]</p><p>参数：</p><ul><li>-d：指定每两次屏幕信息刷新之间的时间间隔（单位为秒）</li><li>-c：切换显示命令名称和完整命令行</li><li>-p：通过指定监控进程ID来仅仅监控某个进程的状态</li><li>-n：信息更新最大次数</li></ul><h2 id="快捷键"><a href="#快捷键" class="headerlink" title="快捷键"></a>快捷键</h2><ul><li>c：显示进程绝对路径</li><li>P：根据CPU使用率排序</li><li>M：根据物理内存使用率排序</li><li>1：显示每个核的CPU状态</li></ul><h2 id="案例-89"><a href="#案例-89" class="headerlink" title="案例"></a>案例</h2><p>实时显示进程动态 <code>top</code></p><p>显示完整的进程信息 <code>top -c</code></p><p>指定信息刷新时间为5秒 <code>top -d 5</code></p><p>仅监控进程 1877 的状态 <code>top -p 1877</code></p><p>设置信息更新次数 <code>top -n 2</code></p><h1 id="ps"><a href="#ps" class="headerlink" title="ps"></a>ps</h1><p>显示进程状态</p><h2 id="语法-87"><a href="#语法-87" class="headerlink" title="语法"></a>语法</h2><p>ps [OPTION]</p><p>OPTION：</p><ul><li>-A：显示所有进程</li><li>-a：显示所有终端机下执行的程序</li><li>-x：通常与a这个参数一起使用，可列出比较完整的信息</li><li>-e：列出程序时，显示每个程序所使用的环境变量</li><li>-f：用ASCII字符显示树状结构，表达程序间的相互关系</li><li>-u&lt;用户识别码&gt;：列出属于该用户的程序的状况，也可以使用用户名称来指定</li></ul><h2 id="信息说明"><a href="#信息说明" class="headerlink" title="信息说明"></a>信息说明</h2><ul><li>USER：用户名称</li><li>PID：进程号</li><li>%CPU：该进程所占用CPU百分比</li><li>%MEM：该进程所占用内存百分比</li><li>VSZ：进程所占用的虚拟内存大小</li><li>RSS：进程所占用的实际内存大小</li><li>TTY：该进程运行在哪个终端上面</li><li>STATUS：进程状态<ul><li>R：运行</li><li>S：可中断睡眠</li><li>D：不可中断睡眠</li><li>T：停止</li><li>Z：僵死</li></ul></li><li>START：进程启动时间</li><li>TIME：进程实际占用CPU的时间</li><li>COMMAND：该进程对应的执行程序</li></ul><h2 id="案例-90"><a href="#案例-90" class="headerlink" title="案例"></a>案例</h2><p>显示当前系统所有进程状态：</p><pre><code class="hljs">- 列出目前所有的正在内存中的程序 `ps -aux`- 显示所有进程信息 `ps -A`- 显示所有进程信息，连同命令行 `ps -ef`</code></pre><p>树形显示所有进程 <code>ps -axf</code></p><p>查找特定进程信息 <code>ps -aux | grep ssh</code></p><p>显示指定用户信息 <code>ps -u xxx</code></p><p>配合less命令使用 <code>ps -aux | less</code></p><p>结合管道操作符与sort命令，依据处理器使用量(第三列)情况降序排序 <code>ps aux | sort -rnk 3</code></p><h1 id="pstree"><a href="#pstree" class="headerlink" title="pstree"></a>pstree</h1><p>以树状图显示进程</p><h2 id="语法-88"><a href="#语法-88" class="headerlink" title="语法"></a>语法</h2><p>pstree [参数]</p><p>参数：</p><ul><li>-a：显示每个程序的完整指令，包含路径，参数或是常驻服务的标示</li><li>-c：不使用精简标示法</li><li>-G：使用VT100终端机的列绘图字符</li><li>-h：列出树状图时，特别标明现在执行的程序</li></ul><h2 id="案例-91"><a href="#案例-91" class="headerlink" title="案例"></a>案例</h2><p>以树状图显示进程 <code>pstree</code></p><p>显示该进程的完整指令及参数，遇到相同的进程名可以压缩显示 <code>pstree -a</code></p><p>显示当前所有进程的进程号和进程id <code>pstree -p</code></p><p>同事显示用户名称 <code>pstree -u</code></p><h1 id="pgrep"><a href="#pgrep" class="headerlink" title="pgrep"></a>pgrep</h1><p>检索当前正在运行的进程</p><h2 id="语法-89"><a href="#语法-89" class="headerlink" title="语法"></a>语法</h2><p>pgrep [参数] [模式]</p><p>参数：</p><ul><li>-d：设置一个字符串，用于分隔输出的每个进程ID</li><li>-f：模式参数仅用于匹配进程名</li><li>-l：列出进程名及进程ID</li><li>-u：选择仅匹配指定有效用户ID进程</li></ul><h2 id="案例-92"><a href="#案例-92" class="headerlink" title="案例"></a>案例</h2><p>查找ssh进程的pid <code>pgrep sshd</code></p><p>指定分隔输出 <code>pgrep sshd -d &#39;&#39;</code></p><p>查询用户xxx启动的bash进程的PID <code>pgrep -u xxx sshd</code></p><p>显示进程名称和PID <code>pgrep -l sshd</code></p><p>使用正则表达式 <code>pgrep &#39;^sshd$&#39; -l</code></p><p>匹配所有的参数列表 <code>pgrep -f ssh</code></p><h1 id="lsof"><a href="#lsof" class="headerlink" title="lsof"></a>lsof</h1><p>查看进程打开的文件</p><h2 id="语法-90"><a href="#语法-90" class="headerlink" title="语法"></a>语法</h2><p>lsof [参数] [文件]</p><p>参数：</p><ul><li>-a：列出打开文件存在的进程</li><li>-c&lt;进程名&gt;：列出指定进程所打开的文件</li><li>-g：列出GID号进程详情</li><li>-d&lt;文件号&gt;：列出占用该文件号的进程</li><li>+d&lt;目录&gt;：列出目录下被打开的文件</li><li>+D&lt;目录&gt;：递归列出目录下被打开的文件</li><li>-n&lt;目录&gt;：列出使用NFS的文件</li><li>-i&lt;条件&gt;：列出符合条件的进程</li><li>-p&lt;进程号&gt;：列出指定进程号所打开的文件</li><li>-u：列出UID号进程详情</li></ul><h2 id="案例-93"><a href="#案例-93" class="headerlink" title="案例"></a>案例</h2><p>查看当前系统中全部文件与进程对应信息 <code>lsof</code></p><p>显示指定目录中目录中被调用的文件信息 <code>lsof +d /home</code></p><p>递归显示指定目录中全部被调用的文件信息 <code>losf +D /home</code></p><p>查看谁正在使用某个文件 <code>losf /bin/bash</code></p><p>列出某个用户打开的文件信息 <code>lsof -u xxx</code></p><p>列出某个程序进程所打开的文件信息 <code>lsof -c bash</code></p><p>通过某个进程号显示该进程打开的文件 <code>lsof -p 1930</code></p><p>根据文件描述符列出对应的文件信息 <code>lsof -d 1</code></p><h1 id="jobs-bg-fg"><a href="#jobs-bg-fg" class="headerlink" title="jobs&#x2F;bg&#x2F;fg"></a>jobs&#x2F;bg&#x2F;fg</h1><p>终端任务调度</p><h2 id="案例-94"><a href="#案例-94" class="headerlink" title="案例"></a>案例</h2><p>列出当前shell的任务 <code>jobs -l</code></p><p>将test2.sh 调至前台运行 <code>fg 2</code></p><p>将当前进程切至后台运行 <code>ctrl + z</code></p><p>回复test2.sh在后台运行 <code>bg 2</code></p><p>杀死test3.sh <code>kill 3</code> <code>kill pid</code></p><h1 id="kill"><a href="#kill" class="headerlink" title="kill"></a>kill</h1><p>发送信号到进程</p><h2 id="语法-91"><a href="#语法-91" class="headerlink" title="语法"></a>语法</h2><p>kill [OPTION] &lt;pid&gt; […]</p><p>-l 列出系统支持的信号</p><h2 id="常用信号"><a href="#常用信号" class="headerlink" title="常用信号"></a>常用信号</h2><ul><li>HUO 1 终端断线</li><li>INT 2 中断(同 ctrl+c)</li><li>QUIT 3 退出(同ctrl+)</li><li>TERM 15 终止</li><li>KILL 9 强制终止</li><li>COUNT 18 继续(与STOP相反，fg&#x2F;bg命令)</li><li>STOP 19 暂停 (同 ctrl+z)</li></ul><h2 id="案例-95"><a href="#案例-95" class="headerlink" title="案例"></a>案例</h2><p>列出系统支持的所有信号列表 <code>kill -l</code></p><p>不指定信号 <code>kill 1951</code></p><p>得到指点信号的数量 <code>kill -l SIGKILL</code></p><p>杀死指定进程 <code>kill -9 1951</code></p><p>杀死指定用户所有进程 <code>kill -9 $(ps -ef | grep xxx)</code></p><h1 id="killall"><a href="#killall" class="headerlink" title="killall"></a>killall</h1><p>使用进程名称来杀死进程</p><h2 id="语法-92"><a href="#语法-92" class="headerlink" title="语法"></a>语法</h2><p>killall [参数] [进程名称]</p><p>参数：</p><ul><li>-l：打印所有已知信号列表</li><li>-u：杀死指定用户的进程</li></ul><h2 id="案例-96"><a href="#案例-96" class="headerlink" title="案例"></a>案例</h2><p>杀死所有sleep进程 <code>killall sleep</code></p><p>查看killall支持的所有信号 <code>killall -l</code></p><p>发送指定信号 <code>killall -9 sleep</code></p><p>杀死指定用户所有进程 <code>sudo killall -u xxx</code></p><h1 id="nice-renice"><a href="#nice-renice" class="headerlink" title="nice&#x2F;renice"></a>nice&#x2F;renice</h1><p>调整进程的优先级</p><h2 id="语法-93"><a href="#语法-93" class="headerlink" title="语法"></a>语法</h2><p>nice [参数] [命令]</p><p>renice [参数] [命令]</p><p>参数</p><p>nice</p><pre><code class="hljs">- -n：后面接一个数值，范围在 -10~19</code></pre><p>renice</p><pre><code class="hljs">- -g：指定进程组id- -p：改变该程序的优先权等级，此参数为预设值- -u：指定开启进程的用户名</code></pre><h2 id="案例-97"><a href="#案例-97" class="headerlink" title="案例"></a>案例</h2><p>查看nice值 <code>ps -l</code></p><p>设置优先级为15 <code>nice -n 15 vim &amp;</code> <code>nice -15 vim &amp;</code></p><p>根据pid重新设置进程的nice值 <code>renice 6 -p 5200</code></p><p>将xxx的进程的nice值全部设置为-5 <code>renice -5 -u xxx</code></p><h1 id="nohup"><a href="#nohup" class="headerlink" title="nohup"></a>nohup</h1><p>后台运行程序</p><h2 id="案例-98"><a href="#案例-98" class="headerlink" title="案例"></a>案例</h2><p>让进程在后台运行 <code>nohup ./test &amp;</code></p><p>输出重定向到file.txt文件  <code>nphup ./test &gt; file.txt 2&gt;&amp;1 &amp;</code></p><h1 id="apt"><a href="#apt" class="headerlink" title="apt"></a>apt</h1><p>包管理器</p><h2 id="语法-94"><a href="#语法-94" class="headerlink" title="语法"></a>语法</h2><p>apt [选项] 软件包</p><h2 id="案例-99"><a href="#案例-99" class="headerlink" title="案例"></a>案例</h2><p>列出所有可更新的软件清单 <code>sudo apt update</code></p><p>升级软件可更新的软件包 <code>sudo apt upgrade</code></p><p>单独升级某个安装包 <code>sudo apt upgrade vim</code></p><p>安装软件包 <code>sudo apt install bat</code></p><p>删除软件包 <code>sudo apt remove bat</code></p><p>打印软件包信息 <code>sudo apt show bat</code></p><p>清理不再使用的依赖和库文件 <code>sudo apt autoremove</code></p><p>列出已安装的所有软件包 <code>sudo apt list --installed</code></p><h1 id="export"><a href="#export" class="headerlink" title="export"></a>export</h1><p>设置或显示环境变量</p><h2 id="语法-95"><a href="#语法-95" class="headerlink" title="语法"></a>语法</h2><p>export [选项] 文件</p><p>参数：</p><ul><li>-f：代表[变量名称]中为函数名</li><li>-n：删除指定的变量。变量实际上并未删除，只是不会输出到后续指令的执行环境中</li><li>-p：列出所有的shell赋予程序的环境变量</li></ul><h2 id="注意-1"><a href="#注意-1" class="headerlink" title="注意"></a>注意</h2><p>export的作用效果仅限于本次登录</p><p>如果想永久生效，可修改配置文件 <code>/etc/profile #所有用户</code> <code>~/.bashrc  #当前用户</code></p><h2 id="案例-100"><a href="#案例-100" class="headerlink" title="案例"></a>案例</h2><p>列出当前所有的环境变量 <code>export -p</code></p><p>定义环境变量 <code>export MYENV</code></p><p>定义环境变量并复制 <code>export MYENV=7</code></p><p>修改环境变量PATH <code>export PATH=$PATH:/usr/local/mysql/bin</code></p><h1 id="source"><a href="#source" class="headerlink" title="source"></a>source</h1><p>在当前shell环境中从指定文件读取和执行命令</p><p>该命令通常用命令 “.” 来代替</p><h2 id="语法-96"><a href="#语法-96" class="headerlink" title="语法"></a>语法</h2><p>source [文件]</p><h2 id="案例-101"><a href="#案例-101" class="headerlink" title="案例"></a>案例</h2><p>读取和执行bashrc文件 <code>source ~/.bashrc</code> <code>. ~/.bashrc</code></p><p>执行刚修改的初始化文件，使之立即生效 <code>source /etc/profile</code></p><h1 id="set-unset"><a href="#set-unset" class="headerlink" title="set&#x2F;unset"></a>set&#x2F;unset</h1><p>设置&#x2F;删除shell变量</p><h2 id="语法-97"><a href="#语法-97" class="headerlink" title="语法"></a>语法</h2><p>set [参数] [变量]</p><p>unset [参数] [变量]</p><p>参数：</p><p>set：</p><pre><code class="hljs">- -a：标示已修改的变量，以供输出至环境变量</code></pre><p>unset：</p><pre><code class="hljs">- -f：仅删除函数- -v：仅删除变量</code></pre><h2 id="案例-102"><a href="#案例-102" class="headerlink" title="案例"></a>案例</h2><p>显示所有的shell变量 <code>set</code></p><p>设置环境变量 <code>第一步：定义新的环境变量 declare myenv=&#39;666&#39;</code> <code>第二步：将定义的变量输出为环境变量 set -a myenv</code> <code>第三步：查看是否设置成功 env|grep myenv</code></p><p>删除环境变量 <code>unset -v myenv</code> <code>unset myenv#优先删除变量</code></p><h1 id="history"><a href="#history" class="headerlink" title="history"></a>history</h1><p>显示与管理历史命令记录</p><h2 id="语法-98"><a href="#语法-98" class="headerlink" title="语法"></a>语法</h2><p>history [参数]</p><p>参数：</p><ul><li>-c：清楚命令记录</li><li>-d：删除指定序号的命令记录</li><li>-n：读取命令记录</li></ul><h2 id="案例-103"><a href="#案例-103" class="headerlink" title="案例"></a>案例</h2><p>显示执行过的全部命令记录 <code>histroy</code></p><p>显示执行过的最近5条命令 <code>history 5</code></p><p>重新执行2039命令 <code>!2039</code></p><p>重新执行上一条命令 <code>!!</code></p><p>将搜索与你输入相匹配的最近一个命令，并重新执行 <code>!ls</code></p><p>调用历史记录的递归搜索 <code>ctrl+r</code></p><p>如果想要删除特定命令 <code>hostory -d 1234</code></p><p>清空全部历史记录 <code>hostiry -c</code></p>]]></content>
    
    
    <categories>
      
      <category>操作系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>操作系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MySQL缓冲池Buffer Pool</title>
    <link href="/2024/08/07/MySQL%E7%BC%93%E5%86%B2%E6%B1%A0Buffer-Pool/"/>
    <url>/2024/08/07/MySQL%E7%BC%93%E5%86%B2%E6%B1%A0Buffer-Pool/</url>
    
    <content type="html"><![CDATA[<h1 id="什么是Buffer-Pool"><a href="#什么是Buffer-Pool" class="headerlink" title="什么是Buffer Pool"></a>什么是Buffer Pool</h1><p>MySQL的数据是存储在磁盘上的，我们在访问数据时，需要从磁盘读取数据，这个过程是比较慢的，如果在内存上有缓存，访问数据时是从内存读取而不是从磁盘读取，就会快很多。</p><p>Buffer Pool就是MySQL在内存上的缓存。</p><p>Buffer Pool是InnoDB存储引擎的。处于引擎层。</p><p>有了Buffer Pool之后，在读取数据时，如果数据存在于Buffer Pool中，就会直接读取Buffer Pool中的数据。在修改数据时，如果数据在Buffer Pool中，则直接Buffer Pool中数据所在的页，然后将其设置为脏页，最后由后台线程将脏页写入磁盘。</p><p>buffer pool具有以下特点：</p><ul><li>buffer pool通常以 <strong>页(page)</strong> 为单位缓存数据，其中的页是数据库页面的副本，页的大小通常是固定的（如 InnoDB 的默认页大小为 16KB）</li><li><strong>磁盘读写，并不是按需读取，而是按页读取</strong>，一次至少读一页数据（，如果未来要读取的数据就在页中，就能够省去后续的磁盘IO，提高效率。</li><li>使用特定的页面替换算法（如 LRU，最近最少使用）来决定哪些页应从内存中移出，为新的页腾出空间</li><li>其大小和相关参数可以通过数据库配置进行调整，以适应不同的工作负载和硬件资源。例如，InnoDB 的 buffer pool 大小可以通过参数 <code>innodb_buffer_pool_size</code> 进行配置。默认是128M，一般建议设置为物理内存的60%~80%</li></ul><h1 id="Buffer-Pool的结构"><a href="#Buffer-Pool的结构" class="headerlink" title="Buffer Pool的结构"></a>Buffer Pool的结构</h1><p><img src="https://gxc-hexo-blog.oss-cn-beijing.aliyuncs.com/blog/mysql_buffer_pool.png"></p><ol><li><p>索引页（Index Pages）</p><p>索引页存储了InnoDB表的索引结构，包括主键索引（聚集索引）和辅助索引（非聚集索引）。这些索引页被加载到缓冲池中，以加速对表中数据的查找和访问。当执行查询操作时，InnoDB会首先检查所需的索引页是否已经在缓冲池中，如果在，则直接从缓冲池中读取，这称为缓冲池命中；如果不在，则需要从磁盘加载到缓冲池中，这称为缓冲池未命中。</p></li><li><p>数据页（Data Pages）</p><p>数据页存储了InnoDB表的实际数据行。在InnoDB中，数据是按页存储的，每个数据页通常包含多行数据。当需要读取或修改表中的数据时，相关的数据页会被加载到缓冲池中。通过将数据页缓存在内存中，InnoDB可以快速地读取和修改数据，而无需每次都从磁盘加载。</p></li><li><p>Undo页（Undo Pages）</p><p>Undo页存储了旧版本的数据，用于支持事务的ACID属性中的隔离性（Isolation）和持久性（Durability）。当执行一个事务时，对数据的修改不会立即生效，而是先记录在Undo页中。如果其他事务需要读取被修改的数据，它可以通过Undo页来获取数据修改前的版本，从而实现多版本并发控制（MVCC）。此外，如果事务失败或回滚，Undo页中的数据可以用于恢复数据到事务开始前的状态。</p></li><li><p>插入缓存（Insert Buffer）</p><p>插入缓存是InnoDB中用于优化非聚集索引插入操作的一种机制。当向一个包含非聚集索引的表中插入数据时，如果相关的索引页不在缓冲池中，InnoDB不会立即将索引键插入到索引页中，而是将其存储在插入缓存中。当相关的索引页被加载到缓冲池时，插入缓存中的索引键会被合并并插入到索引页中。这样可以减少磁盘I&#x2F;O操作，并提高插入操作的性能。</p><p>需要注意的是，插入缓存只适用于非唯一索引的插入操作，并且在某些情况下，如缓冲池足够大或表很小，插入缓存可能不会被使用。</p></li><li><p>自适应哈希索引（Adaptive Hash Index）</p><p>自适应哈希索引是InnoDB存储引擎的一个特性，用于自动根据访问模式创建哈希索引。当某些索引值被频繁访问时，InnoDB会将这些索引值存储在自适应哈希索引中，以加速对这些值的查找。自适应哈希索引是完全自动的，不需要用户手动创建或维护。当哈希索引不再被频繁使用时，InnoDB会自动删除它们以释放内存。</p></li><li><p>InnoDB的锁信息（Lock Information）</p><p>InnoDB存储引擎使用锁来确保并发访问时的数据一致性和完整性。在缓冲池中，InnoDB会维护锁信息，以跟踪哪些数据页或行被锁定，以及锁的类型（如共享锁或排他锁）。这些锁信息对于实现事务的隔离性和并发控制至关重要。当事务尝试访问被其他事务锁定的数据时，它会根据锁的类型和事务的隔离级别来决定是等待锁释放还是立即返回错误。</p></li></ol><h1 id="Buffer-Pool的管理"><a href="#Buffer-Pool的管理" class="headerlink" title="Buffer Pool的管理"></a>Buffer Pool的管理</h1><p>InnoDB把存储的数据划分成了若干个 <code>页</code> 。以页作为和磁盘交互的基本单位，一个页的默认大小是16KB。因此，Buffer Pool同样需要按照 <code>页</code>来划分。</p><p>为了更好的管理这些在Buffer Pool中的缓存页，InnoDB为每一个缓存页都创建了一个「控制块」，控制块信息包括「缓存页的表空间、页号、缓存页地址、链表节点」等。</p><img src="https://gxc-hexo-blog.oss-cn-beijing.aliyuncs.com/blog/mysql_buffer-pool_control_block.png" style="zoom:150%;" /><p>每个控制块大约占缓存页的5%，而系统设置的innodb_buffer_pool_size的大小不包括控制块，所以Innodb存储引擎向操作系统申请的内存空间，会比设置的innodb_buffer_pool_size大5%左右。控制块排在前面，缓存页排在后面，他们之间会存在没有分配完的内存碎片。</p><h2 id="Free链表"><a href="#Free链表" class="headerlink" title="Free链表"></a>Free链表</h2><p>Free链表的作用是管理空闲页。</p><p>当MySQL运行一段时间后，Buffer Pool中既有已使用的，也有空闲的。</p><p>从磁盘读取一页数据，需要把他加载到Buffer Pool中时，需要知道那些缓存页是空闲的， 此时如果从头遍历，查看那些缓存页是空闲的，就显得太低效。</p><p>所以，为了高效的找到空闲的缓存页，InnoDB使用链表存放所有的空闲缓存页的控制块，当需要把一页数据加载到Buffer Pool时，从Free链表中获取一个控制块，根据控制块记录的缓存页的地址，就可以找到一个空闲缓存页，然后把查询到的页数据加入到缓存页中，把此页所属的表空间编号、页号信息写入此缓存页对应的控制块，最后从free链表中移出此控制块。</p><p><img src="https://gxc-hexo-blog.oss-cn-beijing.aliyuncs.com/blog/mysql_buffer-pool_free_list.png"></p><h2 id="Flush链表"><a href="#Flush链表" class="headerlink" title="Flush链表"></a>Flush链表</h2><p>Flush链表的作用是管理脏页。</p><p>当客户端更新数据时，如果数据在Buffer Pool中，就会去更新Buffer Pool中对应的缓存页的数据，这个缓存页也就会被标记为「脏页」，然后再由后台线程将脏页写入磁盘。</p><p>同理，为了能够高效的找到脏页，于是就设计出了Flush链表，作用和Free链表类似，链表的节点也是控制块，区别在于Flush链表的元素都是脏页。</p><p><img src="https://gxc-hexo-blog.oss-cn-beijing.aliyuncs.com/blog/mysql_buffer-pool_free_list.png"></p><h3 id="脏页什么时候刷盘"><a href="#脏页什么时候刷盘" class="headerlink" title="脏页什么时候刷盘"></a>脏页什么时候刷盘</h3><p>当数据在Buffer Pool中时，修改数据，就是修改Buffer Pool中数据所在的页，然后将其设置为脏页，但是磁盘中的数据还没有改变。</p><p>如果此时宕机，或者MySQL进程挂了，数据怎么办？</p><p>InnoDB的更新采用了WAL（write ahead log）的方式，先写了日志（redo log），再写磁盘，通过redo log让MySQL具有crash safe能力。</p><p>刷盘时机：</p><ul><li>当redo log日志满了，就会主动触发脏页刷新到磁盘</li><li>Buffer Pool空间不足，需要将一部分数据淘汰掉，如果被淘汰的数据是脏页，则要先将脏页刷盘</li><li>MySQL空闲时，后台线程定期将适量的脏页刷入磁盘</li><li>MySQL正常关闭前，会把所有的脏页刷入磁盘</li></ul><h2 id="LRU链表"><a href="#LRU链表" class="headerlink" title="LRU链表"></a>LRU链表</h2><p>Buffer Pool的大小是有限的。每次添加新数据时，都会消耗一个空闲缓存页，当Free链表中的空闲页为空，再添加新数据时，就需要淘汰掉一些数据来腾出缓存页。</p><p>这时肯定是淘汰掉使用频率最低的缓存页，所以InnoDB就使用了LRU（least recently used 最近最少使用算法）来淘汰缓存页，LRU链表记录访问过的缓存页对应的控制块。</p><p>简单的LRU思路：</p><ul><li>当访问的页在Buffer Pool中，就直接把该页放到LRU链表的头部</li><li>当访问的页不在Buffer Pool中，先淘汰掉LRU链表末尾的节点，再把访问页放到LRU链表头部</li></ul><p>但是InnoDB有预读机制，如果如同预读机制加载进来的页，试用频率不高，但是因为加载这个页，可能把使用频率高的页淘汰掉。全表扫描没有加where条件加载的页，也可能会把使用频率高的页淘汰掉。于是需要对LRU进行优化。</p><h3 id="预加载优化"><a href="#预加载优化" class="headerlink" title="预加载优化"></a>预加载优化</h3><p>InnoDB把LRU链表分成了两部分：young区域、old区域</p><p>young区域存储使用频率高的缓存页，也叫热数据。</p><p>old区域存储使用频率低的缓存页，也叫冷数据。</p><p>old区域占据整个LRU链表长度的比例可以通过<code>innodb_old_blocks_pct</code>参数来设置，默认是37，表示LRU链表中，young区域与old区域的比例是 63:37。</p><p>当某个页初次加载到Buffer Pool中时，缓存页对应的控制块加到LRU链表的old区域的头部，这样通过预读加载进来的页，放到old区域，不影响young区域的数据，后续会从old区域逐渐被淘汰。</p><p>当再次访问old区域控制块对应的缓存页时，此控制块会从old区域移动到young区域的头部，此缓存页作为热数据处理。</p><p>当young区域放满后，又有新的控制块需要从old区域移动到young，则young区域的链尾移动到old区域的链头；当再次访问young区域控制块对应的缓存页时，此控制块移动到young区域的头部。<br><img src="https://gxc-hexo-blog.oss-cn-beijing.aliyuncs.com/blog/mysql_buffer-pool_lru_list.png"></p><h3 id="全表扫描优化"><a href="#全表扫描优化" class="headerlink" title="全表扫描优化"></a>全表扫描优化</h3><p>以上的优化，虽然在预加载的时候，不会淘汰掉热点数据，但是在全表扫描还是有问题。</p><p>全表扫描，一个页有多条记录需要访问，每访问一条记录就算访问一次缓存页，所以这样也算是多次访问，从而清洗young区域。</p><p>针对此问题，InnoDB对每次访问old区域控制块时，都会记录一下访问时间，当再次访问，会算出访问的时间间隔与阈值进行对比，若是小于阈值，则不会把控制块移动到young区域，此间隔阈值由<code>innodb_old_blocks_time</code>控制，默认是1000，单位毫秒，这样进行全表扫描时，多次访问一个缓存页，就不会移动到young区域。</p><h3 id="young区域优化"><a href="#young区域优化" class="headerlink" title="young区域优化"></a>young区域优化</h3><p>为了防止young区域控制块频繁移动到头部，访问young区域前 1&#x2F;4 区域的控制块，不会进行移动，只有访问后面的 3&#x2F;4 才会移动。</p>]]></content>
    
    
    <categories>
      
      <category>MySQL</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MySQL</tag>
      
      <tag>数据库</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MySQL三大日志(binlog、redo log、undo log)</title>
    <link href="/2024/07/10/MySQL%E4%B8%89%E5%A4%A7%E6%97%A5%E5%BF%97(binlog%E3%80%81redo%20log%E3%80%81undo%20log)/"/>
    <url>/2024/07/10/MySQL%E4%B8%89%E5%A4%A7%E6%97%A5%E5%BF%97(binlog%E3%80%81redo%20log%E3%80%81undo%20log)/</url>
    
    <content type="html"><![CDATA[<p>MySQL的日志有错误日志（Error Log）、查询日志（General Log）、慢查询日志（Slow Query Log）、二进制日志（Binary Log）、中继日志（Relay Log）、重做日志（Redo Log）、撤销日志（Undo Log）等，比较重要的是二进制日志（Binary Log）、重做日志（Redo Log）、撤销日志（Undo Log）。</p><p>需要注意的是，重做日志（Redo Log）和撤销日志（Undo Log）是InnoDB的日志，如果使用的存储引擎不是InnoDB，就不会有这两个日志。</p><h1 id="buffer-pool"><a href="#buffer-pool" class="headerlink" title="buffer pool"></a>buffer pool</h1><p>在介绍日志之前先简单介绍一下buffer pool。</p><p>MySQL的数据是存储在磁盘上的，我们在访问数据时，需要从磁盘读取数据，这个过程是比较慢的，如果在内存上有缓存，访问数据时是从内存读取而不是从磁盘读取，就会快很多。</p><p>buffer pool就是在内存上的缓存。</p><p>buffer pool具有以下特点：</p><ul><li>buffer pool通常以 <strong>页(page)</strong> 为单位缓存数据，其中的页是数据库页面的副本，页的大小通常是固定的（如 InnoDB 的默认页大小为 16KB）</li><li><strong>磁盘读写，并不是按需读取，而是按页读取</strong>，一次至少读一页数据（，如果未来要读取的数据就在页中，就能够省去后续的磁盘IO，提高效率。</li><li>使用特定的页面替换算法（如 LRU，最近最少使用）来决定哪些页应从内存中移出，为新的页腾出空间</li><li>其大小和相关参数可以通过数据库配置进行调整，以适应不同的工作负载和硬件资源。例如，InnoDB 的 buffer pool 大小可以通过参数 <code>innodb_buffer_pool_size</code> 进行配置。</li></ul><p>buffer pool的结构如下：</p><img src="https://gxc-hexo-blog.oss-cn-beijing.aliyuncs.com/blog/mysql_buffer_pool.png"  /><ol><li>索引页（Index Pages）</li></ol><p>索引页存储了InnoDB表的索引结构，包括主键索引（聚集索引）和辅助索引（非聚集索引）。这些索引页被加载到缓冲池中，以加速对表中数据的查找和访问。当执行查询操作时，InnoDB会首先检查所需的索引页是否已经在缓冲池中，如果在，则直接从缓冲池中读取，这称为缓冲池命中；如果不在，则需要从磁盘加载到缓冲池中，这称为缓冲池未命中。</p><ol start="2"><li>数据页（Data Pages）</li></ol><p>数据页存储了InnoDB表的实际数据行。在InnoDB中，数据是按页存储的，每个数据页通常包含多行数据。当需要读取或修改表中的数据时，相关的数据页会被加载到缓冲池中。通过将数据页缓存在内存中，InnoDB可以快速地读取和修改数据，而无需每次都从磁盘加载。</p><ol start="3"><li>Undo页（Undo Pages）</li></ol><p>Undo页存储了旧版本的数据，用于支持事务的ACID属性中的隔离性（Isolation）和持久性（Durability）。当执行一个事务时，对数据的修改不会立即生效，而是先记录在Undo页中。如果其他事务需要读取被修改的数据，它可以通过Undo页来获取数据修改前的版本，从而实现多版本并发控制（MVCC）。此外，如果事务失败或回滚，Undo页中的数据可以用于恢复数据到事务开始前的状态。</p><ol start="4"><li>插入缓存（Insert Buffer）</li></ol><p>插入缓存是InnoDB中用于优化非聚集索引插入操作的一种机制。当向一个包含非聚集索引的表中插入数据时，如果相关的索引页不在缓冲池中，InnoDB不会立即将索引键插入到索引页中，而是将其存储在插入缓存中。当相关的索引页被加载到缓冲池时，插入缓存中的索引键会被合并并插入到索引页中。这样可以减少磁盘I&#x2F;O操作，并提高插入操作的性能。</p><p>需要注意的是，插入缓存只适用于非唯一索引的插入操作，并且在某些情况下，如缓冲池足够大或表很小，插入缓存可能不会被使用。</p><ol start="5"><li>自适应哈希索引（Adaptive Hash Index）</li></ol><p>自适应哈希索引是InnoDB存储引擎的一个特性，用于自动根据访问模式创建哈希索引。当某些索引值被频繁访问时，InnoDB会将这些索引值存储在自适应哈希索引中，以加速对这些值的查找。自适应哈希索引是完全自动的，不需要用户手动创建或维护。当哈希索引不再被频繁使用时，InnoDB会自动删除它们以释放内存。</p><ol start="6"><li>InnoDB的锁信息（Lock Information）</li></ol><p>InnoDB存储引擎使用锁来确保并发访问时的数据一致性和完整性。在缓冲池中，InnoDB会维护锁信息，以跟踪哪些数据页或行被锁定，以及锁的类型（如共享锁或排他锁）。这些锁信息对于实现事务的隔离性和并发控制至关重要。当事务尝试访问被其他事务锁定的数据时，它会根据锁的类型和事务的隔离级别来决定是等待锁释放还是立即返回错误。</p><h1 id="redo-log"><a href="#redo-log" class="headerlink" title="redo log"></a>redo log</h1><h2 id="什么是WAL技术"><a href="#什么是WAL技术" class="headerlink" title="什么是WAL技术"></a>什么是WAL技术</h2><p>WAL（Write-Ahead Logging，预写日志）是一种确保数据一致性和可靠性的重要技术，广泛应用于数据库管理系统中。WAL 技术的核心思想是，在将数据更新写入数据库之前，先将这些更新记录到日志文件中。</p><p>具体步骤如下：</p><ol><li><strong>写日志</strong>：在执行数据修改操作之前，首先将这些修改操作记录到 WAL 日志文件中。这些日志条目通常包括事务 ID、修改的表、被修改的行、修改的具体内容等信息。</li><li><strong>写数据</strong>：将实际的数据修改操作应用到数据库中（写入内存中的缓冲区或磁盘上的数据文件）。</li><li><strong>持久化日志</strong>：确保日志文件中的记录被安全地写入磁盘，以防止在系统崩溃时丢失。</li><li><strong>持久化数据</strong>：在适当的时机，将缓冲区中的数据持久化到磁盘上的数据文件中。</li></ol><p>通过先记录日志再执行数据修改，WAL 技术确保了系统在崩溃后能够通过日志进行恢复，保证数据一致性。即使系统在数据写入过程中崩溃，也可以通过重放 WAL 日志中的记录来恢复未完成的事务。</p><h2 id="什么是redo-log"><a href="#什么是redo-log" class="headerlink" title="什么是redo log"></a>什么是redo log</h2><p>上述说明了什么是WAL技术，对应MySQL来说，就是写操作不是立刻写到磁盘上，而是先写日志，然后在合适的时间写到磁盘上。</p><p>redo log 用于记录对数据库的修改操作，确保在系统崩溃后可以通过这些日志进行恢复，使数据库恢复到崩溃前的一致状态。为了防止崩溃、或者断电导致的数据丢失，当有一条记录更新时，InnoDB引擎就会先更新内存（同时标记为脏页），然后将本次对这个页的修改以 redo log的形式记录下来，这时就算更新完成，后续InnoDB引擎会在适当的时候，由后台线程将缓存在buffer poll的脏页刷新到磁盘（这就是WAL技术）。</p><p>redo log是物理日志，记录的是数据页的物理变化。例如，某个事务将某一页中的某个偏移量处的数据从旧值改为新值。</p><p>在事务提交时，只要先将 redo log 持久化到磁盘即可，可以不需要等到将缓存在 Buffer Pool 里的脏页数据持久化到磁盘。</p><p>当系统崩溃时，虽然脏页数据没有持久化，但是 redo log 已经持久化，接着 MySQL 重启后，可以根据 redo log 的内容，将所有数据恢复到最新的状态。</p><h2 id="Redo-Log-的作用"><a href="#Redo-Log-的作用" class="headerlink" title="Redo Log 的作用"></a>Redo Log 的作用</h2><ol><li><strong>数据恢复</strong>：在系统崩溃或硬件故障后，使用 redo log 可以恢复所有已经提交的事务，将数据库恢复到最新的一致状态。</li><li><strong>崩溃恢复</strong>：通过重放 redo log 中的记录，可以将数据库恢复到崩溃前的状态，确保数据的完整性和一致性。</li><li><strong>持久性保证</strong>：redo log 确保事务的持久性（即事务的 ACID 特性中的 Durability），即使在系统崩溃后，已经提交的事务不会丢失。</li></ol><h2 id="redo-log什么时候写入磁盘"><a href="#redo-log什么时候写入磁盘" class="headerlink" title="redo log什么时候写入磁盘"></a>redo log什么时候写入磁盘</h2><p>redo log也有缓存，不是直接写入磁盘，而是写入redo log的缓存——redo log buffer，那redo log什么时候写入磁盘呢？</p><ol><li>MySQL正常关闭时</li><li>checkpoint机制，InnoDB 通过 checkpoint 机制管理 redo log 的使用和重用。当 redo log 文件接近写满时，系统会触发 checkpoint，将内存中的脏页（已修改但未写入磁盘的数据页）写入数据文件，并更新 checkpoint 位置。这使 redo log 文件能够循环重用，并确保系统在崩溃恢复时可以从 checkpoint 开始重做操作。</li><li>每次事务提交时</li></ol><p>在每次事务提交时，会将redo log写入磁盘，但是写入磁盘有三种方式，InnoDB提供了一个关键参数 <code>innodb_flush_log_at_trx_commit</code> 来控制redo log的写入和刷新策略。这个参数有三种设置，每种设置决定了redo log何时写入磁盘：</p><ul><li><p><strong><code>innodb_flush_log_at_trx_commit = 1</code></strong> （默认值）：</p></li><li><p>每次事务提交时，InnoDB 会将 redo log buffer 中的日志条目写入到 redo log 文件，并立即刷新到磁盘。</p></li><li><p>这种设置保证了每个提交的事务都持久化到磁盘，即使系统崩溃，已提交的事务也不会丢失。</p></li><li><p><strong><code>innodb_flush_log_at_trx_commit = 0</code></strong> ：</p></li><li><p>每次事务提交时，redo log buffer 中的日志条目不会立即写入磁盘，而是由后台线程每秒将 redo log buffer 刷新到 redo log 文件。</p></li><li><p>这种设置在系统崩溃时可能会丢失最近一秒内的事务，但可以提高性能，因为减少了磁盘 I&#x2F;O 操作。</p></li><li><p><strong><code>innodb_flush_log_at_trx_commit = 2</code></strong> ：</p></li><li><p>每次事务提交时，InnoDB 会将 redo log buffer 中的日志条目写入到 redo log 文件，但不会立即刷新到磁盘，而是依赖于操作系统的文件系统缓存刷新机制（通常每秒一次）。</p></li><li><p>这种设置在系统崩溃时可能会丢失最近一秒内的事务，但性能介于 <code>innodb_flush_log_at_trx_commit=0</code> 和 <code>innodb_flush_log_at_trx_commit=1</code> 之间。</p></li></ul><p>解释一下<code>innodb_flush_log_at_trx_commit = 2</code>的场景。在计算机操作系统中，用户空间(user space)下的缓冲区数据一般情况下是无法直接写入磁盘的，中间必须经过操作系统内核空间(kernel space)缓冲区(OS Buffer)。因此，redo log buffer &#x2F; undo log buffer写入redo log file &#x2F; undo log file实际上是先写入OS Buffer，然后再通过系统调用fsync()将其刷到redo log file &#x2F; undo log file中。所以在参数等于2的时候，是将日志写入文件，但是不会立刻刷新到磁盘：</p><p><img src="https://gxc-hexo-blog.oss-cn-beijing.aliyuncs.com/blog/mysql_log_fsync.png"></p><h2 id="redo-log组"><a href="#redo-log组" class="headerlink" title="redo log组"></a>redo log组</h2><p><img src="https://gxc-hexo-blog.oss-cn-beijing.aliyuncs.com/blog/redo_log_group.png"></p><p>redo log日志文件不止一个，而是以一个日志文件组出现的，每个redo log日志文件大小都是一样的，比如上图一组有4个文件，每个文件大小1GB，整个redo log日志文件组容量就有4GB。</p><p>日志的文件名字是<code>ib_logfile+编号</code>，比如上图就是<code>ib_logfile0、ib_logfile1……</code></p><p>redo log日志是环形数组的形式，从头开始写，写到末尾就又回到开头。</p><p>日志文件组中有两个重要的属性，分别是：</p><ul><li><code>write pos</code>是当前记录的位置，一边写一遍后移</li><li><code>check point</code>是当前要擦除的位置，也是向后移动</li></ul><p>redo log是为了防止buffer pool中的脏页丢失而设计的，随着系统运行，buffer pool中的脏页刷新到了磁盘上，对应redo log的记录就没用了，这时就可以擦除旧记录，腾出新空间。</p><p>当write pos追上了checkpoint，说明redo log文件满了，这时，MySQL就不能再执行新的更新操作，MySQL就会阻塞（针对并发量大时，适当设置redo log文件大小），此时要停下来将buffer pool中的脏页刷新到磁盘中，然后标记redo log哪些记录可以被擦除，接着要对旧的redo log记录进行擦除，腾出新的空间，checkpoint向后移动，MySQL恢复正常，继续执行更新操作</p><h2 id="redo-log也要写入磁盘，岂不是多余？"><a href="#redo-log也要写入磁盘，岂不是多余？" class="headerlink" title="redo log也要写入磁盘，岂不是多余？"></a>redo log也要写入磁盘，岂不是多余？</h2><p>redo log在写的时候是追加操作，磁盘是<strong>顺序写</strong>，而直接写数据，要先找到数据的位置，然后再写磁盘，是<strong>随机写</strong>。</p><p>所以这是WAL技术的一个有点：将随机写变更顺序写提高性能</p><h1 id="undo-log"><a href="#undo-log" class="headerlink" title="undo log"></a>undo log</h1><p>undo log是回滚日志，用来回滚行记录到某个版本，undo log一般是逻辑日志，根据行的数据变化进行记录，可以简单的理解为：当insert一条记录时，undo log会记录一条对应的delete语句；当update一条语句时，undo log记录的是一条与之操作相反的语句。它保证了事务ACID特性中的原子性(Atomicty)</p><p>undo log跟redo log一样也是在SQL操作数据之前记录的，也就是SQL操作先记录日志，再进行操作数据</p><p>当事务需要回滚时，可以从undo log中找到相应的内容进行回滚操作，回滚后数据恢复到操作之前的状态</p><p>一条记录的每次更新操作产生的undo log都有一个roll_pointer指针和一个trx_id事务id</p><ul><li>通过trx_id可以知道该记录是被那个事务修改的</li><li>roll_pointer指针将这些undo log串成一个链表，这个链表就被成为版本链</li><li>undo log是MVCC实现的关键，通过ReadView + undo log实现MVCC(多版本并发控制)</li></ul><p><img src="https://gxc-hexo-blog.oss-cn-beijing.aliyuncs.com/blog/undo_log_%E7%89%88%E6%9C%AC%E9%93%BE.png"></p><h1 id="binlog"><a href="#binlog" class="headerlink" title="binlog"></a>binlog</h1><p>binlog用于记录所有对数据库进行更改的额操作（例如，数据的插入、更新和删除，不包含查询操作），以及这些操作的顺序。主要用于数据恢复、复制和审计。在事务提交时，将该事务执行过程中产生的所有binlog统一写进binlog文件。</p><p>redo log和binlog都记录了数据库的修改操作，为什么还需要binlog？</p><p>首先看看redo log和binlog的区别</p><table><thead><tr><th></th><th>redo log</th><th>binlog</th></tr></thead><tbody><tr><td>日志种类</td><td>redo log是物理日志，记录的是数据页的物理变化。例如，某个事务将某一页中的某个偏移量处的数据从旧值改为新值</td><td>binlog是逻辑日志，它记录的是对数据库进行的高层次的逻辑操作，例如 SQL 语句的执行，而不是底层数据页的物理变化。</td></tr><tr><td>所处位置</td><td>redo log是InnoDB引擎实现的，是在存储引擎层的，只有使用InnoDB存储引擎时，才会有这个日志</td><td>binglog是server层实现的，所有的存储引擎都会有这个日志</td></tr><tr><td>作用</td><td>redo是物理日志，具有crash-safe能力，用户掉电或者故障恢复</td><td>binlog是逻辑日志，记录的所有逻辑操作，用于备份、主从复制</td></tr><tr><td>写入方式</td><td>循环写，日志大小固定，写满后需要刷脏页腾出空间再能再写</td><td>追加写，写满一个文件就会创建新的文件，保存全量日志</td></tr></tbody></table><h2 id="binlog日志格式"><a href="#binlog日志格式" class="headerlink" title="binlog日志格式"></a>binlog日志格式</h2><p>Binlog 支持三种日志格式，用户可以根据需要进行配置：</p><ul><li><strong>STATEMENT</strong>：记录 SQL 语句。这种方式体积小，但在某些情况下（如含有不确定因素的函数）可能无法精确重放。（STATEMENT 有动态函数的问题，比如你用了 uuid 或者 now 这些函数，你在主库上执行的结果并不是你在从库执行的结果，这种随时在变的函数会导致复制的数据不一致）</li><li><strong>ROW</strong>：记录行级别的变化。每次修改记录的具体行的变化，更加精确，但日志体积较大。比如执行批量 update 语句，更新多少行数据就会产生多少条记录，使 binlog 文件过大，而在 STATEMENT 格式下只会记录一个 update 语句而已</li><li><strong>MIXED</strong>：结合了 STATEMENT 和 ROW 的优点，根据具体情况自动选择日志格式。</li></ul><h2 id="主从复制"><a href="#主从复制" class="headerlink" title="主从复制"></a>主从复制</h2><p><img src="https://gxc-hexo-blog.oss-cn-beijing.aliyuncs.com/blog/mysql_master_slave_copy.png"></p><p>MySQL主从复制依赖binlog。master服务器将数据的改变记录二进制日志，当master上的数据发生改变时，则将其改变写入二进制日志中，salve服务器会在一定时间间隔内对master二进制日志进行探测其是否发生改变，如果发生改变，则开始一个I&#x2F;OThread请求master二进制事件，同时主节点为每个I&#x2F;O线程启动一个dump线程，用于向其发送二进制事件，并保存至从节点本地的中继日志中，从节点将启动SQL线程从中继日志中读取二进制日志，在本地重放，使得其数据和主节点的保持一致，最后I&#x2F;OThread和SQLThread将进入睡眠状态，等待下一次被唤醒。</p><h2 id="binlog刷盘时机"><a href="#binlog刷盘时机" class="headerlink" title="binlog刷盘时机"></a>binlog刷盘时机</h2><img src="https://gxc-hexo-blog.oss-cn-beijing.aliyuncs.com/blog/binlog_cache.png" style="zoom:20%;" /><p>在每次事务执行过程中，会把日志写到缓存（binlog cache）中，提交时，MySQL会根据<code>sync_binlog</code>参数决定是否立刻刷盘。</p><table><thead><tr><th>值</th><th>刷盘频率</th></tr></thead><tbody><tr><td>0</td><td>每次提交事务，只会调用write将日志写入文件，没有经过 fsync()，后续由操作系统决定数据什么时候写入磁盘</td></tr><tr><td>1</td><td>每次事务提交时，MySQL 都会将 Binlog 从缓存中写入到磁盘，并调用 <code>fsync()</code> 确保数据被持久化到磁盘。</td></tr><tr><td>N(N &gt; 1)</td><td>每提交 <code>sync_binlog</code> 次事务才将 Binlog 刷盘一次。</td></tr></tbody></table><p>MySQL中默认是0，这时候性能比较好，但是风险也比较大。一旦机器宕机或者服务崩溃，还没刷到磁盘的数据就没了。</p><p>如果在MySQL出现了性能瓶颈，且瓶颈在IO上，可以将 sync_binlog 设置为大于 1 的值（比较常见是 100~1000）。这样做的风险是，主机掉电时会丢 binlog 日志。</p><h1 id="两阶段提交"><a href="#两阶段提交" class="headerlink" title="两阶段提交"></a>两阶段提交</h1><h2 id="什么是两阶段提交"><a href="#什么是两阶段提交" class="headerlink" title="什么是两阶段提交"></a>什么是两阶段提交</h2><p><strong>两阶段提交（Two-Phase Commit，2PC）</strong> 是一种分布式事务协议，用于确保分布式系统中的多个节点能够一致地执行事务。它通过两个阶段的操作（准备阶段和提交阶段）来确保所有参与节点都能达成一致，要么全部提交事务，要么全部回滚事务。以下是对两阶段提交的详细解释：</p><p>两阶段提交的步骤：</p><p>阶段一：准备阶段（Prepare Phase）</p><ol><li><strong>事务协调者（Transaction Coordinator）</strong> 向所有参与者（Participants）发送准备请求（Prepare Request），询问它们是否可以执行并准备提交事务。</li><li><strong>参与者</strong> 在接收到准备请求后，执行本地事务的预处理操作，但不提交（只是准备好提交）。然后，参与者将预处理的结果（准备好或失败）反馈给事务协调者。</li></ol><p>阶段二：提交阶段（Commit Phase）</p><ol><li><strong>事务协调者</strong> 收集所有参与者的反馈：<ul><li>如果所有参与者都准备好了，事务协调者向所有参与者发送提交请求（Commit Request），要求它们正式提交事务。</li><li>如果任何一个参与者反馈失败，事务协调者向所有参与者发送回滚请求（Rollback Request），要求它们回滚之前的预处理操作。</li></ul></li><li><strong>参与者</strong> 在接收到提交请求后，正式提交事务；在接收到回滚请求后，回滚事务。</li></ol><h2 id="两阶段提交在-MySQL-中的应用"><a href="#两阶段提交在-MySQL-中的应用" class="headerlink" title="两阶段提交在 MySQL 中的应用"></a>两阶段提交在 MySQL 中的应用</h2><p>在 MySQL 中，两阶段提交用于确保 Binlog 和 InnoDB 的事务日志（redo log）的一致性。这种机制确保了在 MySQL 主从复制中，即使在崩溃恢复的情况下，主从服务器的数据也能保持一致。</p><p>MySQL 两阶段提交的具体过程</p><ol><li><p><strong>准备阶段</strong>：</p><ul><li>InnoDB 存储引擎将事务的变更记录写入 redo log，并标记为准备提交（prepare）。</li></ul></li><li><p><strong>提交阶段</strong>：</p><ul><li><p>MySQL 服务器将事务的变更写入 Binlog，如果 Binlog 写入成功，InnoDB 将 redo log 标记为已提交。</p></li><li><p>如果 Binlog 写入失败，InnoDB 将 redo log 回滚。</p></li></ul></li></ol><h2 id="为什么需要两阶段提交"><a href="#为什么需要两阶段提交" class="headerlink" title="为什么需要两阶段提交"></a>为什么需要两阶段提交</h2><p>事务提交后，redo log和binlog都需要持久化到磁盘，但这是两个独立的逻辑，可能出现半成功的状态，造成两份日志的不一致。而redo log影响主库的数据，binlog影响从库的数据，所以redo log和binlog必须保持一致，才能保证主从数据一致。</p>]]></content>
    
    
    <categories>
      
      <category>MySQL</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MySQL</tag>
      
      <tag>数据库</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MySQL锁</title>
    <link href="/2024/07/01/MySQL%E9%94%81/"/>
    <url>/2024/07/01/MySQL%E9%94%81/</url>
    
    <content type="html"><![CDATA[<h1 id="MySQL锁的分类"><a href="#MySQL锁的分类" class="headerlink" title="MySQL锁的分类"></a>MySQL锁的分类</h1><p>根据加锁的范围，可以分为：</p><ul><li>全局锁</li><li>表级锁</li><li>行级锁</li></ul><p>其中表锁种又有：</p><ul><li>表锁</li><li>元数据锁</li><li>意向锁</li><li>AUTO-INC锁</li></ul><p>行锁有：</p><ul><li>记录锁（Record Lock）</li><li>间隙锁（Gap Lock）</li><li>临键锁（Next Key Lock）</li></ul><h1 id="全局锁"><a href="#全局锁" class="headerlink" title="全局锁"></a>全局锁</h1><p>加上全局锁，整个数据库就都是只读状态了。当会话断开后，全局锁会被自动释放。</p><p>一般用于全库逻辑备份。</p><p>加锁：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">flush tables <span class="hljs-keyword">with</span> read lock<br></code></pre></td></tr></table></figure><p>释放锁：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">unlock tables<br></code></pre></td></tr></table></figure><p>慎用！加上全局锁后，整个数据库就都是只读状态，此时业务只能读数据，不能更新数据，可能会造成业务停滞。</p><p>在可重复读的隔离级别下，如果在备份数据库前开启事务，就会创建Read View，在MVCC下，备份期间依然可以对数据进行更新操作，不影响其他事务。在使用mysqldump 进行备份时，加上 <code>–single-transaction</code>就可以开启事务。但是这种方法仅适用于 可重复读隔离级别的事务 的存储引擎。</p><h1 id="表级锁"><a href="#表级锁" class="headerlink" title="表级锁"></a>表级锁</h1><h2 id="表锁"><a href="#表锁" class="headerlink" title="表锁"></a>表锁</h2><p>表锁有两种：共享锁（读锁）、独占锁（写锁）</p><p>示例：对表T加表锁</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">/</span><span class="hljs-operator">/</span>共享锁<br>lock tables T read;<br><span class="hljs-operator">/</span><span class="hljs-operator">/</span>独占锁<br>lock tables T write;<br></code></pre></td></tr></table></figure><p>表锁不但会限制别的线程的读写，还会限制本线程的读写。</p><p>例如，对表T加了 共享锁 ，那么本线程和其他线程接下来的写操作也会被阻塞。</p><p>释放表锁：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">unlock tables;<br></code></pre></td></tr></table></figure><h2 id="元数据锁"><a href="#元数据锁" class="headerlink" title="元数据锁"></a>元数据锁</h2><p>我们不需要显示的使用元数据锁（MDL），因为当我们在对数据库进行操作时，会自动给这个表加上元数据锁（MDL）：</p><ul><li><p>对一张表进行CURD的操作时，加的是MDL读锁</p></li><li><p>对一张表结构进行变更操作的时候，加的是MDL写锁</p></li></ul><p>元数据锁是为了保证一个线程对表进行CURD操作时，另一个线程对表结构进行了变更。</p><p>当我们开启一个事务的时候，就会默认加上元数据锁，当事务提交或者回滚之后，锁才会释放。</p><p>下面看这样一个场景：</p><ul><li>线程a开启了一个事务，一直没有结束，执行的是CURD操作，所以对表加上了MDL读锁</li><li>线程b也开启一个事务，执行CURD操作，此时不会阻塞，因为「读读共享」</li><li>线程c修改表结构，但是由于线程a一直没有提交，线程a的MDL读锁没有释放，就会导致线程c阻塞</li></ul><p>在线程c阻塞之后，后续所有对该表进行CURD的操作都会阻塞。</p><p>因为申请MDL锁会形成一个队列，<strong>写锁优先级高于读锁</strong>，当写锁等待，就会阻塞后续所有的CURD操作。</p><p>所以在对表结构进行变更前，先检查下有没有长事务，若有长事务，考虑kill掉或是等待执行完毕。</p><h2 id="意向锁"><a href="#意向锁" class="headerlink" title="意向锁"></a>意向锁</h2><p>意向锁（Intention Locks）主要目的是为了支持在不同粒度级别上并发控制的需求，即表级锁和行级锁的混合使用。意向锁包括以下几种类型：</p><ol><li><strong>意向共享锁（Intention Shared Lock，IS）</strong>：表示事务想要在表中的某些行上加共享锁。在使用 InnoDB 引擎的表里对某些记录加上「共享锁」之前，需要先在表级别加上一个「意向共享锁」</li><li><strong>意向独占锁（Intention Exclusive Lock，IX）</strong>：表示事务想要在表中的某些行上加独占锁。在使用 InnoDB 引擎的表里对某些纪录加上「独占锁」之前，需要先在表级别加上一个「意向独占锁」</li></ol><p>意向锁的作用是提前在表级别上标记一个事务将要在某些行上进行锁操作，从而避免在表级和行级锁之间产生冲突。具体来说，当一个事务在某行上加锁时，它会首先在表级别上加一个意向锁，以表明它在表中的某些行上持有或计划持有某种锁，当其他事务要加表锁的时候，就可以快速判断是否可以加锁，而不需要扫描整个表的锁信息来确保没有冲突的存在。</p><p>加锁方式</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">/</span><span class="hljs-operator">/</span>先在表上加上意向共享锁，然后对读取的记录加共享锁<br><span class="hljs-keyword">select</span> ... lock <span class="hljs-keyword">in</span> share mode;<br><br><span class="hljs-operator">/</span><span class="hljs-operator">/</span>先表上加上意向独占锁，然后对读取的记录加独占锁<br><span class="hljs-keyword">select</span> ... <span class="hljs-keyword">for</span> <span class="hljs-keyword">update</span>;<br></code></pre></td></tr></table></figure><p>意向锁是表级锁，不会和行级别的共享锁和独占锁发生冲突，但是会和共享表锁、独占表锁发生冲突，具体兼容性如下表：</p><table><thead><tr><th></th><th>IS</th><th>IX</th><th>S</th><th>X</th></tr></thead><tbody><tr><td>IS</td><td>Y</td><td>Y</td><td>Y</td><td>N</td></tr><tr><td>IX</td><td>Y</td><td>Y</td><td>N</td><td>N</td></tr><tr><td>S</td><td>Y</td><td>N</td><td>Y</td><td>N</td></tr><tr><td>X</td><td>N</td><td>N</td><td>N</td><td>N</td></tr></tbody></table><p>举个例子：</p><p>假设有一个表 <code>orders</code>，其中有若干行记录。现在有三个事务同时操作该表：</p><ul><li><strong>事务1</strong> 要读取行1和行2的数据。</li><li><strong>事务2</strong> 要更新行3的数据。</li><li><strong>事务3</strong> 要对整个表进行备份。</li></ul><p>具体的锁操作如下：</p><ol><li>事务1：<ul><li>在表 <code>orders</code> 上加 IS 锁。</li><li>在行1和行2上加 S 锁。</li></ul></li><li>事务2：<ul><li>在表 <code>orders</code> 上加 IX 锁。</li><li>在行3上加 X 锁。</li></ul></li><li>事务3：<ul><li>在表 <code>orders</code> 上加 S 锁（对整个表进行共享访问，可能是备份操作）。</li></ul></li></ol><p><strong>冲突检查过程</strong></p><ul><li><strong>事务1</strong> 和 <strong>事务2</strong> 在表级别加的 IS 锁和 IX 锁是兼容的，可以同时存在。</li><li>当 <strong>事务3</strong> 尝试在表 <code>orders</code> 上加 S 锁时，数据库系统会检查当前表上的锁状态，发现表上已经有 IX 锁（由事务2 持有）。由于 S 锁和 IX 锁是不兼容的，<strong>事务3</strong> 必须等待 <strong>事务2</strong> 释放 IX 锁。</li></ul><h2 id="AUTO-INC锁"><a href="#AUTO-INC锁" class="headerlink" title="AUTO-INC锁"></a>AUTO-INC锁</h2><p>AUTO-INC锁（自动递增锁）是MySQL在使用<code>AUTO_INCREMENT</code>列时为了确保自增值唯一性和顺序性而使用的一种特殊锁。它主要用于控制并发插入操作，以保证每个插入操作都能获得唯一且递增的自增值。</p><p>表里的主键通常都会设置成自增的，这是通过对主键字段声明 <code>AUTO_INCREMENT</code> 属性实现的。之后可以在插入数据时，可以不指定主键的值，数据库会自动给主键赋值递增的值，这主要是通过 <strong>AUTO-INC 锁</strong>实现的。</p><h3 id="AUTO-INC锁的工作原理"><a href="#AUTO-INC锁的工作原理" class="headerlink" title="AUTO-INC锁的工作原理"></a>AUTO-INC锁的工作原理</h3><p>当一个表包含一个<code>AUTO_INCREMENT</code>列时，MySQL在执行插入操作时会申请一个AUTO-INC锁。这个锁的作用是确保在并发插入操作中，每个插入操作获得的自增值都是唯一且按顺序递增的。具体过程如下：</p><ol><li><strong>申请AUTO-INC锁</strong>：<ul><li>当事务要向包含AUTO_INCREMENT列的表插入一行时，首先需要获取AUTO-INC锁。</li></ul></li><li><strong>分配自增值</strong>：<ul><li>获得AUTO-INC锁后，MySQL从当前的自增值计数器中分配一个新的自增值给该插入操作。</li></ul></li><li><strong>释放AUTO-INC锁</strong>：<ul><li>插入操作完成后，事务释放AUTO-INC锁，允许其他事务继续进行插入操作。</li></ul></li></ol><h3 id="AUTO-INC锁的类型和范围"><a href="#AUTO-INC锁的类型和范围" class="headerlink" title="AUTO-INC锁的类型和范围"></a>AUTO-INC锁的类型和范围</h3><ul><li><strong>表级锁</strong>：AUTO-INC锁是表级锁，而不是行级锁。这意味着当一个事务持有AUTO-INC锁时，其他事务不能向同一个表插入数据，直到该锁被释放。</li><li><strong>短期锁</strong>：AUTO-INC锁是短期锁，<strong>仅在分配自增值的过程中持有</strong>。这使得插入操作不会因为等待自增值分配而长期阻塞。</li></ul><h3 id="AUTO-INC锁的并发控制"><a href="#AUTO-INC锁的并发控制" class="headerlink" title="AUTO-INC锁的并发控制"></a>AUTO-INC锁的并发控制</h3><p>AUTO-INC锁通过以下机制控制并发插入操作：</p><ol><li><strong>串行化插入操作</strong>：<ul><li>由于AUTO-INC锁是表级锁，所有向包含AUTO_INCREMENT列的表插入数据的操作在分配自增值时都是串行化的。这确保了自增值的唯一性和顺序性。</li></ul></li><li><strong>减少锁竞争</strong>：<ul><li>AUTO-INC锁是短期锁，仅在分配自增值时持有，插入数据时立即释放。这减少了锁竞争的机会，提高了并发插入操作的效率。</li></ul></li></ol><h1 id="行级锁"><a href="#行级锁" class="headerlink" title="行级锁"></a>行级锁</h1><p>InnoDB引擎是支持行级锁的，MyISAM引擎不支持行级锁。</p><p>由于InnoDB支持行级锁，粒度更细，所以尽量使用行级锁而不是表锁。</p><p>在InnoDB中，由于默认的隔离级别是可重复读，所以支持Read View，读数据属于快照读，不需要加锁，但是也可以使用如下语句进行加锁：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">/</span><span class="hljs-operator">/</span>对读取的记录加共享锁<br><span class="hljs-keyword">select</span> ... lock <span class="hljs-keyword">in</span> share mode;<br><br><span class="hljs-operator">/</span><span class="hljs-operator">/</span>对读取的记录加独占锁<br><span class="hljs-keyword">select</span> ... <span class="hljs-keyword">for</span> <span class="hljs-keyword">update</span>;<br></code></pre></td></tr></table></figure><p>先说行级锁之间的兼容情况</p><table><thead><tr><th></th><th>X</th><th>S</th></tr></thead><tbody><tr><td>X</td><td>N</td><td>N</td></tr><tr><td>S</td><td>N</td><td>Y</td></tr></tbody></table><ul><li>当一个事务对一条记录加了 S 型记录锁后，其他事务也可以继续对该记录加 S 型记录锁（S 型与 S 锁兼容），但是不可以对该记录加 X 型记录锁（S 型与 X 锁不兼容）;</li><li>当一个事务对一条记录加了 X 型记录锁后，其他事务既不可以对该记录加 S 型记录锁（S 型与 X 锁不兼容），也不可以对该记录加 X 型记录锁（X 型与 X 锁不兼容）。</li></ul><p>在 MySQL 的 InnoDB 存储引擎中，行级锁主要包括记录锁（Record Lock）、间隙锁（Gap Lock）和临键锁（Next-Key Lock）。</p><h2 id="记录锁（Record-Lock）"><a href="#记录锁（Record-Lock）" class="headerlink" title="记录锁（Record Lock）"></a>记录锁（Record Lock）</h2><p>记录锁锁定的是索引记录本身，而不是间隙或范围。记录锁通常用于精确锁定某一行数据，以防止其他事务对该行进行并发修改。</p><p>示例：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">START</span> TRANSACTION;<br><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> orders <span class="hljs-keyword">WHERE</span> id <span class="hljs-operator">=</span> <span class="hljs-number">1</span> <span class="hljs-keyword">FOR</span> <span class="hljs-keyword">UPDATE</span>;<br></code></pre></td></tr></table></figure><p>上述查询会对 <code>id = 1</code> 的记录加一个排他锁（X锁），防止其他事务对该行进行修改。</p><h2 id="间隙锁（Gap-Lock）"><a href="#间隙锁（Gap-Lock）" class="headerlink" title="间隙锁（Gap Lock）"></a>间隙锁（Gap Lock）</h2><p>间隙锁锁定的是索引记录之间的间隙，而不是实际的索引记录。间隙锁用于防止其他事务在锁定间隙中插入新的行，以避免幻读现象。</p><p><strong>使用场景：</strong></p><p>间隙锁主要在可重复读（REPEATABLE READ）隔离级别下使用，当执行范围查询并加锁时，InnoDB 会使用间隙锁来锁定查询范围内的间隙。</p><p>示例：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">START</span> TRANSACTION;<br><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> orders <span class="hljs-keyword">WHERE</span> id <span class="hljs-operator">&gt;</span> <span class="hljs-number">5</span> <span class="hljs-keyword">AND</span> id <span class="hljs-operator">&lt;</span> <span class="hljs-number">10</span> <span class="hljs-keyword">FOR</span> <span class="hljs-keyword">UPDATE</span>;<br></code></pre></td></tr></table></figure><p>上述查询将锁定 <code>id</code> 为 5 和 10 之间的所有间隙，防止其他事务在这些间隙中插入新的行。</p><p>间隙锁的目的是防止间隙中插入新的行，所以是可以有多个事务，对同一个间隙加锁的，都是为了保证间隙中不会插入新行</p><h2 id="临键锁（Next-Key-Lock）"><a href="#临键锁（Next-Key-Lock）" class="headerlink" title="临键锁（Next-Key Lock）"></a>临键锁（Next-Key Lock）</h2><p>临键锁是记录锁和间隙锁的组合，用于锁定一个索引记录以及它前面的间隙。这种锁用于防止幻读现象，确保一致性读取。</p><p><strong>使用场景：</strong></p><p>临键锁在范围查询和单行查询中都可以使用，以确保查询范围内的所有记录和间隙都被锁定。</p><p>示例：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">START</span> TRANSACTION;<br><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> orders <span class="hljs-keyword">WHERE</span> id <span class="hljs-operator">=</span> <span class="hljs-number">7</span> <span class="hljs-keyword">FOR</span> <span class="hljs-keyword">UPDATE</span>;<br></code></pre></td></tr></table></figure><p>上述查询将锁定 <code>id = 7</code> 的记录及其前面的间隙。这意味着 <code>id = 7</code> 的记录和从 <code>id = 6</code> 到 <code>id = 7</code> 的间隙都被锁定，防止其他事务对这些区域进行插入、更新或删除操作。</p><p>虽然相同范围的间隙锁是多个事务相互兼容的，但对于记录锁，我们是要考虑 X 型与 S 型关系，X 型的记录锁与 X 型的记录锁是冲突的。</p><h2 id="插入意向锁（Insert-Intention-Lock）"><a href="#插入意向锁（Insert-Intention-Lock）" class="headerlink" title="插入意向锁（Insert Intention Lock）"></a>插入意向锁（Insert Intention Lock）</h2><p>一个事务在插入一条记录的时候，需要判断插入位置是否已被其他事务加了间隙锁（next-key lock 也包含间隙锁）。</p><p>如果有的话，插入操作就会发生<strong>阻塞</strong>，直到拥有间隙锁的那个事务提交为止（释放间隙锁的时刻），在此期间会生成一个<strong>插入意向锁</strong>，表明有事务想在某个区间插入新记录，但是现在处于等待状态。</p><p>插入意向锁名字虽然有意向锁，但是它并<strong>不是意向锁，它是一种特殊的间隙锁，属于行级别锁</strong>。</p><h3 id="插入意向锁的工作原理"><a href="#插入意向锁的工作原理" class="headerlink" title="插入意向锁的工作原理"></a>插入意向锁的工作原理</h3><ol><li><strong>获取间隙锁</strong>：当一个事务尝试在某个索引间隙中插入一条新记录时，它首先会获取一个插入意向锁。这是一个特殊类型的间隙锁，用于表示该事务计划在这个间隙中插入一条记录。</li><li><strong>允许并发插入</strong>：插入意向锁是互相兼容的，这意味着多个事务可以同时在同一个索引间隙中获取插入意向锁。这允许多个插入操作并发进行，而不会互相阻塞。</li><li><strong>实际插入</strong>：当事务实际插入记录时，插入意向锁会升级为插入操作所需的具体锁（如记录锁）。如果插入的位置已经被其他事务锁定（例如，被一个排他锁锁定），插入操作将等待直到锁被释放。</li></ol><h1 id="MySQL是怎样加锁的"><a href="#MySQL是怎样加锁的" class="headerlink" title="MySQL是怎样加锁的"></a>MySQL是怎样加锁的</h1><p>行锁加锁的对象是索引，加锁的基本单位是 next-key lock，它是由记录锁和间隙锁组合而成的，next-key lock是前开后闭区间，而间隙锁是前开后开区间。</p><p>但是在记录锁或者间隙锁就能避免幻读时， next-key lock就会退化成记录锁或者间隙锁。</p><p>加锁位置实在主键索引上的，如果是用二级索引（不管是不是非唯一索引，还是唯一索引）进行锁定读查询的时候，除了会对二级索引项加行级锁（如果是唯一索引的二级索引，加锁规则和主键索引的案例相同），而且还会对查询到的记录的主键索引项上加「记录锁」。</p><p>具体如何退化，以如下四个场景来介绍</p><h2 id="唯一索引等值查询"><a href="#唯一索引等值查询" class="headerlink" title="唯一索引等值查询"></a>唯一索引等值查询</h2><p>如果查询条件是基于唯一索引的等值查询，并且只锁定一行，临键锁会退化为记录锁。</p><p>当查询记录不存在时，在索引树找到第一条大于该查询记录的记录后，该记录的索引中的next-key lock，就会退化成间隙锁。</p><h2 id="唯一索引范围查询"><a href="#唯一索引范围查询" class="headerlink" title="唯一索引范围查询"></a>唯一索引范围查询</h2><p>对于使用唯一索引的范围查询，临键锁可能会退化为记录锁和间隙锁的组合，这取决于查询的具体范围和数据的分布。</p><p>情况一：针对「大于等于」的范围查询，因为存在等值查询的条件，那么如果等值查询的记录是存在于表中，那么该记录的索引中的 next-key 锁会退化成记录锁。</p><p>比如以下语句</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> users <span class="hljs-keyword">where</span> user_id <span class="hljs-operator">&gt;=</span> <span class="hljs-number">12</span>;<br></code></pre></td></tr></table></figure><p>当12存在的时候，对于该记录的临建锁就会退化成记录锁，当12不存在，就会给第一个大于12的值，假如说是13加上临键锁</p><p>情况二：针对「小于或者小于等于」的范围查询，要看条件值的记录是否存在于表中：</p><p>当条件值的记录不在表中，那么不管是「小于」还是「小于等于」条件的范围查询，扫描到终止范围查询的记录时，该记录的索引的 next-key 锁会退化成间隙锁，其他扫描到的记录，都是在这些记录的索引上加 next-key 锁。</p><p>当条件值的记录在表中，如果是「小于」条件的范围查询，扫描到终止范围查询的记录时，该记录的索引的 next-key 锁会退化成间隙锁，其他扫描到的记录，都是在这些记录的索引上加 next-key 锁；如果「小于等于」条件的范围查询，扫描到终止范围查询的记录时，该记录的索引 next-key 锁不会退化成间隙锁。其他扫描到的记录，都是在这些记录的索引上加 next-key 锁</p><h2 id="非唯一索引等值查询"><a href="#非唯一索引等值查询" class="headerlink" title="非唯一索引等值查询"></a>非唯一索引等值查询</h2><p>当查询条件是基于非唯一索引的查询时，InnoDB 通常会使用间隙锁来锁定索引记录之间的间隙，以防止幻读现象。非唯一索引无法精确锁定单个记录，因此需要锁定范围。</p><p>假如现在有表如下</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> orders (<br>    id <span class="hljs-type">INT</span> AUTO_INCREMENT,<br>    product_name <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">255</span>),<br>    quantity <span class="hljs-type">INT</span>,<br>    <span class="hljs-keyword">PRIMARY</span> KEY (id),<br>    INDEX (product_name)<br>);<br></code></pre></td></tr></table></figure><p>现在我们进行非唯一索引查询：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">START</span> TRANSACTION;<br><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> orders <span class="hljs-keyword">WHERE</span> product_name <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;Product A&#x27;</span> <span class="hljs-keyword">FOR</span> <span class="hljs-keyword">UPDATE</span>;<br></code></pre></td></tr></table></figure><p>在这个查询中：</p><ul><li>查询条件使用了非唯一索引 <code>product_name</code>。</li><li>InnoDB 需要锁定 <code>product_name = &#39;Product A&#39;</code> 的所有记录及其前后的间隙，防止其他事务插入新的 <code>product_name = &#39;Product A&#39;</code> 记录。</li><li>临键锁会退化为间隙锁（Gap Lock），以确保查询范围内的所有间隙都被锁定，防止幻读。</li></ul><p>当Porduct A不存在时，扫描到第一条不符合条件的二级索引记录，该二级索引的 next-key 锁会退化成间隙锁。</p><h2 id="非唯一索引的范围查询"><a href="#非唯一索引的范围查询" class="headerlink" title="非唯一索引的范围查询"></a>非唯一索引的范围查询</h2><p>非唯一索引范围查询，索引的 next-key lock 不会有退化为间隙锁和记录锁的情况</p>]]></content>
    
    
    <categories>
      
      <category>MySQL</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MySQL</tag>
      
      <tag>数据库</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MySQL事务</title>
    <link href="/2024/07/01/MySQL%E4%BA%8B%E5%8A%A1/"/>
    <url>/2024/07/01/MySQL%E4%BA%8B%E5%8A%A1/</url>
    
    <content type="html"><![CDATA[<h1 id="什么是事务"><a href="#什么是事务" class="headerlink" title="什么是事务"></a>什么是事务</h1><h2 id="事务的典型场景"><a href="#事务的典型场景" class="headerlink" title="事务的典型场景"></a>事务的典型场景</h2><p>我们在买东西的过程中，会涉及到转账这个动作。</p><p>假如我们要给卖家转账1500元。</p><p>那么这个过程中就涉及到了两个对数据库的操作：</p><ul><li>我们的账户余额减少1500元</li><li>卖家的账户余额增加1500元</li></ul><p>这两个操作是同时成功同时失败的，只要我们的账户余额减少，卖家的账户余额就会增加。</p><p>单独一个操作的成功或失败都是不合理的，比如说我们的账户余额减少了，而卖家的账户余额却没有增加。或者说我们的账户余额没有减少而卖家的账户余额还是增加了，这都是不合理的。</p><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>数据库事务是<strong>访问</strong>并可能<strong>更新</strong>数据库中各种数据项的一个<strong>程序执行单元</strong>，由一个有限的数据库<strong>操作序列</strong>构成。</p><h2 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h2><ol><li>为数据库操作提供了一个<strong>从失败中恢复到正常状态</strong>的方法，同时提供了数据库即使在<strong>异常状态下仍能保持一致性</strong>的方法</li><li>当多个应用程序在并发访问数据库时，可以<strong>在这些应用程序之间提供一个隔离方法，以防止彼此操作相互干扰</strong></li></ol><p><strong>成功情况下：</strong> 能将数据从一种状态变为另外一种状态，并且能够持久化</p><p><strong>异常情况下：</strong></p><ol><li>能将数据恢复到正常状态</li><li>要能保证一致性，包含数据的一致性和约束的一致性</li></ol><p><strong>并发情况下：</strong> 并发的操作之间不能产生相互影响</p><h1 id="事务的使用"><a href="#事务的使用" class="headerlink" title="事务的使用"></a>事务的使用</h1><h2 id="事务的开启"><a href="#事务的开启" class="headerlink" title="事务的开启"></a>事务的开启</h2><p>首先，当我们在执行单条增删改语句时，会自动开启事务并且会自动提交，所以最终写入了磁盘</p><p>或者手动开启事务，两种方式：</p><ol><li>begin</li><li>start transaction</li></ol><h2 id="事务的结束"><a href="#事务的结束" class="headerlink" title="事务的结束"></a>事务的结束</h2><p>首先，如果客户端断开连接了，自然就会结束事务</p><p>或者手动结束事务：</p><ol><li>回滚事务，使用 rollback</li><li>提交事务，使用 commit</li></ol><hr><p><strong>理论有效，实践开始</strong></p><p>首先创建一张表，并插入数据</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> bank(<br>name <span class="hljs-type">varchar</span>(<span class="hljs-number">20</span>),<br>money <span class="hljs-type">decimal</span>(<span class="hljs-number">5</span>,<span class="hljs-number">1</span>)<br>);<br><br> <span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> bank <span class="hljs-keyword">values</span><br> (<span class="hljs-string">&#x27;i&#x27;</span>,<span class="hljs-number">5000</span>),<br> (<span class="hljs-string">&#x27;store&#x27;</span>,<span class="hljs-number">50000</span>); <br><br></code></pre></td></tr></table></figure><p>查询该表就可以看到数据</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> bank;<br><br><span class="hljs-operator">/</span><span class="hljs-operator">/</span> 数据如下<br><span class="hljs-operator">+</span><span class="hljs-comment">-------+--------+</span><br><span class="hljs-operator">|</span>  name <span class="hljs-operator">|</span> money  <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">-------+--------+</span><br><span class="hljs-operator">|</span>   i   <span class="hljs-operator">|</span> <span class="hljs-number">5000</span>   <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">-------+--------+</span><br><span class="hljs-operator">|</span> store <span class="hljs-operator">|</span> <span class="hljs-number">500000</span> <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">-------+--------+</span><br><br></code></pre></td></tr></table></figure><p>那么让我们开启事务并进行转账</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs shell">//开启事务<br>begin;<br>// 成功会提示<br>// Query OK, 0 rows affected (0.00 sec) <br><br>update bank set money=money-1500 where name=&#x27;i&#x27;;<br>//成功会提示<br>//Query OK, 1 row affected (0.00 sec) <br>//Rows matched: 1 Changed: 1 Warnings: 0 <br><br>// 此时打开另一个终端查询表中数据是没有变化的，因为还没有提交<br><br>update bank set money=money+1500 where name=&#x27;store&#x27;;<br><br>// 提交之后在另一个终端就可以看到此时数据才发生变化<br>// 或者此处用 rollback 就可以看到数据不会变化<br>commit;<br></code></pre></td></tr></table></figure><h1 id="事务的特性"><a href="#事务的特性" class="headerlink" title="事务的特性"></a>事务的特性</h1><p>原子性： 事务作为一个整体被执行，包含在其中的对数据库的操作要么全部被执行，要么都不执行</p><p>一致性： 事务应确保数据库的状态从一个一致状态转变为另一个一致状态。一致状态的含义是数据库中的数据应满足完整性约束</p><p>隔离性： 多个事务并发执行时，一个事务的执行不应影响其他事务的执行</p><p>持久性： 一个事务一旦提交，他对数据库的修改应该永久保存在数据库中</p><h2 id="事务的并发异常"><a href="#事务的并发异常" class="headerlink" title="事务的并发异常"></a>事务的并发异常</h2><h3 id="回滚丢失-第一类更新丢失"><a href="#回滚丢失-第一类更新丢失" class="headerlink" title="回滚丢失&#x2F;第一类更新丢失"></a>回滚丢失&#x2F;第一类更新丢失</h3><p>此种更新丢失的是因为回滚的原因，所以也叫回滚丢失</p><table><thead><tr><th>事务A</th><th>事务B</th></tr></thead><tbody><tr><td>查询数据值得到初始值10</td><td>查询数据得到初始值10</td></tr><tr><td>更新为10+1&#x3D;11</td><td>更新为10+2&#x3D;12</td></tr><tr><td>提交</td><td>回滚失败</td></tr><tr><td></td><td>数据回到初始状态10，导致事务A的更新丢失了，由于回滚导致丢失所以叫做回滚丢失</td></tr></tbody></table><h3 id="覆盖丢失-第二类更新丢失"><a href="#覆盖丢失-第二类更新丢失" class="headerlink" title="覆盖丢失&#x2F;第二类更新丢失"></a>覆盖丢失&#x2F;第二类更新丢失</h3><p>此种更新丢失是因为更新被其他事务给覆盖了，也可以叫覆盖丢失</p><table><thead><tr><th>事务A</th><th>事务B</th></tr></thead><tbody><tr><td>查询数据得到初始值10</td><td>查询数据得到初始值10</td></tr><tr><td>更新10+1&#x3D;11</td><td>更新10+2&#x3D;12</td></tr><tr><td>提交</td><td>提交</td></tr><tr><td></td><td>最终结果变为12，由于事务B是从10开始计算的，并不知道数据已经发生了变化，所以导致事务A的更新结果被覆盖了，所以叫覆盖更新</td></tr></tbody></table><h3 id="脏读"><a href="#脏读" class="headerlink" title="脏读"></a>脏读</h3><p>此种异常是因为一个事务读取了，另一个事务修改了但是未提交的数据</p><table><thead><tr><th>事务A</th><th>事务B</th></tr></thead><tbody><tr><td>查询数据得到初始值10</td><td>查询数据得到初始值10</td></tr><tr><td>更新为10+1&#x3D;11</td><td>再次读取数值的到11</td></tr><tr><td></td><td>更新数据11+1&#x3D;12</td></tr><tr><td>回滚</td><td>提交</td></tr><tr><td></td><td>最终数据变为12，由于读取到的数据11被回滚了，结果是错误的，读取到了脏数据</td></tr></tbody></table><h3 id="不可重复读"><a href="#不可重复读" class="headerlink" title="不可重复读"></a>不可重复读</h3><p>一个事务对同一行数据执行了两次或更多次查询，但是却得到了不同的结果</p><table><thead><tr><th>事务A</th><th>事务B</th></tr></thead><tbody><tr><td>查询数据得到初始值10</td><td>查询数据得到初始值10</td></tr><tr><td>更新为10+1&#x3D;11</td><td>再次读取数据得到11</td></tr><tr><td></td><td>在一个事务内两次对同一条数据查询，得到的结果是不同的，因此叫做不可重复读</td></tr></tbody></table><h3 id="幻读"><a href="#幻读" class="headerlink" title="幻读"></a>幻读</h3><p>幻读和不可重复读有点像，只是针对的不是数据的值而是数据的数量</p><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td>事务A</td><td>事务B</td></tr><tr><td>查询数据有11条</td><td>查询数据有11条</td></tr><tr><td>更新全部数据为1</td><td>插入一条数据</td></tr><tr><td>查询结果有1条没被更新，比原来多了一条</td><td></td></tr><tr><td>仿佛全表更新语句不正常，自己出现了幻觉，因此叫幻读</td><td></td></tr></tbody></table><h1 id="事务的隔离级别"><a href="#事务的隔离级别" class="headerlink" title="事务的隔离级别"></a>事务的隔离级别</h1><p><strong>读未提交：</strong> 该隔离级别指即使一个事务更新语句没有提交，但是别的事务可以读到这个改变</p><p><strong>读已提交：</strong> 指一个事务只能看到其他事务的已经提交的更新，看不到未提交的更新，消除了脏读和第一类丢失更新，这是大多数数据库的默认隔离级别，如Oracle SqlServer</p><p><strong>可重复读：</strong> 该隔离级别指一个事务中进行两次或多次同样的对于数据内容的查询，得到的结果是一样的，但不保证对于数据条数的查询是一样的，只要存在读，该行数据就禁止写，消除了不可重复读和第二类更新丢失，这是MySql数据库的默认隔离级别</p><p><strong>串行化：</strong> 事务执行的时候不允许别的事务并发执行，完全串行化的读，只要存在读就禁止写，但可以同时读，消除了幻读。这是事务隔离级别的最高级别。虽然最安全最省心，但是效率太低，一般不会用</p><h2 id="各种隔离级别能解决哪些并发异常"><a href="#各种隔离级别能解决哪些并发异常" class="headerlink" title="各种隔离级别能解决哪些并发异常"></a>各种隔离级别能解决哪些并发异常</h2><table><thead><tr><th>隔离级别 \ 并发异常</th><th>回滚丢失</th><th>脏读</th><th>不可重复读</th><th>覆盖丢失</th><th>幻读</th></tr></thead><tbody><tr><td>读未提交</td><td>×</td><td>×</td><td>×</td><td>×</td><td>×</td></tr><tr><td>读已提交</td><td>√</td><td>√</td><td>×</td><td>×</td><td>×</td></tr><tr><td>可重复读</td><td>√</td><td>√</td><td>√</td><td>√</td><td>×</td></tr><tr><td>串行化</td><td>√</td><td>√</td><td>√</td><td>√</td><td>√</td></tr></tbody></table><h2 id="mysql为什么选择-可重复读-为默认隔离级别"><a href="#mysql为什么选择-可重复读-为默认隔离级别" class="headerlink" title="mysql为什么选择 可重复读 为默认隔离级别"></a>mysql为什么选择 可重复读 为默认隔离级别</h2><p>首先说一些 mysql InnoDB对隔离级别的支持</p><table><thead><tr><th>事务隔离级别</th><th>脏读</th><th>不可重复读</th><th>幻读</th></tr></thead><tbody><tr><td>读未提交（Read Uncommitted）</td><td>可能</td><td>可能</td><td>可能</td></tr><tr><td>读已提交（Read Committed</td><td>不可能</td><td>可能</td><td>可能</td></tr><tr><td><strong>可重复读（Repeatable Read）</strong></td><td>不可能</td><td>不可能</td><td>对InnoDB不可能</td></tr><tr><td>串行化（Serializable）</td><td>不可能</td><td>不可能</td><td>不可能</td></tr></tbody></table><p>InnoDB 支持的四个隔离级别和 SQL92 定义的完全一致，隔离级别越高事务的并发度就越低。唯一的区别就在于，InnoDB在 RR 的级别就解决了幻读的问题。也就是说，不需要使用串行化的隔离级别就可以解决所有问题，既保证了数据的一致性，又支持较高的并发度。这个就是 InnoDB 默认使用 RR 作为事务隔离级别的原因。</p><p>MySQL解决幻读的方案有两种：</p><ul><li>针对<strong>快照读</strong>（普通 select 语句），是<strong>通过 MVCC 方式解决了幻读</strong>，因为可重复读隔离级别下，事务执行过程中看到的数据，一直跟这个事务启动时看到的数据是一致的，即使中途有其他事务插入了一条数据，是查询不出来这条数据的，所以就很好了避免幻读问题。</li><li>针对<strong>当前读</strong>（select … for update 等语句），是<strong>通过 next-key lock（记录锁+间隙锁）方式解决了幻读</strong>，因为当执行 select … for update 语句的时候，会加上 next-key lock，如果有其他事务在 next-key lock 锁范围内插入了一条记录，那么这个插入语句就会被阻塞，无法成功插入，所以就很好了避免幻读问题。</li></ul><h1 id="mysql是如何实现事务的提交、回滚，怎样保证数据的一致性？"><a href="#mysql是如何实现事务的提交、回滚，怎样保证数据的一致性？" class="headerlink" title="mysql是如何实现事务的提交、回滚，怎样保证数据的一致性？"></a>mysql是如何实现事务的提交、回滚，怎样保证数据的一致性？</h1><p>首先说如何实现事务的提交和回滚<br>数据库为了保证事务的原子性和持久性，引入了 redo log和 undo log</p><p>redo log和 undo log包括两部分：一个是内存中的日志缓冲(redo log buffer &#x2F; undo log buffer)，另一个是磁盘上的日志文件(redo log file &#x2F; undo log file)。mysql每执行一条语句，先将记录写入redo log buffer &#x2F; undo log buffer，后续某个时间点再一次性将多个操作记录写到redo log file &#x2F; undo log file。</p><p>在计算机操作系统中，用户空间(user space)下的缓冲区数据一般情况下是无法直接写入磁盘的，中间必须经过操作系统内核空间(kernel space)缓冲区(OS Buffer)。因此，redo log buffer &#x2F; undo log buffer写入redo log file &#x2F; undo log file实际上是先写入OS Buffer，然后再通过系统调用fsync()将其刷到redo log file &#x2F; undo log file中，过程如下<br><img src="https://gxc-hexo-blog.oss-cn-beijing.aliyuncs.com/blog/mysql_log_buffer.png"></p><h2 id="redo-log"><a href="#redo-log" class="headerlink" title="redo log"></a>redo log</h2><p>redo log叫做重做日志，是用来实现事务的持久性。该日志文件由两部分组成：重做日志缓冲（redo log buffer）以及重做日志文件（redo log）,前者是在内存中，后者在磁盘中。当事务提交之后会把所有修改信息都会存到该日志中。</p><p>SQL操作数据库之前，会先记录重做日志，为了保证效率会先写到日志缓冲区中（redo log Buffer），再通过缓冲区写到磁盘文件中进行持久化，既然有缓冲区说明数据不是实时写到redo log file中的，那么假如redo log写到缓冲区后，此时服务器断电了，那redo log岂不是会丢失？</p><p>在MySQL中可以自已控制log buffer刷新到log file中的频率，通过innodb_flush_log_at_trx_commit参数可以设置事务提交时log buffer如何保存到log file中，innodb_flush_log_at_trx_commit参数有3个值(0、1、2)，表示三种不同的方式</p><ul><li>为0表示事务提交时不会将log buffer写入到os buffer中，而是每秒写入os buffer然后调用fsync()方法将日志写入log file，这种方式在MySQL系统崩溃时会丢失大约1秒钟的数据</li><li>为1表示事务每次提交都会将log buffer写入到os buffer，并调用操作系统的fsync()方法将日志写入log file，这种方式的好处是就算MySQL崩溃也不会丢数据，redo log file保存了所有已提交事务的日志，MySQL重新启动后会通过redo log file进行恢复。但这种方式每次提交事务都会写入磁盘，IO性能较差</li><li>为2表示事务每次提交仅将log buffer写入到os buffer中，然后每秒调用fsync()方法将日志写入log file，这种方式在MySQL崩溃时也会丢失大约1秒钟的数据</li></ul><h2 id="undo-log"><a href="#undo-log" class="headerlink" title="undo log"></a>undo log</h2><p>undo log是回滚日志，用来回滚行记录到某个版本，undo log一般是逻辑日志，根据行的数据变化进行记录，可以简单的理解为：当insert一条记录时，undo log会记录一条对应的delete语句；当update一条语句时，undo log记录的是一条与之操作相反的语句</p><p>undo log跟redo log一样也是在SQL操作数据之前记录的，也就是SQL操作先记录日志，再进行操作数据</p><p>当事务需要回滚时，可以从undo log中找到相应的内容进行回滚操作，回滚后数据恢复到操作之前的状态</p><h2 id="保证数据一致性"><a href="#保证数据一致性" class="headerlink" title="保证数据一致性"></a>保证数据一致性</h2><p>如果要解决读一致性的问题，保证一个事务中前后两次读取数据结果一致，实现事务隔离，应该怎么做？</p><p>总体上来说，我们有两大类的方案。</p><p><strong>LBCC</strong><br>既然要保证前后两次读取数据一致，那么我读取数据的时候，锁定我要操作的数据，不允许其他的事务修改就行了。这种方案我们叫做基于锁的并发控制 Lock Based Concurrency Control（LBCC）。</p><p>如果仅仅是基于锁来实现事务隔离，一个事务读取的时候不允许其他时候修改，那就意味着不支持并发的读写操作，而我们的大多数应用都是读多写少的，这样会极大地影响操作数据的效率。</p><p><strong>MVCC</strong><br>如果要让一个事务前后两次读取的数据保持一致，那么我们可以再修改数据之前给它建立一个备份或者叫快照，后面再来读取这个快照就行了。这种方案我们叫做多版本的并发控制 Multi Version Concurrency Control（MVCC）。</p><p>MVCC只在 读已提交和可重复读两个隔离级别下工作。其他两个隔离级别和MVCC不兼容，因为 读未提交总是读取最新的数据行，而不是符合当前事务版本的数据行。而串行化则会对所有读取的行都加锁。</p><p>聚簇索引记录中有两个必要的隐藏列：</p><ul><li><p>trx_id：用来存储每次对某条聚簇索引记录进行修改的时候的事务id</p></li><li><p>roll_pointer：每次对哪条聚簇索引记录有修改的时候，都会把老版本写入 undo 日志中。这个roll_pointer就是存了一个指针，它指向这条聚簇索引记录的上一个版本的位置，通过它来获得上一个版本的记录信息（注意插入操作的 undo操作日志没有这个属性，因为它没有老版本）</p></li></ul><p>MVCC 的原则：<br>一个事务能看到的数据版本：</p><ul><li>第一次查询之前已经提交的事务的修改</li><li>本事务的修改</li></ul><p>一个事务不能看到的数据版本：</p><ul><li>在本事务第一次查询之后创建的事务（事务 ID 比我的事务 ID 大）</li><li>活跃的（未提交的）事务的修改</li></ul><p>MVCC 的效果：我可以查到在我这个事务开始之前已经存在的数据，即使它在后面被修改或者删除了。而在我这个事务之后新增的数据，我是查不到的。</p><p>所以我们才把这个叫做快照，不管别的事务做任何增删改查的操作，它只能看到第一次查询时看到的数据版本。</p><blockquote><p>这个快照是怎么实现的呢？会不会占用额外的存储空间？</p></blockquote><p>下面我们来分析一下 MVCC 的原理。首先，InnoDB的事务都是有编号的，而且会不断递增。</p><p>InnoDB 为每行记录都实现了两个隐藏字段：</p><ul><li><p>DB_TRX_ID（6字节）：事务ID，数据是在哪个事务插入或者修改为新数据的，就记录为当前事务 ID。</p></li><li><p>DB_ROLL_PTR（7字节）：回滚指针（我们把它理解为删除版本号，数据被删除或记录为旧数据的时候，记录当前事务ID，没有修改或者删除的时候是空，注意插入操作的 undo操作日志没有这个属性，因为它没有老版本）</p></li></ul><p>拿个栗子来说，现在有一张表</p><table><thead><tr><th>id</th><th>name</th><th>DB_TRX_ID</th><th>DB_ROLL_PTR</th></tr></thead><tbody><tr><td></td><td></td><td></td><td></td></tr></tbody></table><p>第一个事务，初始化数据</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">begin</span>;<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> mvcctest <span class="hljs-keyword">values</span>(<span class="hljs-number">1</span>,<span class="hljs-string">&#x27;qingshan&#x27;</span>);<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> mvcctest <span class="hljs-keyword">values</span>(<span class="hljs-number">2</span>,<span class="hljs-string">&#x27;huihui&#x27;</span>);<br><span class="hljs-keyword">commit</span>;<br></code></pre></td></tr></table></figure><p>此时的数据，创建版本是当前事务ID（假设事务编号是1），删除版本为空</p><table><thead><tr><th>id</th><th>name</th><th>创建版本</th><th>删除版本</th></tr></thead><tbody><tr><td>1</td><td>唐三藏</td><td>1</td><td>undefined</td></tr><tr><td>2</td><td>孙悟空</td><td>1</td><td>undefined</td></tr></tbody></table><p>第二个事务，执行第一次查询，读取到两条原始数据，这个时候事务ID是2</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">begin</span>;<br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> mvcctest;  <span class="hljs-operator">/</span><span class="hljs-operator">/</span> 第一次查询<br></code></pre></td></tr></table></figure><p>第三个事务，插入数据</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">begin</span>;<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> mvcctest <span class="hljs-keyword">values</span>(<span class="hljs-number">3</span>,<span class="hljs-string">&#x27;猪八戒&#x27;</span>);<br><span class="hljs-keyword">commit</span>;<br></code></pre></td></tr></table></figure><p>此时的数据，多了一条猪八戒，他的创建版本号是当前事务id（3）</p><table><thead><tr><th>id</th><th>name</th><th>创建版本</th><th>删除版本</th></tr></thead><tbody><tr><td>1</td><td>唐三藏</td><td>1</td><td>undefined</td></tr><tr><td>2</td><td>孙悟空</td><td>1</td><td>undefined</td></tr><tr><td>3</td><td>猪八戒</td><td>3</td><td>undefined</td></tr></tbody></table><p>第二个事务，执行第二次查询</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> mvcctest;  <span class="hljs-operator">/</span><span class="hljs-operator">/</span> 第二次查询<br></code></pre></td></tr></table></figure><p>MVCC的查询规则：只能查找创建时间小于等于当前事务 ID 的数据，和删除时间大于当前事务 ID 的行（或未删除）。</p><p>也就是不能查到在我的事务开始之后插入的数据，猪八戒 的创建 ID 大于 2，所以还是只能查到两条数据。</p><p>第四个事务，删除数据，删除 id&#x3D;2，孙悟空这条记录</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">begin</span>;<br><span class="hljs-keyword">delete</span> <span class="hljs-keyword">from</span> mvcctest <span class="hljs-keyword">where</span> id<span class="hljs-operator">=</span><span class="hljs-number">2</span>;<br><span class="hljs-keyword">commit</span>;<br></code></pre></td></tr></table></figure><p>此时的数据，孙悟空 的删除版本被记录为当前事务 ID （4），其他数据不变：</p><table><thead><tr><th>id</th><th>name</th><th>创建版本</th><th>删除版本</th></tr></thead><tbody><tr><td>1</td><td>唐三藏</td><td>1</td><td>undefined</td></tr><tr><td>2</td><td>孙悟空</td><td>1</td><td>4</td></tr><tr><td>3</td><td>猪八戒</td><td>3</td><td>undefined</td></tr></tbody></table><p>在第二个事务中，执行第 3 次查询：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> mvcctest;  <span class="hljs-operator">/</span><span class="hljs-operator">/</span>第三次查询<br></code></pre></td></tr></table></figure><p>查找规则：只能查找创建时间小于等于当前事务 ID 的数据，和删除时间大于当前事务 ID 的行（或未删除）。</p><p>也就是，在我事务开始之后删除的数据，所以 孙悟空 依然可以查出来。所以还是这两条数据。</p><p>第五个事务，执行更新操作，这个事务 ID 是5：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">begin</span>;<br><span class="hljs-keyword">update</span> mvcctest <span class="hljs-keyword">set</span> name<span class="hljs-operator">=</span><span class="hljs-string">&#x27;杨过&#x27;</span> <span class="hljs-keyword">where</span> id<span class="hljs-operator">=</span><span class="hljs-number">1</span>;<br><span class="hljs-keyword">commit</span>;<br></code></pre></td></tr></table></figure><p>此时的数据，更新数据的时候，旧数据的删除版本被记录为当前事务 ID （5）（undo），产生了一条新数据，创建 ID 为当前事务 ID 5：</p><table><thead><tr><th>id</th><th>name</th><th>创建版本</th><th>删除版本</th></tr></thead><tbody><tr><td>1</td><td>唐三藏</td><td>1</td><td>5</td></tr><tr><td>2</td><td>孙悟空</td><td>1</td><td>4</td></tr><tr><td>3</td><td>猪八戒</td><td>3</td><td>undefined</td></tr><tr><td>1</td><td>杨过</td><td>5</td><td>undefined</td></tr></tbody></table><p>第二个事务，执行第 4 次查询：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> mvcctest;  <span class="hljs-operator">/</span><span class="hljs-operator">/</span>第四次查询<br></code></pre></td></tr></table></figure><p>查找规则：只能查找创建时间小于等于当前事务 ID 的数据，和删除时间大于当前事务 ID 的行（或未删除）。</p><p>因为更新后的数据 杨过 创建版本大于 2，代表是在事务之后增加的，查不出来。</p><p>而旧数据 孙悟空 的删除版本大于 2，代表是在事务之后删除的，可以查出来。</p><p>通过以上演示我们能看到，通过版本号的控制，无论其他事务是插入、修改、删除，第一个事务查询到的数据都没有变化。这个就是 MVCC 的效果。</p><p>回想一下MVCC规则：<br>一个事务能看到的数据版本：</p><ol><li>第一次查询之前已经提交的事务的修改</li><li>本事务的修改</li></ol><p>一个事务不能看见的数据版本：</p><ul><li>在本事务第一次查询之后创建的事务（事务 ID 比我的事务 ID 大）</li><li>活跃的（未提交的）事务的修改</li></ul><p>所以，我们必须要有一个数据结构，把本事务 ID、活跃事务 ID、当前系统最大事务 ID 存起来，这样才能实现判断。这个数据结果就叫 Read View（可见性视图），每个事务都维护一个自己的 Read View。</p><p><strong>m_ids：</strong> 表示在生成 ReadView 时，当前系统中活跃的读写事务的事务 id 列表。</p><p>min_trx_id： 表示在生成 ReadView 时，当前系统中活跃的读写事务中最小的事务 id，也就是 m_ids 中的最小值。</p><p><strong>max_trx_id：</strong> 表示生成 ReadView 时，系统中应该分配给下一个事务的 id 值。</p><p><strong>creator_trx_id：</strong> 表示生成该 ReadView 的事务的事务 id。</p><p>有了这个数据结构之后，事务判断可见性的规则是这样的：</p><ol><li>从数据的最早版本开始（undo log）。</li><li>数据版本的 trx_id &#x3D; creator_trx_id，本事务修改，可以访问。</li><li>数据版本的 trx_id &lt; min_trx_id（未提交事务的最小 ID），说明这个版本在生成 ReadView 已经提交，可以访问。</li><li>数据版本的 trx_id &gt; max_trx_id（下一个事务 ID），这个版本是生成 ReadView 之后才开启的事务建立的，不能访问。</li><li>数据版本的 trx_id 在 min_trx_id 和 max_trx_id 之间，看看是否在 m_ids 中。如果在，不可以。如果不在，可以。</li><li>如果当前版本不可见，就找 undo log 链中的下一个版本。</li></ol><p><strong>注意：</strong> RR 中 Read View 是事务第一次查询的时候建立的。RC 的 Read View 是事务每次查询的时候建立的。</p>]]></content>
    
    
    <categories>
      
      <category>MySQL</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MySQL</tag>
      
      <tag>数据库</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MySQL索引</title>
    <link href="/2024/06/24/MySQL%E7%B4%A2%E5%BC%95/"/>
    <url>/2024/06/24/MySQL%E7%B4%A2%E5%BC%95/</url>
    
    <content type="html"><![CDATA[<h1 id="什么是索引"><a href="#什么是索引" class="headerlink" title="什么是索引"></a>什么是索引</h1><p>当我们想查找书籍中特定的内容时就会想到，去翻目录，就能快速找到目标内容。书籍的目录就是<strong>索引</strong></p><p>在数据库中，索引的定义就是帮助存储引擎快速获取数据的一种数据结构，形象的说就是<strong>索引是数据的目录</strong></p><h1 id="InnoDB索引模型"><a href="#InnoDB索引模型" class="headerlink" title="InnoDB索引模型"></a>InnoDB索引模型</h1><p>在 InnoDB 中，表都是根据主键顺序以索引的形式存放的，这种存储方式的表称为索引组织表。InnoDB 使用了 B+ 树索引模型，所以数据都是存储在 B+ 树中的。</p><p>这里顺带说一下InnoDB的表结构：</p><ol><li>在 InnoDB 中，每一张表其实就是多个 B+ 树，即一个主键索引树和多个非主键索引树。</li><li>执行查询的效率，使用主键索引 &gt; 使用非主键索引 &gt; 不使用索引。</li><li>如果不使用索引进行查询，则从主索引 B+ 树的叶子节点进行遍历。</li></ol><p>每一个索引在 InnoDB 里面对应一棵 B+ 树。索引名称对应所有索引记录，对应一棵B+树，而不是单条记录。</p><p>假设现有一张表如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> T(<br>id <span class="hljs-type">bigint</span> <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span> auto_increment <span class="hljs-keyword">primary</span> key,<br>  name <span class="hljs-type">varchar</span>(<span class="hljs-number">32</span>) <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span> <span class="hljs-keyword">default</span> <span class="hljs-string">&#x27;&#x27;</span>,<br>  age <span class="hljs-type">int</span> <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span> <span class="hljs-keyword">default</span> <span class="hljs-number">0</span>,<br>  index idx_age(age)<br>)engine<span class="hljs-operator">=</span>InnoDB;<br></code></pre></td></tr></table></figure><p>表中 R1~R5 的 (id,age) 值分别为 (100,1)、(200,2)、(300,3)、(500,5) 和 (600,6)，两棵树的示例示意图如下。</p><p><img src="https://gxc-hexo-blog.oss-cn-beijing.aliyuncs.com/blog/mysql_index_model.png"></p><p>根据叶子结点的内容，索引类型分为了主键索引和非主键索引。</p><p>主键索引的叶子节点存的是整行数据。在 InnoDB 里，主键索引也被称为聚簇索引（clustered index）。 key:主键的值，value:整行数据。</p><p>非主键索引的叶子节点内容是主键的值。在 InnoDB 里，非主键索引也被称为二级索引（secondary index）。 key：索引列的值， value:主键的值。</p><p>基于逐渐索引和普通索引的查询有什么区别呢？</p><ul><li>如果语句是 <code>select * from T where id=100</code>，当使用主键索引进行查询的时候，只需要搜索id这颗b+树</li><li>如果语句是 <code>select * from T where age=3</code>，当使用普通索引查询时，先要搜索age索引树，查询到id为300，在用id索引树查到一次，这个过程称为<strong>回表</strong>（如果语句为 <code>select id from T where age=3</code>，这种在二级索引的B+tree就能查询到结果的过程就叫做<strong>覆盖索引</strong>，也就是只需要查一个B+tree就能找到数据）</li></ul><p>所以，基于非主键索引的查询需要多扫描一棵索引树。因此，我们应用中应该多使用主键查询。</p><h1 id="索引维护"><a href="#索引维护" class="headerlink" title="索引维护"></a>索引维护</h1><p>B+树为了维护索引的有序性，在插入新值的时候需要做必要的维护。以上图为例，如果插入的值是700，则只要在R5的记录后边插入一个新纪录。如果新插入的值是400，就麻烦了，需要逻辑上挪动后边的数据，空出位置。</p><p>而更糟的情况是，如果 R5 所在的数据页已经满了，根据 B+ 树的算法，这时候需要申请一个新的数据页，然后挪动部分数据过去。这个过程称为页分裂。在这种情况下，性能自然会受影响。</p><p>除了性能外，页分裂操作还影响数据页的利用率。原本放在一个页的数据，现在分到两个页中，整体空间利用率降低大约 50%。</p><p>当然有分裂就有合并。当相邻两个页由于删除了数据，利用率很低之后，会将数据页做合并。合并的过程，可以认为是分裂过程的逆过程。</p><p>在很多规范里边，都要求建表语句一定要有自增主键，但是事无绝对，也有一些场景不需要。</p><p>自增主键是指自增列上定义的主键，在建表语句中一般是这么定义的： NOT NULL PRIMARY KEY AUTO_INCREMENT。</p><p>插入新记录的时候可以不指定 ID 的值，系统会获取当前 ID 最大值加 1 作为下一条记录的 ID 值。</p><p>也就是说，自增主键的插入数据模式，正符合了我们前面提到的递增插入的场景。每次插入一条新记录，都是追加操作，都不涉及到挪动其他记录，也不会触发叶子节点的分裂。</p><p>而有业务逻辑的字段做主键，则往往不容易保证有序插入，这样写数据成本相对较高。除了考虑性能外，我们还可以从存储空间的角度来看。假设你的表中确实有一个唯一字段，比如字符串类型的身份证号，那应该用身份证号做主键，还是用自增字段做主键呢？由于每个非主键索引的叶子节点上都是主键的值。如果用身份证号做主键，那么每个二级索引的叶子节点占用约 20 个字节，而如果用整型做主键，则只要 4 个字节，如果是长整型（bigint）则是 8 个字节。</p><p><strong>显然，主键长度越小，普通索引的叶子节点就越小，普通索引占用的空间也就越小。</strong></p><p>所以从性能和存储空间上分析，自增主键往往更合理。</p><p>但是，假如有的需求场景如下：</p><ul><li>只有一个索引</li><li>索引必须是唯一索引</li></ul><p>此时就是一个kv场景，由于没有其他索引，也不用考虑其他索引叶子结点的大小问题，这时候查询就用到<code>尽量使用主键查询</code>的原则，直接将这个索引设置为主键，避免为此搜索两棵树。</p><h1 id="索引的分类"><a href="#索引的分类" class="headerlink" title="索引的分类"></a>索引的分类</h1><p>上面大概介绍了下索引，对索引有了大致了解后，从 数据结构、物理存储、字段特性、字段个数 四个方面看看都有哪些索引</p><ul><li>数据结构：B+tree索引、Hash索引、Full-text索引</li><li>物理存储：聚簇索引（主键索引）、二级索引（辅助索引）</li><li>字段特性：主键索引、唯一索引、普通索引、前缀索引</li><li>字段个数：单列索引、联合索引</li></ul><h2 id="按数据结构分类"><a href="#按数据结构分类" class="headerlink" title="按数据结构分类"></a>按数据结构分类</h2><p>从数据结构分类上看，常见的有B+tree索引、Hash索引、Full-text索引灯</p><p>每一种存储引擎支持的索引类型不一定相同，具体如下表：</p><table><thead><tr><th>索引类型</th><th>InnoDB引擎</th><th>MyISAM引擎</th><th>Memory引擎</th></tr></thead><tbody><tr><td>B+tree索引</td><td>Yes</td><td>Yes</td><td>Yes</td></tr><tr><td>Hash索引</td><td>No（不支持hash索引，但是在内存结构中有一个自适应的hash索引）</td><td>No</td><td>Yes</td></tr><tr><td>Full-text索引</td><td>Yes（MySQL 5.6版本后支持）</td><td>Yes</td><td>No</td></tr></tbody></table><p>InnoDB在MySQL5.5之后成为默认的存储引擎，B+tree索引类型也是MySQL存储引擎采用最多的索引类型</p><p>在创建表时，InnoDB 存储引擎会根据不同的场景选择不同的列作为索引：</p><ul><li>如果有主键，默认会使用主键作为聚簇索引的索引键（key）</li><li>如果没有主键，就选择第一个不包含 NULL 值的唯一列作为聚簇索引的索引键（key）</li><li>在上面两个都没有的情况下，InnoDB 将自动生成一个隐式自增 id 列作为聚簇索引的索引键（key）</li></ul><p>其它索引都属于辅助索引（Secondary Index），也被称为二级索引或非聚簇索引。<strong>创建的主键索引和二级索引默认使用的是 B+Tree 索引</strong>。</p><p>数据库的索引和数据都是存储在硬盘的，我们可以把读取一个节点当作一次磁盘 I&#x2F;O 操作。B+Tree 存储千万级的数据只需要 3-4 层高度就可以满足，这意味着从千万级的表查询目标数据最多需要 3-4 次磁盘 I&#x2F;O，所以<strong>B+Tree 相比于 B 树和二叉树来说，最大的优势在于查询效率很高，因为即使在数据量很大的情况，查询一个数据的磁盘 I&#x2F;O 依然维持在 3-4次。</strong></p><p>为什么MySQL选择B+tree作为索引的数据结构呢？</p><p><strong>1、B+Tree vs B Tree</strong></p><p>B+Tree 只在叶子节点存储数据，而 B 树 的非叶子节点也要存储数据，所以 B+Tree 的单个节点的数据量更小，在相同的磁盘 I&#x2F;O 次数下，就能查询更多的节点。</p><p>另外，B+Tree 叶子节点采用的是双链表连接，适合 MySQL 中常见的基于范围的顺序查找，而 B 树无法做到这一点。</p><p><strong>2、B+Tree vs 二叉树</strong></p><p>对于有 N 个叶子节点的 B+Tree，其搜索复杂度为<code>O(logdN)</code>，其中 d 表示节点允许的最大子节点个数为 d 个。</p><p>在实际的应用当中， d 值是大于100的，这样就保证了，即使数据达到千万级别时，B+Tree 的高度依然维持在 3~4 层左右，也就是说一次数据查询操作只需要做 3~4 次的磁盘 I&#x2F;O 操作就能查询到目标数据。</p><p>而二叉树的每个父节点的儿子节点个数只能是 2 个，意味着其搜索复杂度为 <code>O(logN)</code>，这已经比 B+Tree 高出不少，因此二叉树检索到目标数据所经历的磁盘 I&#x2F;O 次数要更多。</p><p><strong>3、B+Tree vs Hash</strong></p><p>Hash 在做等值查询的时候效率贼快，搜索复杂度为 O(1)。</p><p>但是 Hash 表不适合做范围查询，它更适合做等值的查询，这也是 B+Tree 索引要比 Hash 表索引有着更广泛的适用场景的原因。</p><h2 id="按物理存储分类"><a href="#按物理存储分类" class="headerlink" title="按物理存储分类"></a>按物理存储分类</h2><p>在物理存储上，索引可以分为聚簇索引（主键索引）、二级索引（辅助索引）</p><p>这两个区别在前面也提到了：</p><ul><li>主键索引的 B+Tree 的叶子节点存放的是实际数据，所有完整的用户记录都存放在主键索引的 B+Tree 的叶子节点里；</li><li>二级索引的 B+Tree 的叶子节点存放的是主键值，而不是实际数据。</li></ul><p>所以，在查询时使用了二级索引，如果查询的数据能在二级索引里查询的到，那么就不需要回表，这个过程就是覆盖索引。如果查询的数据不在二级索引里，就会先检索二级索引，找到对应的叶子节点，获取到主键值后，然后再检索主键索引，就能查询到数据了，这个过程就是回表。</p><h2 id="按字段特性分类"><a href="#按字段特性分类" class="headerlink" title="按字段特性分类"></a>按字段特性分类</h2><p>从字段特性上看，索引可以分为 主键索引、唯一索引、普通索引、前缀索引</p><h3 id="主键索引"><a href="#主键索引" class="headerlink" title="主键索引"></a>主键索引</h3><p>主键索引就是一张表的主键上的索引，一张表只能有一个主键索引，主键列的值非空且唯一。</p><h3 id="唯一索引"><a href="#唯一索引" class="headerlink" title="唯一索引"></a>唯一索引</h3><p>唯一索引也就是 <code>UNIQUE</code>字段上的索引，一张表可以有多个唯一索引，但是唯一索引的每一列的值，都必须唯一</p><h3 id="普通索引"><a href="#普通索引" class="headerlink" title="普通索引"></a>普通索引</h3><p>普通索引是在普通字段上的索引，不要求字段为主键也不要求字段为<code>UNIQUE</code></p><h3 id="前缀索引"><a href="#前缀索引" class="headerlink" title="前缀索引"></a>前缀索引</h3><p>前缀索引是指对字符类型的前几个字符建立的索引，前缀索引可以建立在字段类型为 char、varchar、binary、varbinary、blob、text的列上</p><h2 id="按字段个数分类"><a href="#按字段个数分类" class="headerlink" title="按字段个数分类"></a>按字段个数分类</h2><p>从字段个数上，索引可以分为单列索引、联合索引</p><p><strong>联合索引</strong>：将多个字段组合成一个索引即为联合索引</p><p>现在将课程表中的课程id和课程名组成联合索引(class_id, class_name)，联合索引的b+tree示意图如下</p><p><img src="https://gxc-hexo-blog.oss-cn-beijing.aliyuncs.com/blog/index_tree.png"></p><p>如图，联合索引的非叶子结点用两个字段的值作为b+tree的key值。当联合索引查询数据时，先按<code>class_id</code>字段进行比较，在<code>class_id</code>字段相同的情况下再按照<code>class_name</code>字段进行比较。即，联合索引查询时，先按<code>class_id</code>进行排序，再按照<code>class_name</code>进行排序。</p><p>因此，在使用联合索引时，存在<strong>最左匹配原则</strong>，也就是按照最左优先的方式进行索引的匹配。在使用联合索引进行查询的时候，如果不遵循<strong>最左匹配原则</strong>，联合索引就会失效。</p><h1 id="索引失效的情况"><a href="#索引失效的情况" class="headerlink" title="索引失效的情况"></a>索引失效的情况</h1><p>使用索引失效有6种情况</p><ul><li>当使用 左 或者 左右 模糊匹配时，也就是<code>like %xxx</code>或者<code>linke %xxx%</code>这两种方式都会造成索引失效</li><li>在查询条件中对索引列使用函数</li><li>在查询条件中对表达式进行计算</li><li>MySQL遇到字符串和数字比较时，会自动吧字符串转为数字，然后进行比较。如果字符串是索引列，那么就会发生隐式类型转换，由于隐式类型转换是通过 CAST 函数实现的，等同于对索引列使用了函数，所以就会导致索引失效。</li><li>联合索引中未正确遵循最左匹配原则</li><li>WHERE字句中，如果在 OR 前的条件列是索引列，而在 OR 后的条件列不是索引列，那么索引会失效。</li></ul><h2 id="对索引使用左或者左右模糊匹配"><a href="#对索引使用左或者左右模糊匹配" class="headerlink" title="对索引使用左或者左右模糊匹配"></a>对索引使用左或者左右模糊匹配</h2><p>由于索引B+树是按照索引值有序排列存储的，只能根据前缀进行比较</p><p>假设现在有二级索引的B+树结构如下图所示</p><p><img src="https://gxc-hexo-blog.oss-cn-beijing.aliyuncs.com/blog/%E4%BA%8C%E7%BA%A7%E7%B4%A2%E5%BC%95.png"></p><p>假如现在要查询name字段前缀为 宝 的数据，即<code>name like &#39;%宝&#39;</code>，扫描索引过程如下：</p><ul><li>在根节点查询，宝这个字的拼音大小比根节点第一个索引的爱大，但是比第二个康小，所以走到二层的节点</li><li>在二层的节点查询，首字爱比宝小，第二个索引宝岛与之匹配，所以走到宝岛的叶子节点查询，即叶子节点的所在层的第二个</li><li>发现第一个索引值的前缀是宝字，与前缀匹配，于是读取该行，接着继续向右匹配，知道匹配不到宝字前缀的索引值</li></ul><p>如果使用<code>name like &#39;%宝&#39;</code>方式来查询，结果可能是 宝岛、宝贝、宝宝 等，所以不知道从哪里开始比较，于是就走了全表扫描的</p><h2 id="对索引使用函数"><a href="#对索引使用函数" class="headerlink" title="对索引使用函数"></a>对索引使用函数</h2><p>因为索引保存的是索引字段的原始值，而不是经过函数计算后的值，所以没办法走索引。</p><p>比如如下的sql</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> product <span class="hljs-keyword">where</span> length(name)<span class="hljs-operator">=</span><span class="hljs-number">3</span>;<br></code></pre></td></tr></table></figure><p>这里需要全表扫描name字段，判断长度是否等于3</p><h2 id="对索引进行表达式计算"><a href="#对索引进行表达式计算" class="headerlink" title="对索引进行表达式计算"></a>对索引进行表达式计算</h2><p>如下这个sql，在执行时也是进行了全表扫描</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> product <span class="hljs-keyword">where</span> price <span class="hljs-operator">+</span><span class="hljs-number">35</span> <span class="hljs-operator">=</span> <span class="hljs-number">100</span>;<br></code></pre></td></tr></table></figure><p>但是如果略作修改，把条件改成  <code>where price = 100-35</code> 就可以走索引了，为什么？</p><p>因为当条件是 <code>price+35 = 100</code>时，需要全表扫描，逐个去判断，那个price+35能等于100。但是当条件改为了<code>price = 100-35</code>的时候，mysql会进行计算，然后再判断 price &#x3D; 65。</p><h2 id="对索引隐式类型转化"><a href="#对索引隐式类型转化" class="headerlink" title="对索引隐式类型转化"></a>对索引隐式类型转化</h2><p>如果索引是字段是字符串类型，但是在条件查询中，输入的参数是整型，最后就会走全表扫描。</p><p>但是如果索引的字段是整型，输入的参数是字符串，还是会走索引。</p><p>因为MySQL在遇到字符串和数字进行比较的时候，会自动把字符串转为数字，然后再进行比较。</p><p>MySQL的CAST函数可以修改类型。</p><p>当索引字段是字符串类型，输入参数是整型时，会把索引字段转为整型，相当于给索引字段用了CAST函数，而如上所说，<strong>对索引使用函数会导致索引失效</strong></p><p>当索引字段是整型，而输入参数是字符串时，会把字符串转为整型，相当于给入参使用了CAST函数，不影响索引，所以还是会走索引扫描。</p><h2 id="联合索引非最左前缀"><a href="#联合索引非最左前缀" class="headerlink" title="联合索引非最左前缀"></a>联合索引非最左前缀</h2><p>在联合索引的情况下，数据是按照索引第一列排序，第一列数据相同时才会按照第二列排序。</p><p>所以如果我们想使用索引中尽可能多的列，查询条件的各个列必须是联合索引中最左边开始连续的列。</p><p>联合索引有一些特殊情况，<strong>并不是查询过程使用了联合索引查询，就代表联合索引中的所有字段都用到了联合索引进行索引查询</strong>，也就是可能存在部分字段用到联合索引的 B+Tree，部分字段没有用到联合索引的 B+Tree 的情况。</p><p>这种特殊情况就发生在范围查询。联合索引的最左匹配原则会一直向右匹配直到遇到「范围查询」就会停止匹配。<strong>也就是范围查询的字段可以用到联合索引，但是在范围查询字段的后面的字段无法用到联合索引</strong>。</p><p>看几个案例：</p><blockquote><p><code>select * from t_table where a &gt; 1 and b = 2</code>，联合索引（a, b）哪一个字段用到了联合索引的 B+Tree？</p></blockquote><p>由于联合索引是先按照a字段的值进行排序的，所以查找a&gt;1的联合索引记录肯定是相邻的，在进行索引扫描时，可以定位到符合a&gt;1的第一条记录，然后沿着记录的链表向后扫描，直到a&gt;1条件不成立。</p><p>但是在符合a&gt;1条件的联合索引记录的范围里，b字段的值是无序的。所以这条语句，只有a字段用到了联合索引，b字段没有用到。</p><blockquote><p><code>select * from t_table where a &gt;= 1 and b = 2</code>，联合索引（a, b）哪一个字段用到了联合索引的 B+Tree？</p></blockquote><p>a&gt;&#x3D;1条件的联合索引记录范围里，b字段是无序的，但是对于符合 a &#x3D; 1的联合索引范围里，b字段的值是有序的。由于联合索引，先按照a字段排序，然后再a字段相同的情况下，再按照b字段排序，所以，从符合a&#x3D;1 and b&#x3D;2条件的第一条记录开始扫描，而不需要从第一个a字段值为1的记录开始扫描，所以，此时a字段和b字段都用到了联合索引</p><blockquote><p><code>SELECT * FROM t_table WHERE a BETWEEN 2 AND 8 AND b = 2</code>，联合索引（a, b）哪一个字段用到了联合索引的 B+Tree？</p></blockquote><p>在MySQL中，BETWEEN包含了 value1和value2边界值，类似 &gt;&#x3D; and &lt;&#x3D;，通过上一个案例可知，在a字段等于2 和等于8的时候，b字段可以走联合索引，所以此时，a字段和b字段都可以用到联合索引</p><blockquote><p><code>SELECT * FROM t_user WHERE name like &#39;j%&#39; and age = 22</code>，联合索引（name, age）哪一个字段用到了联合索引的 B+Tree？</p></blockquote><p>此时是右模糊匹配，所以左前缀不受影响，在name &#x3D; j时，age字段可以走联合索引</p><p>综上所示，<strong>联合索引的最左匹配原则，在遇到范围查询（如 &gt;、&lt;）的时候，就会停止匹配，也就是范围查询的字段可以用到联合索引，但是在范围查询字段的后面的字段无法用到联合索引。注意，对于 &gt;&#x3D;、&lt;&#x3D;、BETWEEN、like 前缀匹配的范围查询，并不会停止匹配</strong></p><h3 id="索引下推"><a href="#索引下推" class="headerlink" title="索引下推"></a>索引下推</h3><p>上边的案例说<code>select * from table where a &gt; 1 and b = 2</code> 语句中的a字段可以走索引，但是b字段不能走索引，那在联合索引里边，是不是回回表呢？</p><p>在MySQL5.6之前，只能根据查到的主键值，一个一个回表，再试在MySQL5.6引入了<strong>索引下推</strong>，可以再联合索引遍历的过程中，对联合索引中包含的字段先做判断，直接过滤掉不满足条件的记录，减少回表次数。</p><p>索引下推的大概原理是：截断的字段不会在 Server 层进行条件判断，而是会被下推到「存储引擎层」进行条件判断（因为 b 字段的值是在 <code>(a, b)</code> 联合索引里的），然后过滤出符合条件的数据后再返回给 Server 层。由于在引擎层就过滤掉大量的数据，无需再回表读取数据来进行判断，减少回表次数，从而提升了性能。</p><h3 id="索引区分度"><a href="#索引区分度" class="headerlink" title="索引区分度"></a>索引区分度</h3><p>建立联合索引时的字段顺序，对索引效率也有很大影响。越靠前的字段被用于索引过滤的概率越高，实际开发工作中<strong>建立联合索引时，要把区分度大的字段排在前面，这样区分度大的字段越有可能被更多的 SQL 使用到</strong>。</p><p>区分度就是某个字段 column 不同值的个数「除以」表的总行数，计算公式如下：</p><blockquote><p>区分度 &#x3D; distinct(column) &#x2F; count(*)</p></blockquote><p>比如，性别的区分度就很小，不适合建立索引或不适合排在联合索引列的靠前的位置，而 UUID 这类字段就比较适合做索引或排在联合索引列的靠前的位置。</p><p>因为如果索引的区分度很小，假设字段的值分布均匀，那么无论搜索哪个值都可能得到一半的数据。在这些情况下，还不如不要索引，因为 MySQL 还有一个查询优化器，查询优化器发现某个值出现在表的数据行中的百分比（惯用的百分比界线是”30%”）很高的时候，它一般会忽略索引，进行全表扫描。</p><h1 id="优化索引的方法"><a href="#优化索引的方法" class="headerlink" title="优化索引的方法"></a>优化索引的方法</h1><h2 id="前缀索引优化"><a href="#前缀索引优化" class="headerlink" title="前缀索引优化"></a>前缀索引优化</h2><p>使用前缀索引是为了减小索引字段大小，可以增加一个索引页中存储的索引值，有效提高索引的查询速度。在一些大字符串的字段作为索引时，使用前缀索引可以帮助我们减小索引项的大小。</p><p>不过，前缀索引有一定的局限性，例如：</p><ul><li>order by 就无法使用前缀索引；</li><li>无法把前缀索引用作覆盖索引；</li></ul><h2 id="覆盖索引优化"><a href="#覆盖索引优化" class="headerlink" title="覆盖索引优化"></a>覆盖索引优化</h2><p>覆盖索引是指，在索引的叶子节点上就能找到值，而不需要再回表。</p><p>比如建立一个联合索引，「name, age, address」， 当查小明的年龄和地址的时候，直接从索引中就能得到数据，不需要再回表</p><h2 id="主键索引最好是自增的"><a href="#主键索引最好是自增的" class="headerlink" title="主键索引最好是自增的"></a>主键索引最好是自增的</h2><p><strong>如果我们使用自增主键</strong>，那么每次插入的新数据就会按顺序添加到当前索引节点的位置，不需要移动已有的数据，当页面写满，就会自动开辟一个新页面。因为每次<strong>插入一条新记录，都是追加操作，不需要重新移动数据</strong>，因此这种插入数据的方法效率非常高。</p><p><strong>如果我们使用非自增主键</strong>，由于每次插入主键的索引值都是随机的，因此每次插入新的数据时，就可能会插入到现有数据页中间的某个位置，这将不得不移动其它数据来满足新数据的插入，甚至需要从一个页面复制数据到另外一个页面，我们通常将这种情况称为<strong>页分裂</strong>。<strong>页分裂还有可能会造成大量的内存碎片，导致索引结构不紧凑，从而影响查询效率</strong>。</p><p>另外，主键字段的长度不要太大，因为<strong>主键字段长度越小，意味着二级索引的叶子节点越小（二级索引的叶子节点存放的数据是主键值），这样二级索引占用的空间也就越小</strong>。</p><h2 id="索引最好设置为NOT-NULL"><a href="#索引最好设置为NOT-NULL" class="headerlink" title="索引最好设置为NOT NULL"></a>索引最好设置为NOT NULL</h2><p>索引列存在 NULL 就会导致优化器在做索引选择的时候更加复杂，更加难以优化，因为可为 NULL 的列会使索引、索引统计和值比较都更复杂，比如进行索引统计时，count 会省略值为NULL 的行。</p><p>NULL 值是一个没意义的值，但是它会占用物理空间，所以会带来的存储空间的问题，因为 InnoDB 存储记录的时候，如果表中存在允许为 NULL 的字段，那么行格式 (opens new window)中<strong>至少会用 1 字节空间存储 NULL 值列表</strong></p><h2 id="防止索引失效"><a href="#防止索引失效" class="headerlink" title="防止索引失效"></a>防止索引失效</h2>]]></content>
    
    
    <categories>
      
      <category>MySQL</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MySQL</tag>
      
      <tag>数据库</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SQL查询过程</title>
    <link href="/2024/06/23/SQL%E6%9F%A5%E8%AF%A2%E8%BF%87%E7%A8%8B/"/>
    <url>/2024/06/23/SQL%E6%9F%A5%E8%AF%A2%E8%BF%87%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="MySQL基本架构"><a href="#MySQL基本架构" class="headerlink" title="MySQL基本架构"></a>MySQL基本架构</h1><p><img src="https://gxc-hexo-blog.oss-cn-beijing.aliyuncs.com/blog/MySQL%E5%9F%BA%E6%9C%AC%E6%9E%B6%E6%9E%84.png"></p><p>从上图看，MySQL分为两部分：Server层 和 存储引擎 </p><p><strong>Server层</strong>：负责建立连接，分析和执行SQL。涵盖MySQL的大多数核心服务功能，主要包括连接器，查询缓存、解析器、预处理器、优化器、执行器等，以及所有的内置函数（如日期、时间、数学和加密函数等）</p><p><strong>存储引擎层</strong>：负责数据的存储和提取。支持 InnoDB、MyISAM、Memory 等多个存储引擎。现在最常用的存储引擎是 InnoDB，它从 MySQL 5.5.5 版本开始成为了默认存储引擎。</p><h1 id="连接器"><a href="#连接器" class="headerlink" title="连接器"></a>连接器</h1><p>执行SQL语句首先得连接到数据库上，这时候就会遇到连机器。连接器负责跟客户端建立连接、获取权限、维持和管理链接。链接命令如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">mysql -h$ip -P$port -u$user -p<br></code></pre></td></tr></table></figure><p>为了密码的安全，不在如上命令后写密码，而是直接执行上述命令在后续的对话框中输入密码。</p><p>连接的过程需要先经过 TCP 三次握手，因为 MySQL 是基于 TCP 协议进行传输的，如果 MySQL 服务并没有启动，则会报一个 “Can’t not connect to MySQL through socket ….”</p><p>如果MySQL服务正常，完成TCP连接之后，连接器就要开始验证用户名和密码</p><ul><li>如果用户名或者密码不对，则会报 “Access denied for user”</li><li>如果用户名密码认证通过，连接器会到权限表里面查出你拥有的权限。之后，这个连接里面的权限判断逻辑，都将依赖于此时读到的权限</li></ul><p>因为在成功建立连接后，连接器已经校验了权限，所以后续管理员账号哪怕对这个权限做了修改，也不会影响已经存在的连接的权限，只有新建的连接才会使用新的权限。</p><p>如何查看MySQL的连接呢？</p><p>连接完成后，如果你没有后续的动作，这个连接就处于空闲状态，你可以在 <code>show processlist</code> 命令中看到它。其中的 Command 列显示为“Sleep”的这一行，就表示现在系统里面有一个空闲连接。</p><p><img src="https://gxc-hexo-blog.oss-cn-beijing.aliyuncs.com/blog/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5.png"></p><p>共有两个用户名为 root 的用户连接了 MySQL 服务，其中 id 为 6 的用户的 Command 列的状态为 <code>Sleep</code> ，这意味着该用户连接完 MySQL 服务就没有再执行过任何命令，也就是说这是一个空闲的连接，并且空闲的时长是 736 秒（ Time 列）。</p><p>客户端如果太长时间没动静，连接器就会自动将它断开。这个时间是由参数 wait_timeout 控制的，默认值是 8 小时。(<code>mysql&gt; show variables like &#39;wait_timeout&#39;;</code> 可以查看此配置)</p><p>也可以手动断开空闲的连接，使用 <code>kill connection + id</code> </p><p>如果在连接被断开之后，客户端不会马上感知，当再次发送请求的时，就会收到一个错误提醒： Lost connection to MySQL server during query。这时候如果你要继续，就需要重连，然后再执行请求了。</p><p>建立连接的过程通常是比较复杂的，所以在使用中要尽量减少建立连接的动作，也就是尽量使用长连接。（使用长连接，通过连接池维护一些长连接）</p><p>但是MySQL的连接数有限制，支持的最大连接数由 max_connections 参数控制，如果超过这个限制就会拒绝接下来的连接请求，并报错提示：”Too many connections”，而且使用长连接后可能会占用内存增多，因为 MySQL 在执行查询过程中临时使用内存管理连接对象，这些连接对象资源只有在连接断开时才会释放。如果长连接累计很多，将导致 MySQL 服务占用内存太大，有可能会被系统强制杀掉，这样会发生 MySQL 服务异常重启的现象。</p><p>那如何解决长连接占用内存问题呢？</p><ol><li>定期断开长连接。使用一段时间，或者程序里面判断执行过一个占用内存的大查询后，断开连接，之后要查询再重连。</li><li>如果用的是 MySQL 5.7 或更新版本，可以在每次执行一个比较大的操作后，通过执行 mysql_reset_connection 来重新初始化连接资源。这个过程不需要重连和重新做权限验证，但是会将连接恢复到刚刚创建完时的状态。注意这是接口函数不是命令，那么当客户端执行了一个很大的操作后，在代码里调用 mysql_reset_connection 函数来重置连接，达到释放内存的效果。</li></ol><p>小结：</p><ul><li>与客户端进行 TCP 三次握手建立连接；</li><li>校验客户端的用户名和密码，如果用户名或密码不对，则会报错；</li><li>如果用户名和密码都对了，会读取该用户的权限，然后后面的权限逻辑判断都基于此时读取到的权限；</li></ul><h1 id="查询缓存"><a href="#查询缓存" class="headerlink" title="查询缓存"></a>查询缓存</h1><p>连接建立完成后，执行逻辑就会来到第二步：查询缓存。</p><p>MySQL 拿到一个查询请求后，会先到查询缓存看看，之前是不是执行过这条语句。之前执行过的语句及其结果可能会以 key-value 对的形式，被直接缓存在内存中。key 是查询的语句，value 是查询的结果。如果你的查询能够直接在这个缓存中找到 key，那么这个 value 就会被直接返回给客户端。如果查询的语句没有命中查询缓存中，那么就要往下继续执行，等执行完后，查询的结果就会被存入查询缓存中。</p><p><strong>但是查询缓存往往弊大于利</strong></p><p><strong>查询缓存的失效非常频繁，只要有对一个表的更新，这个表上所有的查询缓存都会被清空。</strong>对于更新比较频繁的表，查询缓存的命中率很低的，如果刚缓存了一个查询结果很大的数据，还没被使用的时候，刚好这个表有更新操作，查询缓冲就被清空了。</p><p>查询缓存受 <code>query_cache_type</code>参数控制，将其设置成 “DEMAND”，SQL就默认不使用查询缓存，对于要使用查询缓存的，可以用 SQL_CACHE 显示指定，例如：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs SQL"><span class="hljs-keyword">select</span> SQL_CACHE <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> T <span class="hljs-keyword">where</span> ID<span class="hljs-operator">=</span><span class="hljs-number">1</span>；<br></code></pre></td></tr></table></figure><p>在 MySQL 8.0版本之后，查询缓存的功能被移除了。注意：此处移除的是server层的查询缓存，不是InnoDB存储引擎中的 buffer pool。</p><h1 id="分析器"><a href="#分析器" class="headerlink" title="分析器"></a>分析器</h1><p>没有命中查询缓存的查询SQL，就要开始真正执行了。所以接下来要对SQL进行分析</p><p>分析器会做两种分析：<strong>词法分析</strong>、<strong>语法分析</strong></p><p>词法分析：MySQL根据输入的字符串识别出关键字来，比如根据输入的 “select” 识别出这是一个查询语句。</p><p>语法分析：语法分析会根据语法规则，判断输入的这个SQL是否符合MySQL的语法，如果语句有错误，就会收到”You have an error in your SQL syntax”的错误提醒，</p><h1 id="执行SQL"><a href="#执行SQL" class="headerlink" title="执行SQL"></a>执行SQL</h1><p>经过解析器后，就要进入执行SQL查询语句的流程了，查询分三个阶段：预处理阶段、优化阶段、执行阶段</p><h2 id="预处理器"><a href="#预处理器" class="headerlink" title="预处理器"></a>预处理器</h2><ul><li>检查SQL查询语句中的表或者字段是否存在</li><li>将 <code>select *</code> 中的<code>*</code>符号，扩展为表中所有的列</li></ul><h2 id="优化器"><a href="#优化器" class="headerlink" title="优化器"></a>优化器</h2><p>在预处理过后，还需要优化器进行处理</p><p><strong>优化器主要负责将 SQL 查询语句的执行方案确定下来</strong>，比如在表里面有多个索引的时候，决定使用哪个索引，或者在一个语句有多表关联（join）的时候，决定各个表的连接顺序。</p><p>如何知道优化器选择了哪个索引？</p><p>可以在查询语句最前面加个 <code>explain</code> 命令，这样就会输出这条 SQL 语句的执行计划，然后执行计划中的 key 就表示执行过程中使用了哪个索引，当 key 为 <code>PRIMARY</code> 就是使用了主键索引。</p><blockquote><p>type显示的是访问类型，访问类型表示我是以何种方式去访问我们的数据，最容易想的是全表扫描，直接暴力的遍历一张表去寻找需要的数据，效率非常低下，访问的类型有很多，效率从最好到最坏依次是：</p><p>所有的连接类型中，上面的最好，越往下越差。在常用的链接类型中：system &gt; const &gt; eq_ref &gt; ref &gt; fulltext &gt; ref_or_null &gt; index_merge &gt; unique_subquery &gt; index_subquery &gt; range &gt; index &gt; ALL</p><p>以上访问类型除了 all，都能用到索引,一般情况下，得保证查询至少达到range级别，最好能达到ref</p><p>–all:全表扫描，一般情况下出现这样的sql语句而且数据量比较大的话那么就需要进行优化。<br>explain select * from emp;</p><p>–index：全索引扫描这个比all的效率要好，主要有两种情况，一种是当前的查询时覆盖索引，即我们需要的数据在索引中就可以索取，或者是使用了索引进行排序，这样就避免数据的重排序<br>explain  select empno from emp;</p><p>–range：表示利用索引查询的时候限制了范围，在指定范围内进行查询，这样避免了index的全索引扫描，适用的操作符： &#x3D;, &lt;&gt;, &gt;, &gt;&#x3D;, &lt;, &lt;&#x3D;, IS NULL, BETWEEN, LIKE, or IN()<br>explain select * from emp where empno between 7000 and 7500;</p><p>–index_subquery：利用索引来关联子查询，不再扫描全表<br>explain select * from emp where emp.job in (select job from t_job);</p><p>–unique_subquery:该连接类型类似与index_subquery,使用的是唯一索引<br> explain select * from emp e where e.deptno in (select distinct deptno from dept);</p><p>–index_merge：在查询过程中需要多个索引组合使用</p><p>–ref_or_null：对于某个字段即需要关联条件，也需要null值的情况下，查询优化器会选择这种访问方式<br>explain select * from emp e where  e.mgr is null or e.mgr&#x3D;7369;</p><p>–ref：使用了非唯一性索引进行数据的查找，查询用到了非唯一性索引，或者关联操作只使用了索引的最左前缀。<br> create index idx_3 on emp(deptno);<br> explain select * from emp e,dept d where e.deptno &#x3D;d.deptno;</p><p>–eq_ref ：通常出现在多表的 join 查询，被驱动表通过唯一性索引（UNIQUE 或 PRIMARY KEY）进行访问，此时被驱动表的访问方式就是 eq_ref。eq_ref 是除 const 之外最好的访问类型。使用唯一性索引进行数据查找<br>explain select * from emp,emp2 where emp.empno &#x3D; emp2.empno;</p><p>–const：主键索引或者唯一索引,这个表至多有一个匹配行；<br>explain select * from emp where empno &#x3D; 7369;</p><p>–system：system 是 const 的一种特例，只有一行满足条件，对于 MyISAM、Memory 的表，只查询到一条记录，也是 system。比如系统库的这张表（8.0 的版本中系统表全部变成 InnoDB 存储引擎了）：<br>表只有一行记录（等于系统表），这是const类型的特例，平时不会出现；<br>EXPLAIN SELECT * FROM mysql.proxies_priv;</p></blockquote><h2 id="执行器"><a href="#执行器" class="headerlink" title="执行器"></a>执行器</h2><p>MySQL 通过分析器知道了你要做什么，通过优化器知道了该怎么做，于是就进入了执行器阶段，开始执行语句。</p><p>开始执行的时候，要先判断一下你对这个表 T 有没有执行查询的权限，如果没有，就会返回没有权限的错误(在工程实现上，如果命中查询缓存，会在查询缓存返回结果的时候，做权限验证。查询也会在优化器之前调用 precheck 验证权限)。</p>]]></content>
    
    
    <categories>
      
      <category>MySQL</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MySQL</tag>
      
      <tag>数据库</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MongoDB集群</title>
    <link href="/2024/06/19/MongoDB%E9%9B%86%E7%BE%A4/"/>
    <url>/2024/06/19/MongoDB%E9%9B%86%E7%BE%A4/</url>
    
    <content type="html"><![CDATA[<h1 id="副本集"><a href="#副本集" class="headerlink" title="副本集"></a>副本集</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>MongoDB副本集（Replica Set）是一组维护相同数据集的mongod服务，旨在提供冗余和高可用性。它由多个mongod进程组成，这些进程在不同的机器上运行，共同维护相同的数据集。</p><p>副本集的工作原理类似于具有自动故障恢复功能的主从集群，通过多台机器进行同一数据的异步同步，确保多台机器拥有同一数据的多个副本。当主库发生故障时，副本集能够自动切换到其他备份服务器作为新的主库，无需用户干预，从而保证了数据的可用性和系统的持续性运行。此外，副本集还可以利用副本服务器作为只读服务器，实现读写分离，提高系统的负载能力。</p><p>（1）冗余和数据可用性</p><p>复制提供冗余并提高数据可用性。 通过在不同数据库服务器上提供多个数据副本，复制可提供一定级别的容错功能，以防止丢失单个数据库服务器。</p><p>在某些情况下，复制可以提供增加的读取性能，因为客户端可以将读取操作发送到不同的服务上， 在不同数据中心维护数据副本可以增加分布式应用程序的数据位置和可用性。 您还可以为专用目的维护其他副本，例如灾难恢复，报告或备份。</p><p>（2）MongoDB中的复制</p><p>副本集是一组维护相同数据集的mongod实例。 副本集包含多个数据承载节点和可选的一个仲裁节点。在承载数据的节点中，一个且仅一个成员被视为主节点，而其他节点被视为次要（从）节点。</p><p>主节点接收所有写操作。 副本集只能有一个主要能够确认具有{w：“most”}写入关注的写入; 虽然在某些情况下，另一个mongod实例可能暂时认为自己也是主要的。主要记录其操作日志中的数据集的所有更改，即oplog。</p><p>辅助(副本)节点复制主节点的oplog并将操作应用于其数据集，以使辅助节点的数据集反映主节点数据集。 如果主要人员不在，则符合条件的中将举行选举以选出新的主要人员。</p><p>（3）主从复制和副本集区别</p><p>主从集群和副本集最大的区别就是副本集没有固定的“主节点”；整个集群会选出一个“主节点”，当其挂掉后，又在剩下的从节点中选中其他节点为“主节点”，副本集总有一个活跃点(主、primary)和一个或多个备份节点(从、secondary)。</p><h2 id="副本集的三个角色"><a href="#副本集的三个角色" class="headerlink" title="副本集的三个角色"></a>副本集的三个角色</h2><p>副本集有两种类型三种角色</p><p>两种类型：</p><ul><li><p>主节点（Primary）类型：数据操作的主要连接点，可读写。</p></li><li><p>次要（辅助、从）节点（Secondaries）类型：数据冗余备份节点，可以读或选举。</p></li></ul><p>三种角色：</p><p>主要成员（Primary）：主要接收所有写操作。就是主节点。</p><p>副本成员（Replicate）：从主节点通过复制操作以维护相同的数据集，即备份数据，不可写操作，但可以读操作（但需要配置）。是默认的一种从节点类型。</p><p>仲裁者（Arbiter）：不保留任何数据的副本，只具有投票选举作用。当然也可以将仲裁服务器维护为副本集的一部分，即副本成员同时也可以是仲裁者。也是一种从节点类型。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs shell">+-----------------+<br>|    Client       |<br>+-----------------+<br>       |<br>       v<br>+-----------------+<br>|   Primary Node  |<br>+-----------------+<br>       |<br>       v<br>+------------------+        +------------------+<br>| Secondary Node 1 | &lt;----&gt; | Secondary Node 2 |<br>+------------------+        +------------------+<br>       ^<br>       |<br>+------------------+<br>|   Arbiter Node   |<br>+------------------+<br><br></code></pre></td></tr></table></figure><p>关于仲裁者的额外说明：</p><p>您可以将额外的mongod实例添加到副本集作为仲裁者。 仲裁者不维护数据集。 仲裁者的目的是通过响应其他副本集成员的心跳和选举请求来维护副本集中的仲裁。 因为它们不存储数据集，所以仲裁器可以是提供副本集仲裁功能的好方法，其资源成本比具有数据集的全功能副本集成员更便宜。</p><p>如果您的副本集具有偶数个成员，请添加仲裁者以获得主要选举中的“大多数”投票。 仲裁者不需要专用硬件。</p><p>仲裁者将永远是仲裁者，而主要人员可能会退出并成为次要人员，而次要人员可能成为选举期间的主要人员。</p><p>如果你的副本+主节点的个数是偶数，建议加一个仲裁者，形成奇数，容易满足大多数的投票。</p><p>如果你的副本+主节点的个数是奇数，可以不加仲裁者。</p><h2 id="副本集架构目标"><a href="#副本集架构目标" class="headerlink" title="副本集架构目标"></a>副本集架构目标</h2><p>一主一副本一仲裁</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs shell">+-----------------+<br>|    Client       |<br>+-----------------+<br>       |<br>       v<br>+-----------------+<br>|   Primary Node  |<br>+-----------------+<br>       |<br>       v<br>+------------------+        +------------------+<br>| Secondary Node 1 | &lt;----&gt; | Secondary Node 2 |<br>+------------------+        +------------------+<br>       ^<br>       |<br>+------------------+<br>|   Arbiter Node   |<br>+------------------+<br><br><br></code></pre></td></tr></table></figure><h2 id="副本集的创建"><a href="#副本集的创建" class="headerlink" title="副本集的创建"></a>副本集的创建</h2><h3 id="创建主节点"><a href="#创建主节点" class="headerlink" title="创建主节点"></a>创建主节点</h3><p>简历存放数据和日志的目录</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">-----------myrs</span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">主节点</span><br>mkdir -p /mongodb/replica_sets/myrs_27017/log \ &amp;<br>mkdir -p /mongodb/replica_sets/myrs_27017/data/db<br></code></pre></td></tr></table></figure><p>新建或修改配置文件：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">vim /mongodb/replica_sets/myrs_27017/mongod.conf<br></code></pre></td></tr></table></figure><p>myrs_27017：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">systemLog:</span><br>  <span class="hljs-comment">#MongoDB发送所有日志输出的目标指定为文件</span><br>  <span class="hljs-attr">destination:</span> <span class="hljs-string">file</span><br>  <span class="hljs-comment">#mongod或mongos应向其发送所有诊断日志记录信息的日志文件的路径</span><br>  <span class="hljs-attr">path:</span> <span class="hljs-string">&quot;/mongodb/replica_sets/myrs_27017/log/mongod.log&quot;</span><br>  <span class="hljs-comment">#当mongos或mongod实例重新启动时，mongos或mongod会将新条目附加到现有日志文件的末尾。</span><br>  <span class="hljs-attr">logAppend:</span> <span class="hljs-literal">true</span><br><span class="hljs-attr">storage:</span><br>  <span class="hljs-comment">#mongod实例存储其数据的目录。storage.dbPath设置仅适用于mongod。</span><br>  <span class="hljs-attr">dbPath:</span> <span class="hljs-string">&quot;/mongodb/replica_sets/myrs_27017/data/db&quot;</span><br>  <span class="hljs-attr">journal:</span><br>  <span class="hljs-comment">#启用或禁用持久性日志以确保数据文件保持有效和可恢复。</span><br>  <span class="hljs-attr">enabled:</span> <span class="hljs-literal">true</span><br><span class="hljs-attr">processManagement:</span><br>  <span class="hljs-comment">#启用在后台运行mongos或mongod进程的守护进程模式。</span><br>  <span class="hljs-attr">fork:</span> <span class="hljs-literal">true</span><br>  <span class="hljs-comment">#指定用于保存mongos或mongod进程的进程ID的文件位置，其中mongos或mongod将写入其PID</span><br>  <span class="hljs-attr">pidFilePath:</span> <span class="hljs-string">&quot;/mongodb/replica_sets/myrs_27017/log/mongod.pid&quot;</span><br><span class="hljs-attr">net:</span><br>  <span class="hljs-comment">#服务实例绑定所有IP，有副作用，副本集初始化的时候，节点名字会自动设置为本地域名，而不是ip</span><br>  <span class="hljs-comment">#bindIpAll: true</span><br>  <span class="hljs-comment">#服务实例绑定的IP</span><br>  <span class="hljs-attr">bindIp:</span> <span class="hljs-string">localhost,192.168.0.2</span><br>  <span class="hljs-comment">#bindIp</span><br>  <span class="hljs-comment">#绑定的端口</span><br>  <span class="hljs-attr">port:</span> <span class="hljs-number">27017</span><br><span class="hljs-attr">replication:</span><br>  <span class="hljs-comment">#副本集的名称</span><br>  <span class="hljs-attr">replSetName:</span> <span class="hljs-string">myrs</span><br></code></pre></td></tr></table></figure><p>启动节点服务：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">/usr/local/mongodb/bin/mongod -f /mongodb/replica_sets/myrs_27017/mongod.conf<br>about to fork child process, waiting until server is ready for connections.<br>forked process: 54257<br>child process started successfully, parent exiting<br></code></pre></td></tr></table></figure><h3 id="创建副本节点"><a href="#创建副本节点" class="headerlink" title="创建副本节点"></a>创建副本节点</h3><p>建立存放数据和日志的目录</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">副本节点</span><br>mkdir -p /mongodb/replica_sets/myrs_27018/log \ &amp;<br>mkdir -p /mongodb/replica_sets/myrs_27018/data/db<br></code></pre></td></tr></table></figure><p>新建或修改配置文件：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">vim /mongodb/replica_sets/myrs_27018/mongod.conf<br></code></pre></td></tr></table></figure><p>myrs_27018：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs shell">systemLog:<br><span class="hljs-meta prompt_">  #</span><span class="language-bash">MongoDB发送所有日志输出的目标指定为文件</span><br>  destination: file<br><span class="hljs-meta prompt_">  #</span><span class="language-bash">mongod或mongos应向其发送所有诊断日志记录信息的日志文件的路径</span><br>  path: &quot;/mongodb/replica_sets/myrs_27018/log/mongod.log&quot;<br><span class="hljs-meta prompt_">  #</span><span class="language-bash">当mongos或mongod实例重新启动时，mongos或mongod会将新条目附加到现有日志文件的末尾。</span><br>  logAppend: true<br>storage:<br><span class="hljs-meta prompt_">  #</span><span class="language-bash">mongod实例存储其数据的目录。storage.dbPath设置仅适用于mongod。</span><br>  dbPath: &quot;/mongodb/replica_sets/myrs_27018/data/db&quot;<br>  journal:<br><span class="hljs-meta prompt_">  #</span><span class="language-bash">启用或禁用持久性日志以确保数据文件保持有效和可恢复。</span><br>  enabled: true<br>processManagement:<br><span class="hljs-meta prompt_">  #</span><span class="language-bash">启用在后台运行mongos或mongod进程的守护进程模式。</span><br>  fork: true<br><span class="hljs-meta prompt_">  #</span><span class="language-bash">指定用于保存mongos或mongod进程的进程ID的文件位置，其中mongos或mongod将写入其PID</span><br>  pidFilePath: &quot;/mongodb/replica_sets/myrs_27018/log/mongod.pid&quot;<br>net:<br><span class="hljs-meta prompt_">  #</span><span class="language-bash">服务实例绑定所有IP，有副作用，副本集初始化的时候，节点名字会自动设置为本地域名，而不是ip</span><br><span class="hljs-meta prompt_">  #</span><span class="language-bash">bindIpAll: <span class="hljs-literal">true</span></span><br><span class="hljs-meta prompt_">  #</span><span class="language-bash">服务实例绑定的IP</span><br>  bindIp: localhost,192.168.0.2<br><span class="hljs-meta prompt_">  #</span><span class="language-bash">bindIp</span><br><span class="hljs-meta prompt_">  #</span><span class="language-bash">绑定的端口</span><br>  port: 27018<br>replication:<br><span class="hljs-meta prompt_">  #</span><span class="language-bash">副本集的名称</span><br>  replSetName: myrs<br></code></pre></td></tr></table></figure><p>启动节点服务：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">/usr/local/mongodb/bin/mongod -f /mongodb/replica_sets/myrs_27018/mongod.conf<br>about to fork child process, waiting until server is ready for connections.<br>forked process: 54361<br>child process started successfully, parent exiting<br></code></pre></td></tr></table></figure><h3 id="创建仲裁节点"><a href="#创建仲裁节点" class="headerlink" title="创建仲裁节点"></a>创建仲裁节点</h3><p>建立存放数据和日志的目录</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">-----------myrs</span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">仲裁节点</span><br>mkdir -p /mongodb/replica_sets/myrs_27019/log \ &amp;<br>mkdir -p /mongodb/replica_sets/myrs_27019/data/db<br></code></pre></td></tr></table></figure><p>仲裁节点：</p><p>新建或修改配置文件：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">vim /mongodb/replica_sets/myrs_27019/mongod.conf<br></code></pre></td></tr></table></figure><p>myrs_27019：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs shell">systemLog:<br><span class="hljs-meta prompt_">  #</span><span class="language-bash">MongoDB发送所有日志输出的目标指定为文件</span><br>  destination: file<br><span class="hljs-meta prompt_">  #</span><span class="language-bash">mongod或mongos应向其发送所有诊断日志记录信息的日志文件的路径</span><br>  path: &quot;/mongodb/replica_sets/myrs_27019/log/mongod.log&quot;<br><span class="hljs-meta prompt_">  #</span><span class="language-bash">当mongos或mongod实例重新启动时，mongos或mongod会将新条目附加到现有日志文件的末尾。</span><br>  logAppend: true<br>storage:<br><span class="hljs-meta prompt_">  #</span><span class="language-bash">mongod实例存储其数据的目录。storage.dbPath设置仅适用于mongod。</span><br>  dbPath: &quot;/mongodb/replica_sets/myrs_27019/data/db&quot;<br>  journal:<br><span class="hljs-meta prompt_">  #</span><span class="language-bash">启用或禁用持久性日志以确保数据文件保持有效和可恢复。</span><br>  enabled: true<br>processManagement:<br><span class="hljs-meta prompt_">  #</span><span class="language-bash">启用在后台运行mongos或mongod进程的守护进程模式。</span><br>  fork: true<br><span class="hljs-meta prompt_">  #</span><span class="language-bash">指定用于保存mongos或mongod进程的进程ID的文件位置，其中mongos或mongod将写入其PID</span><br>  pidFilePath: &quot;/mongodb/replica_sets/myrs_27019/log/mongod.pid&quot;<br>net:<br><span class="hljs-meta prompt_">  #</span><span class="language-bash">服务实例绑定所有IP，有副作用，副本集初始化的时候，节点名字会自动设置为本地域名，而不是ip</span><br><span class="hljs-meta prompt_">  #</span><span class="language-bash">bindIpAll: <span class="hljs-literal">true</span></span><br><span class="hljs-meta prompt_">  #</span><span class="language-bash">服务实例绑定的IP</span><br>  bindIp: localhost,192.168.0.2<br><span class="hljs-meta prompt_">  #</span><span class="language-bash">bindIp</span><br><span class="hljs-meta prompt_">  #</span><span class="language-bash">绑定的端口</span><br>  port: 27019<br>replication:<br><span class="hljs-meta prompt_">  #</span><span class="language-bash">副本集的名称</span><br>  replSetName: myrs<br></code></pre></td></tr></table></figure><p>启动节点服务：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"> /usr/local/mongodb/bin/mongod -f /mongodb/replica_sets/myrs_27019/mongod.conf<br>about to fork child process, waiting until server is ready for connections.<br>forked process: 54410<br>child process started successfully, parent exiting<br></code></pre></td></tr></table></figure><h3 id="初始化配置副本集和主节点"><a href="#初始化配置副本集和主节点" class="headerlink" title="初始化配置副本集和主节点"></a>初始化配置副本集和主节点</h3><p>使用客户端命令连接任意一个节点，但这里尽量要连接主节点(27017节点)：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">/usr/local/mongodb/bin/mongo --host=180.76.159.126 --port=27017<br></code></pre></td></tr></table></figure><p>结果，连接上之后，很多命令无法使用，，比如 show dbs 等，必须初始化副本集才行</p><p>准备初始化新的副本集：</p><p>语法：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">rs.initiate(configuration)<br></code></pre></td></tr></table></figure><table><thead><tr><th><strong>Parameter</strong></th><th><strong>Type</strong></th><th><strong>Description</strong></th></tr></thead><tbody><tr><td>configuration</td><td>document</td><td>Optional. A document that specifies <a href="https://www.mongodb.com/docs/manual/reference/replica-configuration/#replica-set-configuration-document">configuration</a> for the new replica set. If a configuration is not specified, MongoDB uses a default replica set configuration.</td></tr></tbody></table><p>【示例】</p><p>使用默认的配置来初始化副本集：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">rs.initiate()<br></code></pre></td></tr></table></figure><p>执行结果：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs shell">rs.initiate()<br>&#123;<br>&quot;info2&quot; : &quot;no configuration specified. Using a default configuration for<br>the set&quot;,<br>  &quot;me&quot; : &quot;180.76.159.126:27017&quot;,<br>  &quot;ok&quot; : 1,<br>  &quot;operationTime&quot; : Timestamp(1565760476, 1),<br>  &quot;$clusterTime&quot; : &#123;<br>    &quot;clusterTime&quot; : Timestamp(1565760476, 1),<br>    &quot;signature&quot; : &#123;<br>      &quot;hash&quot; : BinData(0,&quot;AAAAAAAAAAAAAAAAAAAAAAAAAAA=&quot;),<br>      &quot;keyId&quot; : NumberLong(0)<br>&#125;<br>&#125;<br>&#125;<br>myrs:SECONDARY&gt;<br>myrs:PRIMARY&gt;<br></code></pre></td></tr></table></figure><p>提示：</p><p>1）“ok”的值为1，说明创建成功。</p><p>2）命令行提示符发生变化，变成了一个从节点角色，此时默认不能读写。稍等片刻，回车，变成主节点。</p><h3 id="查看副本集的配置内容"><a href="#查看副本集的配置内容" class="headerlink" title="查看副本集的配置内容"></a>查看副本集的配置内容</h3><p>说明：</p><p>返回包含当前副本集配置的文档。</p><p>语法：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">rs.conf(configuration)<br></code></pre></td></tr></table></figure><p>提示：</p><p>rs.config() 是该方法的别名。</p><p>configuration：可选，如果没有配置，则使用默认主节点配置。</p><p>【示例】</p><p>在27017上执行副本集中当前节点的默认节点配置</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs shell">myrs:PRIMARY&gt; rs.conf()<br>&#123;<br>  &quot;_id&quot; : &quot;myrs&quot;,<br>  &quot;version&quot; : 1,<br>  &quot;protocolVersion&quot; : NumberLong(1),<br>  &quot;writeConcernMajorityJournalDefault&quot; : true,<br>  &quot;members&quot; : [<br>    &#123;<br>    &quot;_id&quot; : 0,<br>    &quot;host&quot; : &quot;180.76.159.126:27017&quot;,<br>    &quot;arbiterOnly&quot; : false,<br>    &quot;buildIndexes&quot; : true,<br>    &quot;hidden&quot; : false,<br>    &quot;priority&quot; : 1,<br>    &quot;tags&quot; : &#123;<br>    &#125;,<br>    &quot;slaveDelay&quot; : NumberLong(0),<br>    &quot;votes&quot; : 1<br>  &#125;<br>  ],<br>  &quot;settings&quot; : &#123;<br>    &quot;chainingAllowed&quot; : true,<br>    &quot;heartbeatIntervalMillis&quot; : 2000,<br>    &quot;heartbeatTimeoutSecs&quot; : 10,<br>    &quot;electionTimeoutMillis&quot; : 10000,<br>    &quot;catchUpTimeoutMillis&quot; : -1,<br>    &quot;catchUpTakeoverDelayMillis&quot; : 30000,<br>    &quot;getLastErrorModes&quot; : &#123;<br>  &#125;,<br>  &quot;getLastErrorDefaults&quot; : &#123;<br>    &quot;w&quot; : 1,<br>    &quot;wtimeout&quot; : 0<br>  &#125;,<br>  &quot;replicaSetId&quot; : ObjectId(&quot;5d539bdcd6a308e600d126bb&quot;)<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>说明：</p><p>1） “_id” : “myrs” ：副本集的配置数据存储的主键值，默认就是副本集的名字</p><p>2） “members” ：副本集成员数组，此时只有一个： “host” : “180.76.159.126:27017” ，该成员不是仲裁节点： “arbiterOnly” : false ，优先级（权重值）： “priority” : 1,</p><p>3） “settings” ：副本集的参数配置。</p><p>提示：副本集配置的查看命令，本质是查询的是 system.replset 的表中的数据：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs shell">myrs:PRIMARY&gt; use local<br>switched to db local<br>myrs:PRIMARY&gt; show collections<br>oplog.rs<br>replset.election<br>replset.minvalid<br>replset.oplogTruncateAfterPoint<br>startup_log<br>system.replset<br>system.rollback.id<br>myrs:PRIMARY&gt; db.system.replset.find()<br>&#123; &quot;_id&quot; : &quot;myrs&quot;, &quot;version&quot; : 1, &quot;protocolVersion&quot; : NumberLong(1),<br>&quot;writeConcernMajorityJournalDefault&quot; : true, &quot;members&quot; : [ &#123; &quot;_id&quot; : 0, &quot;host&quot; :<br>&quot;180.76.159.126:27017&quot;, &quot;arbiterOnly&quot; : false, &quot;buildIndexes&quot; : true, &quot;hidden&quot; :<br>false, &quot;priority&quot; : 1, &quot;tags&quot; : &#123; &#125;, &quot;slaveDelay&quot; : NumberLong(0), &quot;votes&quot; : 1<br>&#125; ], &quot;settings&quot; : &#123; &quot;chainingAllowed&quot; : true, &quot;heartbeatIntervalMillis&quot; : 2000,<br>&quot;heartbeatTimeoutSecs&quot; : 10, &quot;electionTimeoutMillis&quot; : 10000,<br>&quot;catchUpTimeoutMillis&quot; : -1, &quot;catchUpTakeoverDelayMillis&quot; : 30000,<br>&quot;getLastErrorModes&quot; : &#123; &#125;, &quot;getLastErrorDefaults&quot; : &#123; &quot;w&quot; : 1, &quot;wtimeout&quot; : 0<br>&#125;, &quot;replicaSetId&quot; : ObjectId(&quot;5d539bdcd6a308e600d126bb&quot;) &#125; &#125;<br>myrs:PRIMARY&gt;<br></code></pre></td></tr></table></figure><h3 id="查看副本集状态"><a href="#查看副本集状态" class="headerlink" title="查看副本集状态"></a>查看副本集状态</h3><p>检查副本集状态。</p><p>说明：</p><p>返回包含状态信息的文档。此输出使用从副本集的其他成员发送的心跳包中获得的数据反映副本集的当前状态。</p><p>语法：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">rs.status()<br></code></pre></td></tr></table></figure><p>【示例】</p><p>在27017上查看副本集状态：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs shell">myrs:PRIMARY&gt; rs.status()<br>&#123;  <br>  &quot;set&quot;: &quot;myrs&quot;,  <br>  &quot;date&quot;: &quot;ISODate(\&quot;2019-08-14T05:29:45.161Z\&quot;)&quot;,  <br>  &quot;myState&quot;: 1,  <br>  &quot;term&quot;: &quot;NumberLong(1)&quot;,  <br>  &quot;syncingTo&quot;: &quot;&quot;,  <br>  &quot;syncSourceHost&quot;: &quot;&quot;,  <br>  &quot;syncSourceId&quot;: -1,  <br>  &quot;heartbeatIntervalMillis&quot;: &quot;NumberLong(2000)&quot;,  <br>  &quot;optimes&quot;: &#123;  <br>    &quot;lastCommittedOpTime&quot;: &#123;  <br>      &quot;ts&quot;: &quot;Timestamp(1565760578, 1)&quot;,  <br>      &quot;t&quot;: &quot;NumberLong(1)&quot;  <br>    &#125;,  <br>    &quot;readConcernMajorityOpTime&quot;: &#123;  <br>      &quot;ts&quot;: &quot;Timestamp(1565760578, 1)&quot;,  <br>      &quot;t&quot;: &quot;NumberLong(1)&quot;  <br>    &#125;,  <br>    &quot;appliedOpTime&quot;: &#123;  <br>      &quot;ts&quot;: &quot;Timestamp(1565760578, 1)&quot;,  <br>      &quot;t&quot;: &quot;NumberLong(1)&quot;  <br>    &#125;,  <br>    &quot;durableOpTime&quot;: &#123;  <br>      &quot;ts&quot;: &quot;Timestamp(1565760578, 1)&quot;,  <br>      &quot;t&quot;: &quot;NumberLong(1)&quot;  <br>    &#125;  <br>  &#125;,  <br>  &quot;lastStableCheckpointTimestamp&quot;: &quot;Timestamp(1565760528, 1)&quot;,  <br>  &quot;members&quot;: [  <br>    &#123;  <br>      &quot;_id&quot;: 0,  <br>      &quot;name&quot;: &quot;180.76.159.126:27017&quot;,  <br>      &quot;health&quot;: 1,  <br>      &quot;state&quot;: 1,  <br>      &quot;stateStr&quot;: &quot;PRIMARY&quot;,  <br>      &quot;uptime&quot;: 419,  <br>      &quot;optime&quot;: &#123;  <br>        &quot;ts&quot;: &quot;Timestamp(1565760578, 1)&quot;,  <br>        &quot;t&quot;: &quot;NumberLong(1)&quot;  <br>      &#125;,  <br>      &quot;optimeDate&quot;: &quot;ISODate(\&quot;2019-08-14T05:29:38Z\&quot;)&quot;,  <br>      &quot;syncingTo&quot;: &quot;&quot;,  <br>      &quot;syncSourceHost&quot;: &quot;&quot;,  <br>      &quot;syncSourceId&quot;: -1,  <br>      &quot;infoMessage&quot;: &quot;could not find member to sync from&quot;,  <br>      &quot;electionTime&quot;: &quot;Timestamp(1565760476, 2)&quot;,  <br>      &quot;electionDate&quot;: &quot;ISODate(\&quot;2019-08-14T05:27:56Z\&quot;)&quot;,  <br>      &quot;configVersion&quot;: 1,  <br>      &quot;self&quot;: true,  <br>      &quot;lastHeartbeatMessage&quot;: &quot;&quot;  <br>    &#125;  <br>  ],  <br>  &quot;ok&quot;: 1,  <br>  &quot;operationTime&quot;: &quot;Timestamp(1565760578, 1)&quot;,  <br>  &quot;$clusterTime&quot;: &#123;  <br>    &quot;clusterTime&quot;: &quot;Timestamp(1565760578, 1)&quot;,  <br>    &quot;signature&quot;: &#123;  <br>      &quot;hash&quot;: &quot;BinData(0,\&quot;AAAAAAAAAAAAAAAAAAAAAAAAAAA=\&quot;)&quot;,  <br>      &quot;keyId&quot;: &quot;NumberLong(0)&quot;  <br>    &#125;  <br>  &#125;  <br>&#125;<br></code></pre></td></tr></table></figure><p>说明：</p><p>1） “set” : “myrs” ：副本集的名字</p><p>2） “myState” : 1：说明状态正常</p><p>3） “members” ：副本集成员数组，此时只有一个： “name” : “180.76.159.126:27017” ，该成员的角色是 “stateStr” : “PRIMARY”, 该节点是健康的： “health” : 1 </p><h3 id="添加副本从节点"><a href="#添加副本从节点" class="headerlink" title="添加副本从节点"></a>添加副本从节点</h3><p>在主节点添加从节点，将其他成员加入到副本集</p><p>语法：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">rs.add(host, arbiterOnly)<br></code></pre></td></tr></table></figure><p>选项：</p><table><thead><tr><th><strong>Parameter</strong></th><th><strong>Type</strong></th><th><strong>Description</strong></th></tr></thead><tbody><tr><td>host</td><td>string or document</td><td>要添加到副本集的新成员。 指定为字符串或配置文档：1）如果是一个字符串，则需要指定新成员的主机名和可选的端口号；2）如果是一个文档，请指定在members数组中找到的副本集成员配置文档。 您必须在成员配置文档中指定主机字段。有关文档配置字段的说明，详见下方文档：“主机成员的配置文档”</td></tr><tr><td>arbiteronly</td><td>boolean</td><td>可选的。 仅在 <host> 值为字符串时适用。 如果为true，则添加的主机是仲裁者。</td></tr></tbody></table><p>主机成员的配置文档：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs shell">&#123;<br>  _id: &lt;int&gt;,<br>  host: &lt;string&gt;, // required<br>  arbiterOnly: &lt;boolean&gt;,<br>  buildIndexes: &lt;boolean&gt;,<br>  hidden: &lt;boolean&gt;,<br>  priority: &lt;number&gt;,<br>  tags: &lt;document&gt;,<br>  slaveDelay: &lt;int&gt;,<br>  votes: &lt;number&gt;<br>&#125;<br></code></pre></td></tr></table></figure><p>【示例】</p><p>将27018的副本节点添加到副本集中：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs shell">myrs:PRIMARY&gt; rs.add(&quot;180.76.159.126:27018&quot;)<br>&#123;  <br>  &quot;ok&quot;: 1,  <br>  &quot;operationTime&quot;: &quot;Timestamp(1565761757, 1)&quot;,  <br>  &quot;$clusterTime&quot;: &#123;  <br>    &quot;clusterTime&quot;: &quot;Timestamp(1565761757, 1)&quot;,  <br>    &quot;signature&quot;: &#123;  <br>      &quot;hash&quot;: &quot;BinData(0,\&quot;AAAAAAAAAAAAAAAAAAAAAAAAAAA=\&quot;)&quot;,  <br>      &quot;keyId&quot;: &quot;NumberLong(0)&quot;  <br>    &#125;  <br>  &#125;  <br>&#125;<br></code></pre></td></tr></table></figure><p>说明：</p><p>1） “ok” : 1 ：说明添加成功。</p><p>查看副本集状态：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><code class="hljs shell">myrs:PRIMARY&gt; rs.status()<br>&#123;<br>    &quot;set&quot; : &quot;myrs&quot;,<br>    &quot;date&quot; : ISODate(&quot;2019-08-14T05:50:05.738Z&quot;),<br>    &quot;myState&quot; : 1,<br>    &quot;term&quot; : NumberLong(1),<br>    &quot;syncingTo&quot; : &quot;&quot;,<br>    &quot;syncSourceHost&quot; : &quot;&quot;,<br>    &quot;syncSourceId&quot; : -1,<br>    &quot;heartbeatIntervalMillis&quot; : NumberLong(2000),<br>    &quot;optimes&quot; : &#123;<br>        &quot;lastCommittedOpTime&quot; : &#123;<br>            &quot;ts&quot; : Timestamp(1565761798, 1),<br>            &quot;t&quot; : NumberLong(1)<br>        &#125;,<br>        &quot;readConcernMajorityOpTime&quot; : &#123;<br>            &quot;ts&quot; : Timestamp(1565761798, 1),<br>            &quot;t&quot; : NumberLong(1)<br>        &#125;,<br>        &quot;appliedOpTime&quot; : &#123;<br>            &quot;ts&quot; : Timestamp(1565761798, 1),<br>            &quot;t&quot; : NumberLong(1)<br>        &#125;,<br>        &quot;durableOpTime&quot; : &#123;<br>            &quot;ts&quot; : Timestamp(1565761798, 1),<br>            &quot;t&quot; : NumberLong(1)<br>        &#125;<br>    &#125;,<br>    &quot;lastStableCheckpointTimestamp&quot; : Timestamp(1565761798, 1),<br>    &quot;members&quot; : [<br>        &#123;<br>            &quot;_id&quot; : 0,<br>            &quot;name&quot; : &quot;180.76.159.126:27017&quot;,<br>            &quot;health&quot; : 1,<br>            &quot;state&quot; : 1,<br>            &quot;stateStr&quot; : &quot;PRIMARY&quot;,<br>            &quot;uptime&quot; : 1639,<br>            &quot;optime&quot; : &#123;<br>                &quot;ts&quot; : Timestamp(1565761798, 1),<br>                &quot;t&quot; : NumberLong(1)<br>            &#125;,<br>            &quot;optimeDate&quot; : ISODate(&quot;2019-08-14T05:49:58Z&quot;),<br>            &quot;syncingTo&quot; : &quot;&quot;,<br>            &quot;syncSourceHost&quot; : &quot;&quot;,<br>            &quot;syncSourceId&quot; : -1,<br>            &quot;infoMessage&quot; : &quot;&quot;,<br>            &quot;electionTime&quot; : Timestamp(1565760476, 2),<br>            &quot;electionDate&quot; : ISODate(&quot;2019-08-14T05:27:56Z&quot;),<br>            &quot;configVersion&quot; : 2,<br>            &quot;self&quot; : true,<br>            &quot;lastHeartbeatMessage&quot; : &quot;&quot;<br>        &#125;,<br>        &#123;<br>            &quot;_id&quot; : 1,<br>            &quot;name&quot; : &quot;180.76.159.126:27018&quot;,<br>            &quot;health&quot; : 1,<br>            &quot;state&quot; : 2,<br>            &quot;stateStr&quot; : &quot;SECONDARY&quot;,<br>            &quot;uptime&quot; : 48,<br>            &quot;optime&quot; : &#123;<br>                &quot;ts&quot; : Timestamp(1565761798, 1),<br>                &quot;t&quot; : NumberLong(1)<br>            &#125;,<br>            &quot;optimeDurable&quot; : &#123;<br>                &quot;ts&quot; : Timestamp(1565761798, 1),<br>                &quot;t&quot; : NumberLong(1)<br>            &#125;,<br>            &quot;optimeDate&quot; : ISODate(&quot;2019-08-14T05:49:58Z&quot;),<br>            &quot;optimeDurableDate&quot; : ISODate(&quot;2019-08-14T05:49:58Z&quot;),<br>            &quot;lastHeartbeat&quot; : ISODate(&quot;2019-08-14T05:50:05.294Z&quot;),<br>            &quot;lastHeartbeatRecv&quot; : ISODate(&quot;2019-08-14T05:50:05.476Z&quot;),<br>            &quot;pingMs&quot; : NumberLong(0),<br>            &quot;lastHeartbeatMessage&quot; : &quot;&quot;,<br>            &quot;syncingTo&quot; : &quot;180.76.159.126:27017&quot;,<br>            &quot;syncSourceHost&quot; : &quot;180.76.159.126:27017&quot;,<br>            &quot;syncSourceId&quot; : 0,<br>            &quot;infoMessage&quot; : &quot;&quot;,<br>            &quot;configVersion&quot; : 2<br>        &#125;<br>    ],<br>    &quot;ok&quot; : 1,<br>    &quot;operationTime&quot; : Timestamp(1565761798, 1),<br>    &quot;$clusterTime&quot; : &#123;<br>        &quot;clusterTime&quot; : Timestamp(1565761798, 1),<br>        &quot;signature&quot; : &#123;<br>            &quot;hash&quot; : BinData(0, &quot;AAAAAAAAAAAAAAAAAAAAAAAAAAA=&quot;),<br>            &quot;keyId&quot; : NumberLong(0)<br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>说明：</p><p>1） “name” : “180.76.159.126:27018” 是第二个节点的名字，其角色是 “stateStr” : “SECONDARY”</p><h3 id="添加仲裁节点"><a href="#添加仲裁节点" class="headerlink" title="添加仲裁节点"></a>添加仲裁节点</h3><p>添加一个仲裁节点到副本集</p><p>语法：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">rs.addArb(host)<br></code></pre></td></tr></table></figure><p>将27019的仲裁节点添加到副本集中：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs shell">myrs:PRIMARY&gt; rs.addArb(&quot;180.76.159.126:27019&quot;)<br>&#123;<br>    &quot;ok&quot; : 1,<br>    &quot;operationTime&quot; : Timestamp(1565761959, 1),<br>    &quot;$clusterTime&quot; : &#123;<br>        &quot;clusterTime&quot; : Timestamp(1565761959, 1),<br>        &quot;signature&quot; : &#123;<br>            &quot;hash&quot; : BinData(0,&quot;AAAAAAAAAAAAAAAAAAAAAAAAAAA=&quot;),<br>            &quot;keyId&quot; : NumberLong(0)<br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>说明：</p><p>1） “ok” : 1 ：说明添加成功。</p><p>查看副本集状态：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><code class="hljs shell">myrs:PRIMARY&gt; rs.status()<br>&#123;<br>    &quot;set&quot; : &quot;myrs&quot;,<br>    &quot;date&quot; : ISODate(&quot;2019-08-14T05:53:27.198Z&quot;),<br>    &quot;myState&quot; : 1,<br>    &quot;term&quot; : NumberLong(1),<br>    &quot;syncingTo&quot; : &quot;&quot;,<br>    &quot;syncSourceHost&quot; : &quot;&quot;,<br>    &quot;syncSourceId&quot; : -1,<br>    &quot;heartbeatIntervalMillis&quot; : NumberLong(2000),<br>    &quot;optimes&quot; : &#123;<br>        &quot;lastCommittedOpTime&quot; : &#123;<br>            &quot;ts&quot; : Timestamp(1565761998, 1),<br>            &quot;t&quot; : NumberLong(1)<br>        &#125;,<br>        &quot;readConcernMajorityOpTime&quot; : &#123;<br>            &quot;ts&quot; : Timestamp(1565761998, 1),<br>            &quot;t&quot; : NumberLong(1)<br>        &#125;,<br>        &quot;appliedOpTime&quot; : &#123;<br>            &quot;ts&quot; : Timestamp(1565761998, 1),<br>            &quot;t&quot; : NumberLong(1)<br>        &#125;,<br>        &quot;durableOpTime&quot; : &#123;<br>            &quot;ts&quot; : Timestamp(1565761998, 1),<br>            &quot;t&quot; : NumberLong(1)<br>        &#125;<br>    &#125;,<br>    &quot;lastStableCheckpointTimestamp&quot; : Timestamp(1565761978, 1),<br>    &quot;members&quot; : [<br>        &#123;<br>            &quot;_id&quot; : 0,<br>            &quot;name&quot; : &quot;180.76.159.126:27017&quot;,<br>            &quot;health&quot; : 1,<br>            &quot;state&quot; : 1,<br>            &quot;stateStr&quot; : &quot;PRIMARY&quot;,<br>            &quot;uptime&quot; : 1841,<br>            &quot;optime&quot; : &#123;<br>                &quot;ts&quot; : Timestamp(1565761998, 1),<br>                &quot;t&quot; : NumberLong(1)<br>            &#125;,<br>            &quot;optimeDate&quot; : ISODate(&quot;2019-08-14T05:53:18Z&quot;),<br>            &quot;syncingTo&quot; : &quot;&quot;,<br>            &quot;syncSourceHost&quot; : &quot;&quot;,<br>            &quot;syncSourceId&quot; : -1,<br>            &quot;infoMessage&quot; : &quot;&quot;,<br>            &quot;electionTime&quot; : Timestamp(1565760476, 2),<br>            &quot;electionDate&quot; : ISODate(&quot;2019-08-14T05:27:56Z&quot;),<br>            &quot;configVersion&quot; : 3,<br>            &quot;self&quot; : true,<br>            &quot;lastHeartbeatMessage&quot; : &quot;&quot;<br>        &#125;,<br>        &#123;<br>            &quot;_id&quot; : 1,<br>            &quot;name&quot; : &quot;180.76.159.126:27018&quot;,<br>            &quot;health&quot; : 1,<br>            &quot;state&quot; : 2,<br>            &quot;stateStr&quot; : &quot;SECONDARY&quot;,<br>            &quot;uptime&quot; : 249,<br>            &quot;optime&quot; : &#123;<br>                &quot;ts&quot; : Timestamp(1565761998, 1),<br>                &quot;t&quot; : NumberLong(1)<br>            &#125;,<br>            &quot;optimeDurable&quot; : &#123;<br>                &quot;ts&quot; : Timestamp(1565761998, 1),<br>                &quot;t&quot; : NumberLong(1)<br>            &#125;,<br>            &quot;optimeDate&quot; : ISODate(&quot;2019-08-14T05:53:18Z&quot;),<br>            &quot;optimeDurableDate&quot; : ISODate(&quot;2019-08-14T05:53:18Z&quot;),<br>            &quot;lastHeartbeat&quot; : ISODate(&quot;2019-08-14T05:53:25.668Z&quot;),<br>            &quot;lastHeartbeatRecv&quot; : ISODate(&quot;2019-08-14T05:53:26.702Z&quot;),<br>            &quot;pingMs&quot; : NumberLong(0),<br>            &quot;lastHeartbeatMessage&quot; : &quot;&quot;,<br>            &quot;syncingTo&quot; : &quot;180.76.159.126:27017&quot;,<br>            &quot;syncSourceHost&quot; : &quot;180.76.159.126:27017&quot;,<br>            &quot;syncSourceId&quot; : 0,<br>            &quot;infoMessage&quot; : &quot;&quot;,<br>            &quot;configVersion&quot; : 3<br>        &#125;,<br>        &#123;<br>            &quot;_id&quot; : 2,<br>            &quot;name&quot; : &quot;180.76.159.126:27019&quot;,<br>            &quot;health&quot; : 1,<br>            &quot;state&quot; : 7,<br>            &quot;stateStr&quot; : &quot;ARBITER&quot;,<br>            &quot;uptime&quot; : 47,<br>            &quot;lastHeartbeat&quot; : ISODate(&quot;2019-08-14T05:53:25.668Z&quot;),<br>            &quot;lastHeartbeatRecv&quot; : ISODate(&quot;2019-08-14T05:53:25.685Z&quot;),<br>            &quot;pingMs&quot; : NumberLong(0),<br>            &quot;lastHeartbeatMessage&quot; : &quot;&quot;,<br>            &quot;syncingTo&quot; : &quot;&quot;,<br>            &quot;syncSourceHost&quot; : &quot;&quot;,<br>            &quot;syncSourceId&quot; : -1,<br>            &quot;infoMessage&quot; : &quot;&quot;,<br>            &quot;configVersion&quot; : 3<br>        &#125;<br>    ],<br>    &quot;ok&quot; : 1,<br>    &quot;operationTime&quot; : Timestamp(1565761998, 1),<br>    &quot;$clusterTime&quot; : &#123;<br>        &quot;clusterTime&quot; : Timestamp(1565761998, 1),<br>        &quot;signature&quot; : &#123;<br>            &quot;hash&quot; : BinData(0,&quot;AAAAAAAAAAAAAAAAAAAAAAAAAAA=&quot;),<br>            &quot;keyId&quot; : NumberLong(0)<br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>说明：</p><p>1） “name” : “180.76.159.126:27019” 是第二个节点的名字，其角色是 “stateStr” : “ARBITER”</p><h2 id="副本集的读写操作"><a href="#副本集的读写操作" class="headerlink" title="副本集的读写操作"></a>副本集的读写操作</h2><p>目标：测试三个不同角色的节点的数据读写情况。</p><p>登录主节点27017，写入和读取数据：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@bobohost ~]# /usr/local/mongodb/bin/mongo --host 180.76.159.126 --port<br>27017<br>myrs:PRIMARY&gt; use articledb<br>switched to db articledb<br>myrs:PRIMARY&gt; db<br>articledb<br>myrs:PRIMARY&gt; db.comment.insert(&#123;&quot;articleid&quot;:&quot;100000&quot;,&quot;content&quot;:&quot;今天天气真好，阳光<br>明媚&quot;,&quot;userid&quot;:&quot;1001&quot;,&quot;nickname&quot;:&quot;Rose&quot;,&quot;createdatetime&quot;:new Date()&#125;)<br>WriteResult(&#123; &quot;nInserted&quot; : 1 &#125;)<br>myrs:PRIMARY&gt; db.comment.find()<br>&#123; &quot;_id&quot; : ObjectId(&quot;5d4d2ae3068138b4570f53bf&quot;), &quot;articleid&quot; : &quot;100000&quot;,<br>&quot;content&quot; : &quot;今天天气真好，阳光明媚&quot;, &quot;userid&quot; : &quot;1001&quot;, &quot;nickname&quot; : &quot;Rose&quot;,<br>&quot;createdatetime&quot; : ISODate(&quot;2019-08-09T08:12:19.427Z&quot;) &#125;<br></code></pre></td></tr></table></figure><p>登录从节点27018</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@bobohost ~]# /usr/local/mongodb/bin/mongo --host 180.76.159.126 --port<br>27018<br>myrs:SECONDARY&gt; show dbs;<br>2019-09-10T10:56:51.953+0800 E QUERY [js] Error: listDatabases failed:&#123;<br>  &quot;operationTime&quot; : Timestamp(1568084204, 1),<br>  &quot;ok&quot; : 0,<br>  &quot;errmsg&quot; : &quot;not master and slaveOk=false&quot;,<br>  &quot;code&quot; : 13435,<br>  &quot;codeName&quot; : &quot;NotMasterNoSlaveOk&quot;,<br>  &quot;$clusterTime&quot; : &#123;<br>    &quot;clusterTime&quot; : Timestamp(1568084204, 1),<br>    &quot;signature&quot; : &#123;<br>      &quot;hash&quot; : BinData(0,&quot;AAAAAAAAAAAAAAAAAAAAAAAAAAA=&quot;),<br>      &quot;keyId&quot; : NumberLong(0)<br>    &#125;<br>  &#125;<br>&#125; :<br>_getErrorWithCode@src/mongo/shell/utils.js:25:13<br>Mongo.prototype.getDBs@src/mongo/shell/mongo.js:139:1<br>shellHelper.show@src/mongo/shell/utils.js:882:13<br>shellHelper@src/mongo/shell/utils.js:766:15<br>@(shellhelp2):1:1<br></code></pre></td></tr></table></figure><p>发现，不能读取集合的数据。当前从节点只是一个备份，不是奴隶节点，无法读取数据，写当然更不行。</p><p>因为默认情况下，从节点是没有读写权限的，可以增加读的权限，但需要进行设置。</p><p>设置读操作权限：</p><p>说明：</p><p>设置为奴隶节点，允许在从成员上运行读的操作</p><p>语法：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">rs.slaveOk()<br><span class="hljs-meta prompt_">#</span><span class="language-bash">或</span><br>rs.slaveOk(true)<br></code></pre></td></tr></table></figure><p>提示：</p><p>该命令是 db.getMongo().setSlaveOk() 的简化命令。</p><p>【示例】</p><p>在27018上设置作为奴隶节点权限，具备读权限：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">rs:SECONDARY&gt; rs.slaveOk()<br></code></pre></td></tr></table></figure><p>此时，在执行查询命令，运行成功！</p><p>但仍然不允许插入。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs shell">myrs:SECONDARY&gt; rs.slaveOk()<br>myrs:SECONDARY&gt; show dbs;<br>admin 0.000GB<br>articledb 0.000GB<br>config 0.000GB<br>local 0.000GB<br>myrs:SECONDARY&gt; use articledb<br>switched to db articledb<br>myrs:SECONDARY&gt; show collections<br>comment<br>myrs:SECONDARY&gt; db.comment.find()<br>&#123; &quot;_id&quot; : ObjectId(&quot;5d7710c04cfd7eee2e3cdabe&quot;), &quot;articleid&quot; : &quot;100000&quot;,<br>&quot;content&quot; : &quot;今天天气真好，阳光明媚&quot;, &quot;userid&quot; : &quot;1001&quot;, &quot;nickname&quot; : &quot;Rose&quot;,<br>&quot;createdatetime&quot; : ISODate(&quot;2019-09-10T02:56:00.467Z&quot;) &#125;<br>myrs:SECONDARY&gt; db.comment.insert(&#123;&quot;_id&quot;:&quot;1&quot;,&quot;articleid&quot;:&quot;100001&quot;,&quot;content&quot;:&quot;我们<br>不应该把清晨浪费在手机上，健康很重要，k一杯温水幸福你我<br>他。&quot;,&quot;userid&quot;:&quot;1002&quot;,&quot;nickname&quot;:&quot;相忘于江湖&quot;,&quot;createdatetime&quot;:new Date(&quot;2019-08-<br>05T22:08:15.522Z&quot;),&quot;likenum&quot;:NumberInt(1000),&quot;state&quot;:&quot;1&quot;&#125;)<br>WriteCommandError(&#123;<br>  &quot;operationTime&quot; : Timestamp(1568084434, 1),<br>  &quot;ok&quot; : 0,<br>  &quot;errmsg&quot; : &quot;not master&quot;,<br>  &quot;code&quot; : 10107,<br>  &quot;codeName&quot; : &quot;NotMaster&quot;,<br>  &quot;$clusterTime&quot; : &#123;<br>  &quot;clusterTime&quot; : Timestamp(1568084434, 1),<br>    &quot;signature&quot; : &#123;<br>      &quot;hash&quot; : BinData(0,&quot;AAAAAAAAAAAAAAAAAAAAAAAAAAA=&quot;),<br>      &quot;keyId&quot; : NumberLong(0)<br>    &#125;<br>  &#125;<br>&#125;)<br></code></pre></td></tr></table></figure><p>现在可实现了读写分离，让主插入数据，让从来读取数据。</p><p>如果要取消作为奴隶节点的读权限：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs shell">myrs:SECONDARY&gt; rs.slaveOk(false)<br>myrs:SECONDARY&gt; db.comment.find()<br>Error: error: &#123;<br>  &quot;operationTime&quot; : Timestamp(1568084459, 1),<br>  &quot;ok&quot; : 0,<br>  &quot;errmsg&quot; : &quot;not master and slaveOk=false&quot;,<br>  &quot;code&quot; : 13435,<br>  &quot;codeName&quot; : &quot;NotMasterNoSlaveOk&quot;,<br>  &quot;$clusterTime&quot; : &#123;<br>    &quot;clusterTime&quot; : Timestamp(1568084459, 1),<br>    &quot;signature&quot; : &#123;<br>      &quot;hash&quot; : BinData(0,&quot;AAAAAAAAAAAAAAAAAAAAAAAAAAA=&quot;),<br>      &quot;keyId&quot; : NumberLong(0)<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>仲裁者节点，不存放任何业务数据的，可以登录查看</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@bobohost ~]# /usr/local/mongodb/bin/mongo --host 180.76.159.126 --port<br>27019<br>myrs:ARBITER&gt; rs.slaveOk()<br>myrs:ARBITER&gt; show dbs<br>local 0.000GB<br>myrs:ARBITER&gt; use local<br>switched to db local<br>myrs:ARBITER&gt; show collections<br>replset.minvalid<br>replset.oplogTruncateAfterPoint<br>startup_log<br>system.replset<br>system.rollback.id<br>myrs:ARBITER&gt;<br></code></pre></td></tr></table></figure><p>发现，只存放副本集配置等数据。</p><h2 id="主节点的选举原则"><a href="#主节点的选举原则" class="headerlink" title="主节点的选举原则"></a>主节点的选举原则</h2><p>MongoDB在副本集中，会自动进行主节点的选举，主节点选举的触发条件：</p><p>1） 主节点故障</p><p>2） 主节点网络不可达（默认心跳信息为10秒）</p><p>3） 人工干预（rs.stepDown(600)）</p><p>一旦触发选举，就要根据一定规则来选主节点。</p><p>选举规则是根据票数来决定谁获胜：</p><ul><li>票数最高，且获得了“大多数”成员的投票支持的节点获胜。“大多数”的定义为：假设复制集内投票成员数量为N，则大多数为 N&#x2F;2 + 1。例如：3个投票成员，则大多数的值是2。当复制集内存活成员数量不足大多数时，整个复制集将无法选举出Primary，复制集将无法提供写服务，处于只读状态。</li><li>若票数相同，且都获得了“大多数”成员的投票支持的，数据新的节点获胜。数据的新旧是通过操作日志oplog来对比的。</li></ul><p>在获得票数的时候，优先级（priority）参数影响重大。</p><p>可以通过设置优先级（priority）来设置额外票数。优先级即权重，取值为0-1000，相当于可额外增加0-1000的票数，优先级的值越大，就越可能获得多数成员的投票（votes）数。指定较高的值可使成员更有资格成为主要成员，更低的值可使成员更不符合条件。</p><p>默认情况下，优先级的值是1</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs shell">myrs:PRIMARY&gt; rs.conf()<br>&#123;<br>    &quot;_id&quot; : &quot;myrs&quot;,<br>    &quot;version&quot; : 3,<br>    &quot;protocolVersion&quot; : NumberLong(1),<br>    &quot;writeConcernMajorityJournalDefault&quot; : true,<br>    &quot;members&quot; : [<br>        &#123;<br>            &quot;_id&quot; : 0,<br>            &quot;host&quot; : &quot;180.76.159.126:27017&quot;,<br>            &quot;arbiterOnly&quot; : false,<br>            &quot;buildIndexes&quot; : true,<br>            &quot;hidden&quot; : false,<br>            &quot;priority&quot; : 1,<br>            &quot;tags&quot; : &#123;&#125;,<br>            &quot;slaveDelay&quot; : NumberLong(0),<br>            &quot;votes&quot; : 1<br>        &#125;,<br>        &#123;<br>            &quot;_id&quot; : 1,<br>            &quot;host&quot; : &quot;180.76.159.126:27018&quot;,<br>            &quot;arbiterOnly&quot; : false,<br>            &quot;buildIndexes&quot; : true,<br>            &quot;hidden&quot; : false,<br>            &quot;priority&quot; : 1,<br>            &quot;tags&quot; : &#123;&#125;,<br>            &quot;slaveDelay&quot; : NumberLong(0),<br>            &quot;votes&quot; : 1<br>        &#125;,<br>        &#123;<br>            &quot;_id&quot; : 2,<br>            &quot;host&quot; : &quot;180.76.159.126:27019&quot;,<br>            &quot;arbiterOnly&quot; : true,<br>            &quot;buildIndexes&quot; : true,<br>            &quot;hidden&quot; : false,<br>            &quot;priority&quot; : 0,<br>            &quot;tags&quot; : &#123;&#125;,<br>            &quot;slaveDelay&quot; : NumberLong(0),<br>            &quot;votes&quot; : 1<br>        &#125;<br>    ],<br>    &quot;settings&quot; : &#123;<br>        &quot;chainingAllowed&quot; : true,<br>        &quot;heartbeatIntervalMillis&quot; : 2000,<br>        &quot;heartbeatTimeoutSecs&quot; : 10,<br>        &quot;electionTimeoutMillis&quot; : 10000,<br>        &quot;catchUpTimeoutMillis&quot; : -1,<br>        &quot;catchUpTakeoverDelayMillis&quot; : 30000,<br>        &quot;getLastErrorModes&quot; : &#123;&#125;,<br>        &quot;getLastErrorDefaults&quot; : &#123;<br>            &quot;w&quot; : 1,<br>            &quot;wtimeout&quot; : 0<br>        &#125;,<br>        &quot;replicaSetId&quot; : ObjectId(&quot;5d539bdcd6a308e600d126bb&quot;)<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>可以看出，主节点和副本节点的优先级各为1，即，默认可以认为都已经有了一票。但选举节点，优先级是0，（要注意是，官方说了，选举节点的优先级必须是0，不能是别的值。即不具备选举权，但具有投票权）</p><p>【了解】修改优先级</p><p>比如，下面提升从节点的优先级：</p><p>1）先将配置导入cfg变量</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">myrs:SECONDARY&gt; cfg=rs.conf()<br></code></pre></td></tr></table></figure><p>2）然后修改值（ID号默认从0开始）：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">myrs:SECONDARY&gt; cfg.members[1].priority=2<br>2<br></code></pre></td></tr></table></figure><p>3）重新加载配置</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">myrs:SECONDARY&gt; rs.reconfig(cfg)<br>&#123; &quot;ok&quot; : 1 &#125;<br></code></pre></td></tr></table></figure><p>稍等片刻会重新开始选举。</p><h2 id="故障测试"><a href="#故障测试" class="headerlink" title="故障测试"></a>故障测试</h2><h3 id="副本节点故障测试"><a href="#副本节点故障测试" class="headerlink" title="副本节点故障测试"></a>副本节点故障测试</h3><p>关闭27018副本节点：</p><p>发现，主节点和仲裁节点对27018的心跳失败。因为主节点还在，因此，没有触发投票选举。</p><p>如果此时，在主节点写入数据。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">db.comment.insert(&#123;&quot;_id&quot;:&quot;1&quot;,&quot;articleid&quot;:&quot;100001&quot;,&quot;content&quot;:&quot;我们不应该把清晨浪费在<br>手机上，健康很重要，一杯温水幸福你我他。&quot;,&quot;userid&quot;:&quot;1002&quot;,&quot;nickname&quot;:&quot;相忘于江<br>湖&quot;,&quot;createdatetime&quot;:new Date(&quot;2019-08-<br>05T22:08:15.522Z&quot;),&quot;likenum&quot;:NumberInt(1000),&quot;state&quot;:&quot;1&quot;&#125;)<br></code></pre></td></tr></table></figure><p>再启动从节点，会发现，主节点写入的数据，会自动同步给从节点。</p><h3 id="主节点故障测试"><a href="#主节点故障测试" class="headerlink" title="主节点故障测试"></a>主节点故障测试</h3><p>关闭27017节点</p><p>发现，从节点和仲裁节点对27017的心跳失败，当失败超过10秒，此时因为没有主节点了，会自动发起投票。</p><p>而副本节点只有27018，因此，候选人只有一个就是27018，开始投票。</p><p>27019向27018投了一票，27018本身自带一票，因此共两票，超过了“大多数”</p><p>27019是仲裁节点，没有选举权，27018不向其投票，其票数是0.</p><p>最终结果，27018成为主节点。具备读写功能。</p><p>在27018写入数据查看。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">db.comment.insert(&#123;&quot;_id&quot;:&quot;2&quot;,&quot;articleid&quot;:&quot;100001&quot;,&quot;content&quot;:&quot;我夏天空腹喝凉开水，冬<br>天喝温开水&quot;,&quot;userid&quot;:&quot;1005&quot;,&quot;nickname&quot;:&quot;伊人憔悴&quot;,&quot;createdatetime&quot;:new Date(&quot;2019-<br>08-05T23:58:51.485Z&quot;),&quot;likenum&quot;:NumberInt(888),&quot;state&quot;:&quot;1&quot;&#125;)<br></code></pre></td></tr></table></figure><p>再启动27017节点，发现27017变成了从节点，27018仍保持主节点。</p><p>登录27017节点，发现是从节点了，数据自动从27018同步。</p><p>从而实现了高可用。</p><h3 id="仲裁节点和主节点故障"><a href="#仲裁节点和主节点故障" class="headerlink" title="仲裁节点和主节点故障"></a>仲裁节点和主节点故障</h3><p>先关掉仲裁节点27019，</p><p>关掉现在的主节点27018</p><p>登录27017后，发现，27017仍然是从节点，副本集中没有主节点了，导致此时，副本集是只读状态，无法写入。</p><p>为啥不选举了？因为27017的票数，没有获得大多数，即没有大于等于2，它只有默认的一票（优先级是1）</p><p>如果要触发选举，随便加入一个成员即可。</p><ul><li>如果只加入27019仲裁节点成员，则主节点一定是27017，因为没得选了，仲裁节点不参与选举，但参与投票。（不演示）</li><li>如果只加入27018节点，会发起选举。因为27017和27018都是两票，则按照谁数据新，谁当主节点。</li></ul><h3 id="仲裁节点和从节点故障"><a href="#仲裁节点和从节点故障" class="headerlink" title="仲裁节点和从节点故障"></a>仲裁节点和从节点故障</h3><p>先关掉仲裁节点27019，</p><p>关掉现在的副本节点27018</p><p>10秒后，27017主节点自动降级为副本节点。（服务降级）</p><p>副本集不可写数据了，已经故障了。</p><h2 id="连接副本集"><a href="#连接副本集" class="headerlink" title="连接副本集"></a>连接副本集</h2><p>MongoDB客户端连接语法：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">mongodb://[username:password@]host1[:port1][,host2[:port2],...[,hostN[:portN]]]<br>[/[database][?options]]<br></code></pre></td></tr></table></figure><ul><li><p><strong>mongodb:&#x2F;&#x2F;</strong> 这是固定的格式，必须要指定。</p></li><li><p><strong>username:password@</strong> 可选项，如果设置，在连接数据库服务器之后，驱动都会尝试登陆这个数据库</p></li><li><p><strong>host1</strong> 必须的指定至少一个host, host1 是这个URI唯一要填写的。它指定了要连接服务器的地址。如果要连接复制集，请指定多个主机地址。</p></li><li><p><strong>portX</strong> 可选的指定端口，如果不填，默认为27017</p></li><li><p><strong>&#x2F;database</strong> 如果指定username:password@，连接并验证登陆指定数据库。若不指定，默认打开test 数据库。</p></li><li><p><strong>?options</strong> 是连接选项。如果不使用&#x2F;database，则前面需要加上&#x2F;。所有连接选项都是键值对name&#x3D;value，键值对之间通过&amp;或;（分号）隔开</p></li></ul><p>标准的连接格式包含了多个选项(options)，如下所示：</p><table><thead><tr><th>选项</th><th>描述</th></tr></thead><tbody><tr><td>replicaSet&#x3D;name</td><td>验证replica set的名称。 Impliesconnect&#x3D;replicaSet.</td></tr><tr><td>slaveOk&#x3D;true|false</td><td>true:在connect&#x3D;direct模式下，驱动会连接第一台机器，即使这台服务器不是主。在connect&#x3D;replicaSet模式下，驱动会发送所有的写请求到主并且把读取操作分布在其他从服务器。false: 在connect&#x3D;direct模式下，驱动会自动找寻主服务器. 在connect&#x3D;replicaSet 模式下，驱动仅仅连接主服务器，并且所有的读写命令都连接到主服务器。</td></tr><tr><td>safe&#x3D;true|false</td><td>true: 在执行更新操作之后，驱动都会发送getLastError命令来确保更新成功。(还要参考 wtimeoutMS).false: 在每次更新之后，驱动不会发送getLastError来确保更新成功</td></tr><tr><td>w&#x3D;n</td><td>驱动添加 { w : n } 到getLastError命令. 应用于safe&#x3D;true。</td></tr><tr><td>wtimeoutMS&#x3D;ms</td><td>驱动添加 { wtimeout : ms } 到 getlasterror 命令. 应用于 safe&#x3D;true.</td></tr><tr><td>fsync&#x3D;true|false</td><td>true: 驱动添加 { fsync : true } 到 getlasterror 命令.应用于safe&#x3D;true.false: 驱动不会添加到getLastError命令中。</td></tr><tr><td>journal&#x3D;true|false</td><td>如果设置为 true, 同步到 journal (在提交到数据库前写入到实体中).应用于 safe&#x3D;true</td></tr><tr><td>connectTimeoutMS&#x3D;ms</td><td>可以打开连接的时间。</td></tr><tr><td>socketTimeoutMS&#x3D;ms</td><td>发送和接受sockets的时间。</td></tr></tbody></table><h1 id="分片"><a href="#分片" class="headerlink" title="分片"></a>分片</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>分片（sharding）是一种跨多台机器分布数据的方法， MongoDB使用分片来支持具有非常大的数据集</p><p>和高吞吐量操作的部署。</p><p>换句话说：分片(sharding)是指将数据拆分，将其分散存在不同的机器上的过程。有时也用分区(partitioning)来表示这个概念。将数据分散到不同的机器上，不需要功能强大的大型计算机就可以储存更多的数据，处理更多的负载。</p><p>具有大型数据集或高吞吐量应用程序的数据库系统可以会挑战单个服务器的容量。例如，高查询率会耗尽服务器的CPU容量。工作集大小大于系统的RAM会强调磁盘驱动器的I &#x2F; O容量。</p><p>有两种解决系统增长的方法：垂直扩展和水平扩展。</p><p>垂直扩展意味着增加单个服务器的容量，例如使用更强大的CPU，添加更多RAM或增加存储空间量。可用技术的局限性可能会限制单个机器对于给定工作负载而言足够强大。此外，基于云的提供商基于可用的硬件配置具有硬性上限。结果，垂直缩放有实际的最大值。水平扩展意味着划分系统数据集并加载多个服务器，添加其他服务器以根据需要增加容量。虽然单个机器的总体速度或容量可能不高，但每台机器处理整个工作负载的子集，可能提供比单个高速大容量服务器更高的效率。扩展部署容量只需要根据需要添加额外的服务器，这可能比单个机器的高端硬件的总体成本更低。权衡是基础架构和部署维护的复杂性增加。</p><p>MongoDB支持通过分片进行水平扩展。</p><h2 id="分片集群包含的组件"><a href="#分片集群包含的组件" class="headerlink" title="分片集群包含的组件"></a>分片集群包含的组件</h2><p>MongoDB分片群集包含以下组件：</p><ul><li><p>分片（存储）：每个分片包含分片数据的子集。 每个分片都可以部署为副本集。</p></li><li><p>mongos（路由）：mongos充当查询路由器，在客户端应用程序和分片集群之间提供接口。</p></li><li><p>config servers（“调度”的配置）：配置服务器存储群集的元数据和配置设置。 从MongoDB 3.4开始，必须将配置服务器部署为副本集（CSRS）。</p></li></ul><p>下图描述了分片集群中组件的交互：</p><p><img src="https://gxc-hexo-blog.oss-cn-beijing.aliyuncs.com/blog/%E5%88%86%E7%89%87.png" alt="分片"></p><p>MongoDB在集合级别对数据进行分片，将集合数据分布在集群中的分片上。</p><h2 id="分片集群架构目标"><a href="#分片集群架构目标" class="headerlink" title="分片集群架构目标"></a>分片集群架构目标</h2><p>两个分片节点副本集（3+3）+一个配置节点副本集（3）+两个路由节点（2），共11个服务节点。</p><p><img src="https://gxc-hexo-blog.oss-cn-beijing.aliyuncs.com/blog/%E5%88%86%E7%89%87%E9%9B%86%E7%BE%A4%E6%9E%B6%E6%9E%84%E7%9B%AE%E6%A0%87.png"></p>]]></content>
    
    
    <categories>
      
      <category>MongoDB</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据库</tag>
      
      <tag>MongoDB</tag>
      
      <tag>NoSQL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MongoDB基本使用</title>
    <link href="/2024/06/17/MongoDB%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/"/>
    <url>/2024/06/17/MongoDB%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="1-MongoDB介绍"><a href="#1-MongoDB介绍" class="headerlink" title="1. MongoDB介绍"></a>1. MongoDB介绍</h1><h2 id="1-1-MongoDB简介"><a href="#1-1-MongoDB简介" class="headerlink" title="1.1 MongoDB简介"></a>1.1 MongoDB简介</h2><p>MongoDB是一个开源、高性能、无模式的文档型数据库，当初的设计就是用于简化开发和方便扩展，是NoSQL数据库产品中的一种。是最像关系型数据库（MySQL）的非关系型数据库。</p><p>它支持的数据结构非常松散，是一种类似于 JSON 的 格式叫BSON，所以它既可以存储比较复杂的数据类型，又相当的灵活。</p><p>MongoDB中的记录是一个文档，它是一个由字段和值对（field:value）组成的数据结构。MongoDB文档类似于JSON对象，即一个文档认为就是一个对象。字段的数据类型是字符型，它的值除了使用基本的一些类型外，还可以包括其他文档、普通数组和文档数组。</p><h2 id="1-2-业务应用场景"><a href="#1-2-业务应用场景" class="headerlink" title="1.2 业务应用场景"></a>1.2 业务应用场景</h2><p>传统的关系型数据库（如MySQL），在数据操作的“三高”需求以及应对Web2.0的网站需求面前，显得力不从心。<strong>而MongoDB可以应对。</strong></p><p>解释：“三高”需求：</p><p>• High performance - 对数据库高并发读写的需求。</p><p>• Huge Storage - 对海量数据的高效率存储和访问的需求。</p><p>• High Scalability &amp;&amp; High Availability- 对数据库的高可扩展性和高可用性的需求。</p><p>MongoDB与MySQL对比</p><table>    <tr>      <td> </td>      <td> </td>      <td>MongoDB</td>      <td>MySQL</td>    </tr>    <tr>      <td rowspan="2">高并发性</td>      <td>架构设计</td>      <td>采用无模式（schema-less）设计，文档存储（BSON 格式），可以灵活处理变更数据结构。写入操作不需要锁定整个表或重新定义表结构，写性能较高。</td>      <td>使用固定模式（schema）设计，表结构变更（例如增加列）可能需要锁定整个表，影响写入性能。虽然支持事务和行级锁定，但在高并发写入时，锁争用仍可能成为瓶颈。</td>    </tr>    <tr>      <td>并发控制</td>      <td>使用优化的锁机制（如 WiredTiger 存储引擎中的多文档级锁），并且能够通过分片在多个节点上分散写入压力。</td>      <td>尽管支持行级锁（如 InnoDB 引擎），但在高并发场景下，锁冲突和死锁的概率增大，可能导致性能下降。</td>    </tr>    <tr>      <td rowspan="2">高存储能力</td>      <td>扩展性</td>      <td>内置分片（sharding）机制，可以将数据水平拆分到多个节点，几乎无限扩展存储容量，且分片管理自动化。</td>      <td>缺乏原生的分片机制，水平扩展需要手动配置分区、分库分表，管理复杂且成本高。MySQL Cluster 也能提供一定的扩展性，但配置和维护复杂度较高。</td>    </tr>    <tr>      <td>数据模型</td>      <td>文档模型（BSON）允许嵌套和数组，适用于复杂和非结构化数据，减少了表关联（JOIN）和多表查询的需求。</td>      <td>使用关系模型，数据规范化存储，复杂查询常需要 JOIN 操作。随着数据量增加，JOIN 操作的性能瓶颈更明显。</td>    </tr>    <tr>      <td rowspan="2">高可用性</td>      <td>复制与故障转移</td>      <td>内置复制集（Replica Sets）机制，支持自动故障转移。当主节点故障时，副本节点可以自动提升为主节点，确保高可用性。</td>      <td>支持主从复制和半同步复制，但自动故障转移需要额外配置（如使用 MHA 或 Percona XtraDB Cluster），增加了系统复杂度和维护难度。</td>    </tr>    <tr>      <td>分布式架构</td>      <td>从设计上就是分布式系统，支持地理分布的分片和复制，提高了系统的灾难恢复能力和全球可用性。</td>      <td>典型部署是集中式架构，虽然可以通过复制和分区实现一定程度的分布式，但不是原生支持，配置和维护更复杂。</td>    </tr>  </table><h2 id="1-3-概念解析"><a href="#1-3-概念解析" class="headerlink" title="1.3 概念解析"></a>1.3 概念解析</h2><table><thead><tr><th align="left">SQL术语&#x2F;概念</th><th align="left">MongoDB术语&#x2F;概念</th><th align="left">解释&#x2F;说明</th></tr></thead><tbody><tr><td align="left">database</td><td align="left">database</td><td align="left">数据库</td></tr><tr><td align="left">table</td><td align="left">collection</td><td align="left">数据库表&#x2F;集合</td></tr><tr><td align="left">row</td><td align="left">document</td><td align="left">数据记录行&#x2F;文档</td></tr><tr><td align="left">column</td><td align="left">field</td><td align="left">数据字段&#x2F;域</td></tr><tr><td align="left">index</td><td align="left">index</td><td align="left">索引</td></tr><tr><td align="left">table joins</td><td align="left"></td><td align="left">表连接,MongoDB不支持</td></tr><tr><td align="left">primary key</td><td align="left">primary key</td><td align="left">主键,MongoDB自动将_id字段设置为主键</td></tr></tbody></table><h2 id="1-4-数据模型"><a href="#1-4-数据模型" class="headerlink" title="1.4 数据模型"></a>1.4 数据模型</h2><p>MongoDB的最小存储单位就是文档(document)对象。文档(document)对象对应于关系型数据库的行。数据在MongoDB中以BSON（Binary-JSON）文档的格式存储在磁盘上。</p><p>BSON（Binary Serialized Document Format）是一种类json的一种二进制形式的存储格式，简称Binary JSON。BSON和JSON一样，支持内嵌的文档对象和数组对象，但是BSON有JSON没有的一些数据类型，如Date和BinData类型。</p><p>BSON采用了类似于 C 语言结构体的名称、对表示方法，支持内嵌的文档对象和数组对象，具有轻量性、可遍历性、高效性的三个特点，可以有效描述非结构化数据和结构化数据。这种格式的优点是灵活性高，但它的缺点是空间利用率不是很理想。</p><p>Bson中，除了基本的JSON类型：string,integer,boolean,double,null,array和object，mongo还使用了特殊的数据类型。这些类型包括date,object id,binary data,regular expression 和code。每一个驱动都以特定语言的方式实现了这些类型，查看你的驱动的文档来获取详细信息。</p><h2 id="1-5-优缺点"><a href="#1-5-优缺点" class="headerlink" title="1.5 优缺点"></a>1.5 优缺点</h2><p>MongoDB 是一种 NoSQL 数据库，以其灵活的文档模型和高性能而闻名。以下是 MongoDB 的主要优缺点：</p><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ol><li><strong>灵活的文档模型</strong><ul><li>MongoDB 使用 BSON（类似 JSON 的二进制格式）存储数据，这允许存储复杂的嵌套数据结构。</li><li>模型灵活，模式自由，可以轻松处理数据模型的变化。</li></ul></li><li><strong>高性能</strong><ul><li>MongoDB 对于读取和写入操作都有很好的性能表现，尤其适用于高吞吐量和低延迟的应用场景。</li></ul></li><li><strong>水平扩展</strong><ul><li>MongoDB 支持水平扩展（sharding），能够通过将数据分布在多个服务器上来扩展存储容量和计算能力，适应大规模数据存储和访问需求。</li></ul></li><li><strong>高可用性</strong><ul><li>通过复制集（replica sets）实现数据的高可用性和自动故障转移，确保数据的可靠性和服务的连续性。</li></ul></li><li><strong>丰富的查询语言</strong><ul><li>MongoDB 提供了强大的查询语言，可以进行复杂的查询、排序、投影和聚合操作，满足各种数据查询需求。</li></ul></li><li><strong>强大的社区和生态系统</strong><ul><li>MongoDB 有广泛的社区支持和丰富的第三方工具和库，提供了良好的文档、教程和支持。</li></ul></li><li><strong>地理空间查询</strong><ul><li>内置支持地理空间查询，适用于位置数据的存储和查询。</li></ul></li></ol><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ol><li><strong>内存消耗高</strong><ul><li>由于 MongoDB 的文档存储格式和索引机制，其内存消耗相对较高，对于内存有限的环境可能会有压力。</li></ul></li><li><strong>事务支持有限</strong><ul><li>虽然 MongoDB 从 4.0 版本开始支持多文档 ACID 事务，但在某些复杂的事务场景下，仍然不如传统的关系型数据库。</li></ul></li><li><strong>不支持传统的 SQL</strong><ul><li>MongoDB 的查询语言不同于传统的 SQL，对于习惯于 SQL 的开发者需要学习新的查询语法和操作方法。</li></ul></li><li><strong>数据一致性</strong><ul><li>在默认配置下，MongoDB 的写操作是异步的，这意味着在某些情况下可能会导致数据一致性问题。虽然可以通过配置来保证更高的一致性，但可能会影响性能。</li></ul></li><li><strong>索引大小</strong><ul><li>MongoDB 的索引在内存中占用的空间较大，需要合理设计索引以避免性能问题。</li></ul></li><li><strong>备份和恢复复杂</strong><ul><li>尽管 MongoDB 提供了备份和恢复的工具，但在大规模数据场景下，备份和恢复操作可能会比较复杂和耗时。</li></ul></li></ol><h1 id="2-MongoDB操作"><a href="#2-MongoDB操作" class="headerlink" title="2. MongoDB操作"></a>2. MongoDB操作</h1><h2 id="2-1-数据库操作"><a href="#2-1-数据库操作" class="headerlink" title="2.1 数据库操作"></a>2.1 数据库操作</h2><h3 id="选择和创建数据库"><a href="#选择和创建数据库" class="headerlink" title="选择和创建数据库"></a>选择和创建数据库</h3><p>选择和创建数据库的语法格式：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">use 数据库名称<br></code></pre></td></tr></table></figure><p>如果数据库不存在则自动创建，例如，以下语句创建testdb数据库：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">use testdb<br></code></pre></td></tr></table></figure><p>查看有权限查看的所有数据库命令</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">show</span> dbs<br>或<br><span class="hljs-keyword">show</span> databases<br></code></pre></td></tr></table></figure><blockquote><p>注意：在MongoDB中，集合只有在内容插入后才会创建，就是说，创建集合（数据表）后要在插入一个文档（记录），集合才会真正创建</p></blockquote><h3 id="查看当前正在使用的数据库命令"><a href="#查看当前正在使用的数据库命令" class="headerlink" title="查看当前正在使用的数据库命令"></a>查看当前正在使用的数据库命令</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">db<br></code></pre></td></tr></table></figure><p>MongoDB中默认的数据库为test，如果你没有选择数据库，集合将存放在test数据库中。</p><p>另外：</p><ul><li><p>数据库名可以是满足以下条件的任意UTF-8字符串。</p></li><li><p>不能是空字符串（””)。</p></li><li><p>不得含有’ ‘（空格)、.、$、&#x2F;、\和\0 (空字符)。</p></li><li><p>应全部小写。</p></li><li><p>最多64字节。</p></li></ul><p>有一些数据库名是保留的，可以直接访问这些有特殊作用的数据库。</p><ul><li><p><strong>admin</strong>： 从权限的角度来看，这是”root”数据库。要是将一个用户添加到这个数据库，这个用户自动继承所有数据库的权限。一些特定的服务器端命令也只能从这个数据库运行，比如列出所有的数据库或者关闭服务器。</p></li><li><p><strong>local:</strong> 这个数据永远不会被复制，可以用来存储限于本地单台服务器的任意集合</p></li><li><p><strong>config</strong>: 当Mongo用于分片设置时，config数据库在内部使用，用于保存分片的相关信息。</p></li></ul><h3 id="数据库的删除"><a href="#数据库的删除" class="headerlink" title="数据库的删除"></a>数据库的删除</h3><p>MongoDB删除数据的语法格式如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">db.dropDatabase()<br></code></pre></td></tr></table></figure><p>提示：主要用来删除已经持久化的数据库</p><h2 id="2-2-集合操作"><a href="#2-2-集合操作" class="headerlink" title="2.2 集合操作"></a>2.2 集合操作</h2><h3 id="集合的显示创建"><a href="#集合的显示创建" class="headerlink" title="集合的显示创建"></a>集合的显示创建</h3><p>基本语法格式：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">db.createCollection(name)<br></code></pre></td></tr></table></figure><p>参数说明：</p><ul><li>name：要创建的集合名称</li></ul><p>例如：创建一个名为mycollection的普通集合</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">db.createCollection(&quot;mycollection&quot;)<br></code></pre></td></tr></table></figure><p>查看当前库中的表：show tables命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">show collections<br>或<br>show tables<br></code></pre></td></tr></table></figure><p>集合的命名规范：</p><ul><li><p>集合名不能是空字符串””。</p></li><li><p>集合名不能含有\0字符（空字符)，这个字符表示集合名的结尾。</p></li><li><p>集合名不能以”system.”开头，这是为系统集合保留的前缀。</p></li><li><p>用户创建的集合名字不能含有保留字符。有些驱动程序的确支持在集合名里面包含，这是因为某些系统生成的集合中包含该字符。除非你要访问这种系统创建的集合，否则千万不要在名字里出现$。</p></li></ul><h3 id="集合的隐式创建"><a href="#集合的隐式创建" class="headerlink" title="集合的隐式创建"></a>集合的隐式创建</h3><p>当向一个集合中插入一个文档的时候，如果集合不存在，则会自动创建集合。</p><blockquote><p>提示：通常我们使用隐式创建集合即可</p></blockquote><h2 id="2-3-集合的删除"><a href="#2-3-集合的删除" class="headerlink" title="2.3 集合的删除"></a>2.3 集合的删除</h2><p>集合删除语法格式如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">db.collection.drop()<br>或<br>db.集合.drop()<br></code></pre></td></tr></table></figure><p><strong>返回值</strong></p><p>如果成功删除选定集合，则drop()方法返回true，否则返回flase。</p><p>例如：要删除mycollection集合</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">db.mycollection.drop()<br></code></pre></td></tr></table></figure><h2 id="2-4-文档基本CRUD"><a href="#2-4-文档基本CRUD" class="headerlink" title="2.4 文档基本CRUD"></a>2.4 文档基本CRUD</h2><p>文档（document）的数据结构和 JSON 基本一样。</p><p>所有存储在集合中的数据都是 BSON 格式。</p><h3 id="文档的插入"><a href="#文档的插入" class="headerlink" title="文档的插入"></a>文档的插入</h3><p>（1）单个文档插入</p><p>使用insert()或者save()方法向集合中插入文档，语法如下：</p><figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs xquery">db<span class="hljs-built_in">.collection</span>.<span class="hljs-keyword">insert</span>(<br>&lt;<span class="hljs-keyword">document</span> or array of <span class="hljs-keyword">document</span>&gt;,<br>&#123;<br>writeConcern: <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">document</span>&gt;</span>,</span><br><span class="language-xml">ordered: </span><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">boolean</span>&gt;</span></span><br><span class="language-xml">&#125;</span><br><span class="language-xml">)</span><br></code></pre></td></tr></table></figure><p>参数：</p><table><thead><tr><th>Parameter</th><th>Type</th><th>Description</th></tr></thead><tbody><tr><td>document</td><td>document or array</td><td>要插入到集合中的文档或者文档数组。（json格式）</td></tr><tr><td>writeConcern</td><td>document</td><td>Optional. A document expressing the <a href="https://docs.mongodb.com/manual/reference/write-concern/">write concern</a>. Omit to use the default <a href="https://docs.mongodb.com/manual/reference/write-concern/">write concern</a>.See Write Concern.Do not explicitly set the write concern for the operation if run in a transaction. To use write concern with transactions, see <a href="https://docs.mongodb.com/manual/core/transactions/#transactions-write-concern">Transactions and Write Concern</a>.</td></tr><tr><td>ordered</td><td>boolean</td><td>可选。如果为真，则按顺序插入数组中的文档，如果其中一个文档出现错误，MongoDB将返回而不处理数组中的其余文档。如果为假，则执行无序插入，如果其中一个文档出现错误，则继续处理数组中的主文档。在版本2.6+中默认为true</td></tr></tbody></table><p>【示例】</p><p>要向comment的集合（表）中插入一条数据：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs shell">db.comment.insert(<br>&#123;<br>&quot;articleid&quot;:&quot;100000&quot;,<br>&quot;content&quot;:&quot;今天天气真好，阳光明媚&quot;,<br>&quot;userid&quot;:&quot;1001&quot;,<br>&quot;nickname&quot;:&quot;Rose&quot;,<br>&quot;createdatetime&quot;:new Date(),<br>&quot;likenum&quot;:NumberInt(10),<br>&quot;state&quot;:null<br>&#125;<br>)<br></code></pre></td></tr></table></figure><p>提示：</p><p>1）comment集合如果不存在，则会隐式创建</p><p>2）mongo中的数字，默认情况下是double类型，如果要存整型，必须使用函数NumberInt(整型数字)，否则取出来就有问题了。</p><p>3）插入当前日期使用 new Date()</p><p>4）插入的数据没有指定 _id ，会自动生成主键值</p><p>5）如果某字段没值，可以赋值为null，或不写该字段。</p><p>执行后，如下，说明插入一个数据成功了</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">writeResult</span><span class="hljs-params">(&#123;<span class="hljs-string">&quot;nInserted&quot;</span>: <span class="hljs-number">1</span>&#125;)</span></span><br></code></pre></td></tr></table></figure><p>注意：</p><ol><li>文档中的键&#x2F;值对是有序的。</li><li>文档中的值不仅可以是在双引号里面的字符串，还可以是其他几种数据类型（甚至可以是整个嵌入的文档)。</li><li>MongoDB区分类型和大小写。</li><li>MongoDB的文档不能有重复的键。</li><li>文档的键是字符串。除了少数例外情况，键可以使用任意UTF-8字符。</li></ol><p>文档键命名规范：</p><ul><li><p>键不能含有\0 (空字符)。这个字符用来表示键的结尾。</p></li><li><p>.和$有特别的意义，只有在特定环境下才能使用。</p></li><li><p>以下划线”_”开头的键是保留的(不是严格要求的)。</p></li></ul><p>（2）批量插入</p><p>语法：</p><figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs pf">db.collection.insertM<span class="hljs-literal">any</span>(<br>[ <span class="hljs-variable">&lt;document 1&gt;</span> , <span class="hljs-variable">&lt;document 2&gt;</span>, ... ],<br>&#123;<br>writeConcern: <span class="hljs-variable">&lt;document&gt;</span>,<br>ordered: <span class="hljs-variable">&lt;boolean&gt;</span><br>&#125;<br>)<br></code></pre></td></tr></table></figure><p>【示例】</p><p>批量插入多条文章评论：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs shell">db.comment.insertMany([<br>&#123;&quot;_id&quot;:&quot;1&quot;,&quot;articleid&quot;:&quot;100001&quot;,&quot;content&quot;:&quot;我们不应该把清晨浪费在手机上，健康很重要，一杯温水幸福你我他。&quot;,&quot;userid&quot;:&quot;1002&quot;,&quot;nickname&quot;:&quot;相忘于江湖&quot;,&quot;createdatetime&quot;:new Date(&quot;2019-08-05T22:08:15.522Z&quot;),&quot;likenum&quot;:NumberInt(1000),&quot;state&quot;:&quot;1&quot;&#125;,<br>&#123;&quot;_id&quot;:&quot;2&quot;,&quot;articleid&quot;:&quot;100001&quot;,&quot;content&quot;:&quot;我夏天空腹喝凉开水，冬天喝温开水&quot;,&quot;userid&quot;:&quot;1005&quot;,&quot;nickname&quot;:&quot;伊人憔悴&quot;,&quot;createdatetime&quot;:new Date(&quot;2019-08-05T23:58:51.485Z&quot;),&quot;likenum&quot;:NumberInt(888),&quot;state&quot;:&quot;1&quot;&#125;,<br>&#123;&quot;_id&quot;:&quot;3&quot;,&quot;articleid&quot;:&quot;100001&quot;,&quot;content&quot;:&quot;我一直喝凉开水，冬天夏天都喝。&quot;,&quot;userid&quot;:&quot;1004&quot;,&quot;nickname&quot;:&quot;杰克船长&quot;,&quot;createdatetime&quot;:new Date(&quot;2019-08-06T01:05:06.321Z&quot;),&quot;likenum&quot;:NumberInt(666),&quot;state&quot;:&quot;1&quot;&#125;,<br>&#123;&quot;_id&quot;:&quot;4&quot;,&quot;articleid&quot;:&quot;100001&quot;,&quot;content&quot;:&quot;专家说不能空腹吃饭，影响健康。&quot;,&quot;userid&quot;:&quot;1003&quot;,&quot;nickname&quot;:&quot;凯撒&quot;,&quot;createdatetime&quot;:new Date(&quot;2019-08-06T08:18:35.288Z&quot;),&quot;likenum&quot;:NumberInt(2000),&quot;state&quot;:&quot;1&quot;&#125;,<br>&#123;&quot;_id&quot;:&quot;5&quot;,&quot;articleid&quot;:&quot;100001&quot;,&quot;content&quot;:&quot;研究表明，刚烧开的水千万不能喝，因为烫<br>嘴。&quot;,&quot;userid&quot;:&quot;1003&quot;,&quot;nickname&quot;:&quot;凯撒&quot;,&quot;createdatetime&quot;:new Date(&quot;2019-08-<br>06T11:01:02.521Z&quot;),&quot;likenum&quot;:NumberInt(3000),&quot;state&quot;:&quot;1&quot;&#125;<br>]);<br></code></pre></td></tr></table></figure><p>提示：</p><p>插入时指定了 _id ，则主键就是该值。</p><p>如果某条数据插入失败，将会终止插入，但已经插入成功的数据不会回滚掉。</p><p>因为批量插入由于数据较多容易出现失败，因此，可以使用try catch进行异常捕捉处理，测试的时候可以不处理。如：</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript"><span class="hljs-keyword">try</span> &#123;<br>db.comment.insertMany([<br>&#123;<span class="hljs-string">&quot;_id&quot;</span>:<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;articleid&quot;</span>:<span class="hljs-string">&quot;100001&quot;</span>,<span class="hljs-string">&quot;content&quot;</span>:<span class="hljs-string">&quot;我们不应该把清晨浪费在手机上，健康很重要，一杯温水幸福你我他。&quot;</span>,<span class="hljs-string">&quot;userid&quot;</span>:<span class="hljs-string">&quot;1002&quot;</span>,<span class="hljs-string">&quot;nickname&quot;</span>:<span class="hljs-string">&quot;相忘于江湖&quot;</span>,<span class="hljs-string">&quot;createdatetime&quot;</span>:<span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>(<span class="hljs-string">&quot;2019-08-05T22:08:15.522Z&quot;</span>),<span class="hljs-string">&quot;likenum&quot;</span>:NumberInt(<span class="hljs-number">1000</span>),<span class="hljs-string">&quot;state&quot;</span>:<span class="hljs-string">&quot;1&quot;</span>&#125;,<br>&#123;<span class="hljs-string">&quot;_id&quot;</span>:<span class="hljs-string">&quot;2&quot;</span>,<span class="hljs-string">&quot;articleid&quot;</span>:<span class="hljs-string">&quot;100001&quot;</span>,<span class="hljs-string">&quot;content&quot;</span>:<span class="hljs-string">&quot;我夏天空腹喝凉开水，冬天喝温开水&quot;</span>,<span class="hljs-string">&quot;userid&quot;</span>:<span class="hljs-string">&quot;1005&quot;</span>,<span class="hljs-string">&quot;nickname&quot;</span>:<span class="hljs-string">&quot;伊人憔悴&quot;</span>,<span class="hljs-string">&quot;createdatetime&quot;</span>:<span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>(<span class="hljs-string">&quot;2019-08-05T23:58:51.485Z&quot;</span>),<span class="hljs-string">&quot;likenum&quot;</span>:NumberInt(<span class="hljs-number">888</span>),<span class="hljs-string">&quot;state&quot;</span>:<span class="hljs-string">&quot;1&quot;</span>&#125;,<br>&#123;<span class="hljs-string">&quot;_id&quot;</span>:<span class="hljs-string">&quot;3&quot;</span>,<span class="hljs-string">&quot;articleid&quot;</span>:<span class="hljs-string">&quot;100001&quot;</span>,<span class="hljs-string">&quot;content&quot;</span>:<span class="hljs-string">&quot;我一直喝凉开水，冬天夏天都喝。&quot;</span>,<span class="hljs-string">&quot;userid&quot;</span>:<span class="hljs-string">&quot;1004&quot;</span>,<span class="hljs-string">&quot;nickname&quot;</span>:<span class="hljs-string">&quot;杰克船长&quot;</span>,<span class="hljs-string">&quot;createdatetime&quot;</span>:<span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>(<span class="hljs-string">&quot;2019-08-06T01:05:06.321Z&quot;</span>),<span class="hljs-string">&quot;likenum&quot;</span>:NumberInt(<span class="hljs-number">666</span>),<span class="hljs-string">&quot;state&quot;</span>:<span class="hljs-string">&quot;1&quot;</span>&#125;,<br>&#123;<span class="hljs-string">&quot;_id&quot;</span>:<span class="hljs-string">&quot;4&quot;</span>,<span class="hljs-string">&quot;articleid&quot;</span>:<span class="hljs-string">&quot;100001&quot;</span>,<span class="hljs-string">&quot;content&quot;</span>:<span class="hljs-string">&quot;专家说不能空腹吃饭，影响健康。&quot;</span>,<span class="hljs-string">&quot;userid&quot;</span>:<span class="hljs-string">&quot;1003&quot;</span>,<span class="hljs-string">&quot;nickname&quot;</span>:<span class="hljs-string">&quot;凯撒&quot;</span>,<span class="hljs-string">&quot;createdatetime&quot;</span>:<span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>(<span class="hljs-string">&quot;2019-08-06T08:18:35.288Z&quot;</span>),<span class="hljs-string">&quot;likenum&quot;</span>:NumberInt(<span class="hljs-number">2000</span>),<span class="hljs-string">&quot;state&quot;</span>:<span class="hljs-string">&quot;1&quot;</span>&#125;,<br>&#123;<span class="hljs-string">&quot;_id&quot;</span>:<span class="hljs-string">&quot;5&quot;</span>,<span class="hljs-string">&quot;articleid&quot;</span>:<span class="hljs-string">&quot;100001&quot;</span>,<span class="hljs-string">&quot;content&quot;</span>:<span class="hljs-string">&quot;研究表明，刚烧开的水千万不能喝，因为烫</span><br><span class="hljs-string">嘴。&quot;</span>,<span class="hljs-string">&quot;userid&quot;</span>:<span class="hljs-string">&quot;1003&quot;</span>,<span class="hljs-string">&quot;nickname&quot;</span>:<span class="hljs-string">&quot;凯撒&quot;</span>,<span class="hljs-string">&quot;createdatetime&quot;</span>:<span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>(<span class="hljs-string">&quot;2019-08-</span><br><span class="hljs-string">06T11:01:02.521Z&quot;</span>),<span class="hljs-string">&quot;likenum&quot;</span>:NumberInt(<span class="hljs-number">3000</span>),<span class="hljs-string">&quot;state&quot;</span>:<span class="hljs-string">&quot;1&quot;</span>&#125;<br>]);<br>&#125; <span class="hljs-keyword">catch</span> (e) &#123;<br><span class="hljs-built_in">print</span> (e);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="文档的基本查询"><a href="#文档的基本查询" class="headerlink" title="文档的基本查询"></a>文档的基本查询</h3><p>查询数据的语法格式如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">db.collection.find(&lt;query&gt;, [projection])<br></code></pre></td></tr></table></figure><p>参数：</p><table><thead><tr><th>Parameter</th><th>Type</th><th>Description</th></tr></thead><tbody><tr><td>query</td><td>document</td><td>可选。使用查询运算符指定选择筛选器。若要返回集合中的所有文档，请省略此参数或传递空文档({})</td></tr><tr><td>projection</td><td>document</td><td>可选。指定要在与查询筛选器匹配的文档中返回的字段（投影）。若要返回匹配文档中的所有字段，请忽略此参数。</td></tr></tbody></table><p>【示例】</p><p>（1）查询所有</p><p>如果我们要查询comment集合的所有文档，我们输入以下命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">db.comment.find()<br>或<br>db.comment.find(&#123;&#125;)<br></code></pre></td></tr></table></figure><p>这里你会发现每条文档会有一个叫_id的字段，这个相当于我们原来关系数据库中表的主键，当你在插入文档记录时没有指定该字段，MongoDB会自动创建，其类型是ObjectID类型。</p><p>如果我们在插入文档记录时指定该字段也可以，其类型可以是ObjectID类型，也可以是MongoDB支持的任意类型。</p><p>如果我想按一定条件来查询，比如我想查询userid为1003的记录，怎么办？很简单！只 要在find()中添加参数即可，参数也是json格式，如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">db.comment.fin(&#123;userid:&#x27;1003&#x27;&#125;)<br></code></pre></td></tr></table></figure><p>如果你只需要返回符合条件的第一条数据，我们可以使用findOne命令来实现，语法和find一样。</p><p>如：查询用户编号是1003的记录，但只最多返回符合条件的第一条记录：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">db.comment.findOne(&#123;userid:&#x27;1003&#x27;&#125;)<br></code></pre></td></tr></table></figure><p>（2）投影查询（Projection Query）：</p><p>如果要查询结果返回部分字段，则需要使用投影查询（不显示所有字段，只显示指定的字段）。</p><p>如：查询结果只显示 _id、userid、nickname :</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">db.comment.find(&#123;userid:&quot;1003&quot;&#125;,&#123;userid:1,nickname:1&#125;)<br>&#123; &quot;_id&quot; : &quot;4&quot;, &quot;userid&quot; : &quot;1003&quot;, &quot;nickname&quot; : &quot;凯撒&quot; &#125;<br>&#123; &quot;_id&quot; : &quot;5&quot;, &quot;userid&quot; : &quot;1003&quot;, &quot;nickname&quot; : &quot;凯撒&quot; &#125;<br></code></pre></td></tr></table></figure><p>默认 _id 会显示。</p><p>如：查询结果只显示 、userid、nickname ，不显示 _id ：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">db.comment.find(&#123;userid:&quot;1003&quot;&#125;,&#123;userid:1,nickname:1,_id:0&#125;)<br>&#123; &quot;userid&quot; : &quot;1003&quot;, &quot;nickname&quot; : &quot;凯撒&quot; &#125;<br>&#123; &quot;userid&quot; : &quot;1003&quot;, &quot;nickname&quot; : &quot;凯撒&quot; &#125;<br></code></pre></td></tr></table></figure><p>再例如：查询所有数据，但只显示 _id、userid、nickname :</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">db.comment.find(&#123;&#125;,&#123;userid:1,nickname:1&#125;)<br></code></pre></td></tr></table></figure><h3 id="文档的更新"><a href="#文档的更新" class="headerlink" title="文档的更新"></a>文档的更新</h3><p>更新文档的语法：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs shell">db.collection.update(query, update, options)<br>//或<br>db.collection.update(<br>&lt;query&gt;,<br>&lt;update&gt;,<br>&#123;<br>upsert: &lt;boolean&gt;,<br>multi: &lt;boolean&gt;,<br>writeConcern: &lt;document&gt;<br>&#125;<br>)<br></code></pre></td></tr></table></figure><p>参数：</p><table><thead><tr><th>Parameter</th><th>Type</th><th>Description</th></tr></thead><tbody><tr><td>query</td><td>document</td><td>update的查询条件，类似sql update查询的where子句。</td></tr><tr><td>update</td><td>document or pipeline</td><td>update的对象和一些更新的操作符（如$,$inc…）等，也可以理解为 sql update查询的set子句</td></tr><tr><td>upsert</td><td>boolean</td><td>可选。如果设置为true，则在没有与查询条件匹配的文档时创建新文档。默认值为false，如果找不到匹配项，则不会插入新文档。</td></tr><tr><td>multi</td><td>boolean</td><td>可选。如果设置为true，则更新符合查询条件的多个文档。如果设置为false，则更新一个文档。默认值为false。</td></tr><tr><td>writeConcern</td><td>document</td><td>可选。表示写问题的文档。抛出异常的级别。</td></tr></tbody></table><p>提示：</p><p>主要关注前四个参数即可。</p><p>【示例】</p><p>（1）覆盖的修改</p><p>如果我们想修改_id为1的记录，点赞量为1001，输入以下语句：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">db.comment.update(&#123;_id:&quot;1&quot;&#125;,&#123;likenum:NumberInt(1001)&#125;)<br></code></pre></td></tr></table></figure><p>执行后，我们会发现，这条文档除了likenum字段其它字段都不见了，</p><p>（2）局部修改</p><p>为了解决这个问题，我们需要使用修改器$set来实现，命令如下：</p><p>我们想修改_id为2的记录，浏览量为889，输入以下语句：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">db.comment.update(&#123;_id:&quot;2&quot;&#125;,&#123;$set:&#123;likenum:NumberInt(889)&#125;&#125;)<br></code></pre></td></tr></table></figure><p>这样就OK啦。</p><p>（3）批量的修改</p><p>更新所有用户为 1003 的用户的昵称为 凯撒大帝 。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">//默认只修改第一条数据<br>db.comment.update(&#123;userid:&quot;1003&quot;&#125;,&#123;$set:&#123;nickname:&quot;凯撒2&quot;&#125;&#125;)<br>//修改所有符合条件的数据<br>db.comment.update(&#123;userid:&quot;1003&quot;&#125;,&#123;$set:&#123;nickname:&quot;凯撒大帝&quot;&#125;&#125;,&#123;multi:true&#125;)<br></code></pre></td></tr></table></figure><p>提示：如果不加后面的参数，则只更新符合条件的第一条记录</p><p>（3）列值增长的修改</p><p>如果我们想实现对某列值在原有值的基础上进行增加或减少，可以使用 $inc 运算符来实现。</p><p>需求：对3号数据的点赞数，每次递增</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus">db<span class="hljs-selector-class">.comment</span><span class="hljs-selector-class">.update</span>(&#123;_id:<span class="hljs-string">&quot;3&quot;</span>&#125;,&#123;<span class="hljs-variable">$inc</span>:&#123;likenum:<span class="hljs-built_in">NumberInt</span>(<span class="hljs-number">1</span>)&#125;&#125;)<br></code></pre></td></tr></table></figure><h3 id="删除文档"><a href="#删除文档" class="headerlink" title="删除文档"></a>删除文档</h3><p>删除文档的语法结构：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">db.集合名称.remove(条件)<br></code></pre></td></tr></table></figure><p>以下语句可以将数据全部删除，请慎用</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">db.comment.remove(&#123;&#125;)<br></code></pre></td></tr></table></figure><p>如果删除_id&#x3D;1的记录，输入以下语句</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">db.comment.remove(&#123;_id:&quot;1&quot;&#125;)<br></code></pre></td></tr></table></figure><h2 id="2-5-文档的分页查询"><a href="#2-5-文档的分页查询" class="headerlink" title="2.5 文档的分页查询"></a>2.5 文档的分页查询</h2><h3 id="统计查询"><a href="#统计查询" class="headerlink" title="统计查询"></a>统计查询</h3><p>统计查询使用count()方法，语法如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">db.collection.count(query, options)<br></code></pre></td></tr></table></figure><p>参数：</p><table><thead><tr><th>Parameter</th><th>Type</th><th>Description</th></tr></thead><tbody><tr><td>query</td><td>document</td><td>查询选择条件</td></tr><tr><td>options</td><td>document</td><td>可选。用于修改计数的额外选项</td></tr></tbody></table><p>提示：</p><p>可选项暂时不使用。</p><p>【示例】</p><p>（1）统计所有记录数：</p><p>统计comment集合的所有记录数：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">db.comment.count()<br></code></pre></td></tr></table></figure><p>（2）按条件统计记录数</p><p>例如：统计userid为1003的记录条数</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">db.comment.count(&#123;userid:&quot;1003&quot;&#125;)<br></code></pre></td></tr></table></figure><p>提示：默认情况下 count()方法返回符合条件的全部记录条数。</p><h3 id="分页列表查询"><a href="#分页列表查询" class="headerlink" title="分页列表查询"></a>分页列表查询</h3><p>可以使用limit()方法来读取指定数量的数据，使用skip()方法来跳过指定数量的数据。</p><p>基本语法如下所示：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">db.COLLECTION_NAME.find().limit(NUMBER).skip(NUMBER)<br></code></pre></td></tr></table></figure><p>如果想返回指定条数的记录，可以在find方法后调用limit来返回结果（TopN），默认值20，例如：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">db.comment.find().limit(3)<br></code></pre></td></tr></table></figure><p>skip方法同样接收一个数字参数作为跳过的记录条数。（前N个不要）， 默认值是0</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">db.comment.find().skip(3)<br></code></pre></td></tr></table></figure><p>分页查询：需求： 每页2个，从第二页开始：跳过前两条数据，接着值显示3和4条数据</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell">//第一页<br>db.comment.find().skip(0).limit(2)<br>//第二页<br>db.comment.find().skip(2).limit(2)<br>//第三页<br>db.comment.find().skip(4).limit(2)<br></code></pre></td></tr></table></figure><h3 id="排序查询"><a href="#排序查询" class="headerlink" title="排序查询"></a>排序查询</h3><p>sort() 方法对数据进行排序，sort() 方法可以通过参数指定排序的字段，并使用1和-1来指定排序的方式，其中 1 为升序排列，而-1是用于降序排列。</p><p>语法如下所示：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">db.COLLECTION_NAME.find().sort(&#123;KEY:1&#125;)<br>或<br>db.集合名称.find().sort(排序方式)<br></code></pre></td></tr></table></figure><p>例如：</p><p>对userid降序排列，并对访问量进行升序排列</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">db.comment.find().sort(&#123;userid:-1,likenum:1&#125;)<br></code></pre></td></tr></table></figure><p>提示：</p><p>skip(), limilt(), sort()三个放在一起执行的时候，执行的顺序是先 sort(), 然后是 skip()，最后是显示的 limit()，和命令编写顺序无关。</p><h2 id="2-6-文档的更多查询"><a href="#2-6-文档的更多查询" class="headerlink" title="2.6 文档的更多查询"></a>2.6 文档的更多查询</h2><h3 id="正则的复杂条件查询"><a href="#正则的复杂条件查询" class="headerlink" title="正则的复杂条件查询"></a>正则的复杂条件查询</h3><p>MongoDB的模糊查询是通过<strong>正则表达式</strong>的方式实现的。格式为：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">db.collection.find(&#123;field:/正则表达式/&#125;)<br>或<br>db.集合.find(&#123;字段:/正则表达式/&#125;)<br></code></pre></td></tr></table></figure><p>提示：正则表达式是js的语法，直接量的写法。</p><p>例如，我要查询评论内容包含“开水”的所有文档，代码如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">db.comment.find(&#123;content:/开水/&#125;)<br></code></pre></td></tr></table></figure><p>如果要查询评论的内容中以“专家”开头的，代码如下：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus">db<span class="hljs-selector-class">.comment</span><span class="hljs-selector-class">.find</span>(&#123;<span class="hljs-attribute">content</span>:/^专家/&#125;)<br></code></pre></td></tr></table></figure><h3 id="比较查询"><a href="#比较查询" class="headerlink" title="比较查询"></a>比较查询</h3><p>&lt;, &lt;&#x3D;, &gt;, &gt;&#x3D; 这个操作符也是很常用的，格式如下:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">db.集合名称.find(&#123; &quot;field&quot; : &#123; $gt: value &#125;&#125;) // 大于: field &gt; value<br>db.集合名称.find(&#123; &quot;field&quot; : &#123; $lt: value &#125;&#125;) // 小于: field &lt; value<br>db.集合名称.find(&#123; &quot;field&quot; : &#123; $gte: value &#125;&#125;) // 大于等于: field &gt;= value<br>db.集合名称.find(&#123; &quot;field&quot; : &#123; $lte: value &#125;&#125;) // 小于等于: field &lt;= value<br>db.集合名称.find(&#123; &quot;field&quot; : &#123; $ne: value &#125;&#125;) // 不等于: field != value<br></code></pre></td></tr></table></figure><p>示例：查询评论点赞数量大于700的记录</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">db.comment.find(&#123;likenum:&#123;$gt:NumberInt(700)&#125;&#125;)<br></code></pre></td></tr></table></figure><h3 id="包含查询"><a href="#包含查询" class="headerlink" title="包含查询"></a>包含查询</h3><p>包含使用$in操作符。 示例：查询评论的集合中userid字段包含1003或1004的文档</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">db.comment.find(&#123;userid:&#123;$in:[&quot;1003&quot;,&quot;1004&quot;]&#125;&#125;)<br></code></pre></td></tr></table></figure><p>不包含使用$nin操作符。 示例：查询评论集合中userid字段不包含1003和1004的文档</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">db.comment.find(&#123;userid:&#123;$nin:[&quot;1003&quot;,&quot;1004&quot;]&#125;&#125;)<br></code></pre></td></tr></table></figure><h3 id="条件连接查询"><a href="#条件连接查询" class="headerlink" title="条件连接查询"></a>条件连接查询</h3><p>我们如果需要查询同时满足两个以上条件，需要使用$and操作符将条件进行关联。（相 当于SQL的and） 格式为：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$</span><span class="language-bash">and:[ &#123; &#125;,&#123; &#125;,&#123; &#125; ]</span><br></code></pre></td></tr></table></figure><p>示例：查询评论集合中likenum大于等于700 并且小于2000的文档：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">db.comment.find(&#123;$and:[&#123;likenum:&#123;$gte:NumberInt(700)&#125;&#125;,&#123;likenum:&#123;$lt:NumberInt(2000)&#125;&#125;]&#125;)<br></code></pre></td></tr></table></figure><p>如果两个以上条件之间是或者的关系，我们使用 操作符进行关联，与前面 and的使用方式相同 格式为：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$</span><span class="language-bash">or:[ &#123; &#125;,&#123; &#125;,&#123; &#125; ]</span><br></code></pre></td></tr></table></figure><p>示例：查询评论集合中userid为1003，或者点赞数小于1000的文档记录</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">db.comment.find(&#123;$or:[ &#123;userid:&quot;1003&quot;&#125; ,&#123;likenum:&#123;$lt:1000&#125; &#125;]&#125;)<br></code></pre></td></tr></table></figure><h2 id="2-7-常用命令小结"><a href="#2-7-常用命令小结" class="headerlink" title="2.7 常用命令小结"></a>2.7 常用命令小结</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs shell">选择切换数据库：use articledb<br>插入数据：db.comment.insert(&#123;bson数据&#125;)<br>查询所有数据：db.comment.find();<br>条件查询数据：db.comment.find(&#123;条件&#125;)<br>查询符合条件的第一条记录：db.comment.findOne(&#123;条件&#125;)<br>查询符合条件的前几条记录：db.comment.find(&#123;条件&#125;).limit(条数)<br>查询符合条件的跳过的记录：db.comment.find(&#123;条件&#125;).skip(条数)<br>修改数据：db.comment.update(&#123;条件&#125;,&#123;修改后的数据&#125;) 或db.comment.update(&#123;条件&#125;,&#123;$set:&#123;要修改部分的字段:数据&#125;)<br>修改数据并自增某字段值：db.comment.update(&#123;条件&#125;,&#123;$inc:&#123;自增的字段:步进值&#125;&#125;)<br>删除数据：db.comment.remove(&#123;条件&#125;)<br>统计查询：db.comment.count(&#123;条件&#125;)<br>模糊查询：db.comment.find(&#123;字段名:/正则表达式/&#125;)<br>条件比较运算：db.comment.find(&#123;字段名:&#123;$gt:值&#125;&#125;)<br>包含查询：db.comment.find(&#123;字段名:&#123;$in:[值1，值2]&#125;&#125;)或db.comment.find(&#123;字段名:&#123;$nin:[值1，值2]&#125;&#125;)<br>条件连接查询：db.comment.find(&#123;$and:[&#123;条件1&#125;,&#123;条件2&#125;]&#125;)或db.comment.find(&#123;$or:[&#123;条件1&#125;,&#123;条件2&#125;]&#125;)<br></code></pre></td></tr></table></figure><h2 id="2-8-聚合"><a href="#2-8-聚合" class="headerlink" title="2.8 聚合"></a>2.8 聚合</h2><p>MongoDB中聚合(aggregate)主要用于处理数据(诸如统计平均值,求和等)，并返回计算后的数据结果。有点类似sql语句中的 count(*)。</p><h3 id="aggregate-方法"><a href="#aggregate-方法" class="headerlink" title="aggregate() 方法"></a>aggregate() 方法</h3><p>MongoDB中聚合的方法使用 aggregate()。</p><p>语法如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">db.COLLECTION_NAME.aggregate(AGGREGATE_OPERATION)<br></code></pre></td></tr></table></figure><p>【实例】</p><p>集合中的数据如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs shell">&#123;<br>   _id: ObjectId(7df78ad8902c)<br>   title: &#x27;MongoDB Overview&#x27;, <br>   description: &#x27;MongoDB is no sql database&#x27;,<br>   by_user: &#x27;w3cschool.cn&#x27;,<br>   url: &#x27;http://www.w3cschool.cn&#x27;,<br>   tags: [&#x27;mongodb&#x27;, &#x27;database&#x27;, &#x27;NoSQL&#x27;],<br>   likes: 100<br>&#125;,<br>&#123;<br>   _id: ObjectId(7df78ad8902d)<br>   title: &#x27;NoSQL Overview&#x27;, <br>   description: &#x27;No sql database is very fast&#x27;,<br>   by_user: &#x27;w3cschool.cn&#x27;,<br>   url: &#x27;http://www.w3cschool.cn&#x27;,<br>   tags: [&#x27;mongodb&#x27;, &#x27;database&#x27;, &#x27;NoSQL&#x27;],<br>   likes: 10<br>&#125;,<br>&#123;<br>   _id: ObjectId(7df78ad8902e)<br>   title: &#x27;Neo4j Overview&#x27;, <br>   description: &#x27;Neo4j is no sql database&#x27;,<br>   by_user: &#x27;Neo4j&#x27;,<br>   url: &#x27;http://www.neo4j.com&#x27;,<br>   tags: [&#x27;neo4j&#x27;, &#x27;database&#x27;, &#x27;NoSQL&#x27;],<br>   likes: 750<br>&#125;,<br></code></pre></td></tr></table></figure><p>现在我们通过以上集合计算每个作者所写的文章数，使用<code>aggregate()</code>计算结果如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs shell">db.mycol.aggregate([&#123;$group : &#123;_id : &quot;$by_user&quot;, num_tutorial : &#123;$sum : 1&#125;&#125;&#125;])<br>&#123;<br>   &quot;result&quot; : [<br>      &#123;<br>         &quot;_id&quot; : &quot;w3cschool.cn&quot;,<br>         &quot;num_tutorial&quot; : 2<br>      &#125;,<br>      &#123;<br>         &quot;_id&quot; : &quot;Neo4j&quot;,<br>         &quot;num_tutorial&quot; : 1<br>      &#125;<br>   ],<br>   &quot;ok&quot; : 1<br>&#125;<br></code></pre></td></tr></table></figure><p>以上实例类似sql语句：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">select by_user, count(*) from mycol group by by_user<br></code></pre></td></tr></table></figure><p>在上面的例子中，我们通过字段by_user字段对数据进行分组，并计算by_user字段相同值的总和。</p><h3 id="管道"><a href="#管道" class="headerlink" title="管道"></a>管道</h3><p>MongoDB 的管道（Pipeline）是一个用于数据处理和分析的概念，它允许你通过一系列阶段（stages）来处理文档集合中的数据。每个阶段对输入文档执行操作，然后将结果传递到下一个阶段。最终，经过一系列操作后，管道输出处理后的结果。</p><p>管道在 MongoDB 中主要用于聚合框架，通过这种方式可以实现数据的过滤、转换、分组、排序、连接等复杂操作。整个管道的结构类似于 Unix 的管道命令，通过一系列简单的步骤，组合起来完成复杂的数据处理任务。</p><h4 id="管道的主要特点"><a href="#管道的主要特点" class="headerlink" title="管道的主要特点"></a>管道的主要特点</h4><ol><li><strong>逐步处理</strong>：数据经过一系列操作步骤，每个阶段只处理当前的数据并传递给下一个阶段。</li><li><strong>组合灵活</strong>：不同的阶段可以自由组合，以满足各种数据处理需求。</li><li><strong>高效执行</strong>：MongoDB 会对管道进行优化，尽量减少内存和计算资源的使用。</li></ol><h4 id="常用的管道阶段"><a href="#常用的管道阶段" class="headerlink" title="常用的管道阶段"></a>常用的管道阶段</h4><p><strong>$match</strong>：过滤文档。用于筛选文档，仅通过满足指定条件的文档。类似于 SQL 中的 <code>WHERE</code> 子句。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">&#123;<br><span class="hljs-meta prompt_">  $</span><span class="language-bash">match: &#123; status: <span class="hljs-string">&quot;A&quot;</span> &#125;</span><br>&#125;<br></code></pre></td></tr></table></figure><p>这将筛选出所有 <code>status</code> 字段为 “A” 的文档。</p><p><strong>$project</strong>：用于包括或排除文档中的特定字段，还可以创建新的字段。类似于 SQL 中的 <code>SELECT</code> 子句。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">&#123;<br><span class="hljs-meta prompt_">  $</span><span class="language-bash">project: &#123; item: 1, status: 1, total: &#123; <span class="hljs-variable">$multiply</span>: [<span class="hljs-string">&quot;<span class="hljs-variable">$price</span>&quot;</span>, <span class="hljs-string">&quot;<span class="hljs-variable">$quantity</span>&quot;</span>] &#125; &#125;</span><br>&#125;<br></code></pre></td></tr></table></figure><p>这会选择 <code>item</code> 和 <code>status</code> 字段，并创建一个 <code>total</code> 字段，其值是 <code>price</code> 和 <code>quantity</code> 的乘积。</p><p><strong>$group</strong>：用于将文档分组，并对每个组应用聚合操作。类似于 SQL 中的 <code>GROUP BY</code> 子句。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">&#123;<br><span class="hljs-meta prompt_">  $</span><span class="language-bash">group: &#123; _id: <span class="hljs-string">&quot;<span class="hljs-variable">$status</span>&quot;</span>, totalQuantity: &#123; <span class="hljs-variable">$sum</span>: <span class="hljs-string">&quot;<span class="hljs-variable">$quantity</span>&quot;</span> &#125; &#125;</span><br>&#125;<br></code></pre></td></tr></table></figure><p>这会根据 <code>status</code> 字段对文档进行分组，并计算每个组的 <code>quantity</code> 字段总和。</p><p><strong>$sort</strong>：用于对文档进行排序。类似于 SQL 中的 <code>ORDER BY</code> 子句。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">&#123;<br><span class="hljs-meta prompt_">  $</span><span class="language-bash"><span class="hljs-built_in">sort</span>: &#123; totalQuantity: -1 &#125;</span><br>&#125;<br></code></pre></td></tr></table></figure><p>这会按 <code>totalQuantity</code> 字段降序排列文档。</p><p><strong>$limit</strong>：用于限制返回的文档数量。类似于 SQL 中的 <code>LIMIT</code> 子句。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">&#123;<br><span class="hljs-meta prompt_">  $</span><span class="language-bash"><span class="hljs-built_in">limit</span>: 5</span><br>&#125;<br></code></pre></td></tr></table></figure><p>这会限制返回的文档数量为 5。</p><p><strong>$skip</strong>：用于跳过指定数量的文档。通常与 <code>$limit</code> 一起使用，实现分页功能。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">&#123;<br><span class="hljs-meta prompt_">  $</span><span class="language-bash">skip: 10</span><br>&#125;<br></code></pre></td></tr></table></figure><p>这会跳过前 10 个文档。</p><p><strong>$unwind</strong>：用于将数组字段拆分为多个文档，每个数组元素对应一个文档。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">&#123;<br><span class="hljs-meta prompt_">  $</span><span class="language-bash">unwind: <span class="hljs-string">&quot;<span class="hljs-variable">$items</span>&quot;</span></span><br>&#125;<br></code></pre></td></tr></table></figure><p>这会将 <code>items</code> 数组字段中的每个元素拆分为单独的文档。</p><p><strong>$lookup</strong>：联表查询。用于在集合之间进行左外连接，类似于 SQL 中的 <code>JOIN</code> 操作。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs shell">&#123;<br><span class="hljs-meta prompt_">  $</span><span class="language-bash">lookup:</span><br>    &#123;<br>      from: &quot;otherCollection&quot;,<br>      localField: &quot;itemId&quot;,<br>      foreignField: &quot;id&quot;,<br>      as: &quot;itemDetails&quot;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这会将当前集合中的 <code>itemId</code> 字段与 <code>otherCollection</code> 中的 <code>id</code> 字段进行匹配，并将匹配结果存储在 <code>itemDetails</code> 字段中。</p><p><strong>$addFields</strong>：添加新字段。用于向文档添加新的字段。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">&#123;<br><span class="hljs-meta prompt_">  $</span><span class="language-bash">addFields: &#123; totalPrice: &#123; <span class="hljs-variable">$multiply</span>: [<span class="hljs-string">&quot;<span class="hljs-variable">$price</span>&quot;</span>, <span class="hljs-string">&quot;<span class="hljs-variable">$quantity</span>&quot;</span>] &#125; &#125;</span><br>&#125;<br></code></pre></td></tr></table></figure><p>这会添加一个 <code>totalPrice</code> 字段，其值为 <code>price</code> 和 <code>quantity</code> 的乘积。</p><p><strong>$replaceRoot</strong>：替换根文档。用于用指定的文档替换输入文档。通常用于嵌套文档。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">&#123;<br><span class="hljs-meta prompt_">  $</span><span class="language-bash">replaceRoot: &#123; newRoot: <span class="hljs-string">&quot;<span class="hljs-variable">$itemDetails</span>&quot;</span> &#125;</span><br>&#125;<br></code></pre></td></tr></table></figure><p>这会用 <code>itemDetails</code> 字段的内容替换当前文档。</p><p><strong>$count</strong>：计算文档数量。用于计算通过管道的文档数量，并返回结果。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">&#123;<br><span class="hljs-meta prompt_">  $</span><span class="language-bash">count: <span class="hljs-string">&quot;total&quot;</span></span><br>&#125;<br><br></code></pre></td></tr></table></figure><p>这会返回一个包含文档总数的字段 <code>total</code>。</p><p><strong>$facet</strong>：允许在单个聚合管道中同时运行多个子管道。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs shell">&#123;<br><span class="hljs-meta prompt_">  $</span><span class="language-bash">facet: &#123;</span><br>    &quot;categorizedByStatus&quot;: [<br>      &#123; $match: &#123; status: &#123; $exists: true &#125; &#125; &#125;,<br>      &#123; $group: &#123; _id: &quot;$status&quot;, count: &#123; $sum: 1 &#125; &#125; &#125;<br>    ],<br>    &quot;categorizedByPrice&quot;: [<br>      &#123; $match: &#123; price: &#123; $exists: true &#125; &#125; &#125;,<br>      &#123; $group: &#123; _id: &#123; $cond: &#123; if: &#123; $gte: [&quot;$price&quot;, 100] &#125;, then: &quot;expensive&quot;, else: &quot;cheap&quot; &#125; &#125;, count: &#123; $sum: 1 &#125; &#125; &#125;<br>    ]<br>  &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>这会分别计算按 <code>status</code> 和 <code>price</code> 分类的文档数量。</p><p><strong>$out</strong>：将聚合结果输出到一个指定的集合。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">&#123;<br><span class="hljs-meta prompt_">  $</span><span class="language-bash">out: <span class="hljs-string">&quot;outputCollection&quot;</span></span><br>&#125;<br></code></pre></td></tr></table></figure><p>这会将聚合结果保存到 <code>outputCollection</code> 集合中。</p><p><strong>$merge</strong>：合并结果到指定集合。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">&#123;<br><span class="hljs-meta prompt_">  $</span><span class="language-bash">merge: &#123; into: <span class="hljs-string">&quot;outputCollection&quot;</span>, whenMatched: <span class="hljs-string">&quot;merge&quot;</span>, whenNotMatched: <span class="hljs-string">&quot;insert&quot;</span> &#125;</span><br>&#125;<br></code></pre></td></tr></table></figure><p>【示例】</p><p>假设有一个包含销售数据的集合 <code>sales</code>，我们想要查询销售状态为 “A” 的文档，并计算每个商品的总销售量，最后按总销售量降序排列，并只取前 5 个结果。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell">db.sales.aggregate([<br>  &#123; $match: &#123; status: &quot;A&quot; &#125; &#125;,<br>  &#123; $group: &#123; _id: &quot;$item&quot;, totalQuantity: &#123; $sum: &quot;$quantity&quot; &#125; &#125; &#125;,<br>  &#123; $sort: &#123; totalQuantity: -1 &#125; &#125;,<br>  &#123; $limit: 5 &#125;<br>]);<br></code></pre></td></tr></table></figure><h4 id="管道的作用"><a href="#管道的作用" class="headerlink" title="管道的作用"></a>管道的作用</h4><p>管道使得 MongoDB 的聚合框架非常强大和灵活。通过管道，你可以：</p><ul><li><strong>清洗数据</strong>：过滤和转换原始数据，得到更干净的数据集。</li><li><strong>聚合分析</strong>：进行复杂的统计分析，比如求和、平均值、最大值、最小值等。</li><li><strong>数据转换</strong>：对数据进行格式化、计算新字段、展开数组等操作。</li><li><strong>数据集成</strong>：通过联表查询将多个集合的数据合并起来。</li></ul><h1 id="3-MongoDB索引"><a href="#3-MongoDB索引" class="headerlink" title="3. MongoDB索引"></a>3. MongoDB索引</h1><h2 id="3-1-概述"><a href="#3-1-概述" class="headerlink" title="3.1 概述"></a>3.1 概述</h2><p>索引支持在MongoDB中高效地执行查询。如果没有索引，MongoDB必须执行全集合扫描，即扫描集合中的每个文档，以选择与查询语句匹配的文档。这种扫描全集合的查询效率是非常低的，特别在处理大量的数据时，查询可以要花费几十秒甚至几分钟，这对网站的性能是非常致命的。</p><p>如果查询存在适当的索引，MongoDB可以使用该索引限制必须检查的文档数。</p><p>索引是特殊的数据结构，它以易于遍历的形式存储集合数据集的一小部分。索引存储特定字段或一组字段的值，按字段值排序。索引项的排序支持有效的相等匹配和基于范围的查询操作。此外，MongoDB还可以使用索引中的排序返回排序结果。</p><p>官网文档：<a href="https://docs.mongodb.com/manual/indexes/">https://docs.mongodb.com/manual/indexes/</a></p><p>MongoDB索引使用B树数据结构（确切的说是B-Tree，MySQL是B+Tree）</p><h2 id="3-2-索引的类型"><a href="#3-2-索引的类型" class="headerlink" title="3.2 索引的类型"></a>3.2 索引的类型</h2><h3 id="单字段索引"><a href="#单字段索引" class="headerlink" title="单字段索引"></a>单字段索引</h3><p>MongoDB支持在文档的单个字段上创建用户定义的升序&#x2F;降序索引，称为单字段索引（Single Field Index）。</p><p>对于单个字段索引和排序操作，索引键的排序顺序（即升序或降序）并不重要，因为MongoDB可以在任何方向上遍历索引。</p><h3 id="复合索引"><a href="#复合索引" class="headerlink" title="复合索引"></a>复合索引</h3><p>MongoDB还支持多个字段的用户定义索引，即复合索引（Compound Index）。</p><p>复合索引中列出的字段顺序具有重要意义。例如，如果复合索引由 { userid: 1, score: -1 } 组成，则索引首先按userid正序排序，然后在每个userid的值内，再在按score倒序排序。</p><h3 id="其他索引"><a href="#其他索引" class="headerlink" title="其他索引"></a>其他索引</h3><p>地理空间索引（Geospatial Index）、文本索引（Text Indexes）、哈希索引（Hashed Indexes）。</p><p>地理空间索引（Geospatial Index）</p><p>为了支持对地理空间坐标数据的有效查询，MongoDB提供了两种特殊的索引：返回结果时使用平面几何的二维索引和返回结果时使用球面几何的二维球面索引。</p><p>文本索引（Text Indexes）</p><p>MongoDB提供了一种文本索引类型，支持在集合中搜索字符串内容。这些文本索引不存储特定于语言的停止词（例如“the”、“a”、“or”），而将集合中的词作为词干，只存储根词。</p><p>哈希索引（Hashed Indexes）</p><p>为了支持基于散列的分片，MongoDB提供了散列索引类型，它对字段值的散列进行索引。这些索引在其范围内的值分布更加随机，但只支持相等匹配，不支持基于范围的查询。</p><h2 id="3-3-索引的管理操作"><a href="#3-3-索引的管理操作" class="headerlink" title="3.3 索引的管理操作"></a>3.3 索引的管理操作</h2><h3 id="索引的查看"><a href="#索引的查看" class="headerlink" title="索引的查看"></a>索引的查看</h3><p>说明：</p><p>返回一个集合中的所有索引的数组。</p><p>语法：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">db.collection.getIndexes()<br></code></pre></td></tr></table></figure><p>【示例】</p><p>查看comment集合中所有的索引情况</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs shell">db.comment.getIndexes()<br>[<br>&#123;<br>&quot;v&quot; : 2,<br>&quot;key&quot; : &#123;<br>&quot;_id&quot; : 1<br>&#125;,<br>&quot;name&quot; : &quot;_id_&quot;,<br>&quot;ns&quot; : &quot;articledb.comment&quot;<br>&#125;<br>]<br></code></pre></td></tr></table></figure><p>结果中显示的是默认 _id 索引。</p><p>默认_id索引：</p><p>MongoDB在创建集合的过程中，在 _id 字段上创建一个唯一的索引，默认名字为 <em>id</em> ，该索引可防止客户端插入两个具有相同值的文档，您不能在_id字段上删除此索引。</p><p>注意：该索引是唯一索引，因此值不能重复，即 _id 值不能重复的。在分片集群中，通常使用 _id 作为片键。</p><h3 id="索引的创建"><a href="#索引的创建" class="headerlink" title="索引的创建"></a>索引的创建</h3><p>说明：</p><p>在集合上创建索引。</p><p>语法：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">db.collection.createIndex(keys, options)<br></code></pre></td></tr></table></figure><p>参数：</p><table><thead><tr><th><strong>Parameter</strong></th><th><strong>Type</strong></th><th><strong>Description</strong></th></tr></thead><tbody><tr><td>keys</td><td>document</td><td>包含字段和值对的文档，其中字段是索引键，值描述该字段的索引类型。对于字段上的升序索引，请指定值1；对于降序索引，请指定值-1。比如： {字段:1或-1} ，其中1 为指定按升序创建索引，如果你想按降序来创建索引指定为 -1 即可。另外，MongoDB支持几种不同的索引类型，包括文本、地理空间和哈希索引。</td></tr><tr><td>options</td><td>document</td><td>可选。包含一组控制索引创建的选项的文档。有关详细信息，请参见选项详情列表。</td></tr></tbody></table><p>options（更多选项）列表：</p><table><thead><tr><th align="left">Parameter</th><th align="left">Type</th><th align="left">Description</th></tr></thead><tbody><tr><td align="left">background</td><td align="left">Boolean</td><td align="left">建索引过程会阻塞其它数据库操作，background可指定以后台方式创建索引，即增加 “background” 可选参数。 “background” 默认值为<strong>false</strong>。</td></tr><tr><td align="left">unique</td><td align="left">Boolean</td><td align="left">建立的索引是否唯一。指定为true创建唯一索引。默认值为<strong>false</strong>.</td></tr><tr><td align="left">name</td><td align="left">string</td><td align="left">索引的名称。如果未指定，MongoDB的通过连接索引的字段名和排序顺序生成一个索引名称。</td></tr><tr><td align="left">dropDups</td><td align="left">Boolean</td><td align="left">在建立唯一索引时是否删除重复记录,指定 true 创建唯一索引。默认值为 <strong>false</strong>.</td></tr><tr><td align="left">sparse</td><td align="left">Boolean</td><td align="left">对文档中不存在的字段数据不启用索引；这个参数需要特别注意，如果设置为true的话，在索引字段中不会查询出不包含对应字段的文档.。默认值为 <strong>false</strong>.</td></tr><tr><td align="left">expireAfterSeconds</td><td align="left">integer</td><td align="left">指定一个以秒为单位的数值，完成 TTL设定，设定集合的生存时间。</td></tr><tr><td align="left">v</td><td align="left">index version</td><td align="left">索引的版本号。默认的索引版本取决于mongod创建索引时运行的版本。</td></tr><tr><td align="left">weights</td><td align="left">document</td><td align="left">索引权重值，数值在 1 到 99,999 之间，表示该索引相对于其他索引字段的得分权重。</td></tr><tr><td align="left">default_language</td><td align="left">string</td><td align="left">对于文本索引，该参数决定了停用词及词干和词器的规则的列表。 默认为英语</td></tr><tr><td align="left">language_override</td><td align="left">string</td><td align="left">对于文本索引，该参数指定了包含在文档中的字段名，语言覆盖默认的language，默认值为 language.</td></tr></tbody></table><p>提示：</p><p>注意在 3.0.0 版本前创建索引方法为 db.collection.ensureIndex() ，之后的版本使用了 db.collection.createIndex() 方法，ensureIndex() 还能用，但只是 createIndex() 的别名。</p><p>【示例】</p><p>（1）单字段索引示例：对 userid 字段建立索引：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell">db.comment.createIndex(&#123;userid:1&#125;)<br>&#123;<br>&quot;createdCollectionAutomatically&quot; : false,<br>&quot;numIndexesBefore&quot; : 1,<br>&quot;numIndexesAfter&quot; : 2,<br>&quot;ok&quot; : 1<br>&#125;<br></code></pre></td></tr></table></figure><p>参数1：按升序创建索引</p><p>可以查看一下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs shell">db.comment.getIndexes()<br>[<br>&#123;<br>&quot;v&quot; : 2,<br>&quot;key&quot; : &#123;<br>&quot;_id&quot; : 1<br>&#125;,<br>    &quot;name&quot; : &quot;_id_&quot;,<br>    &quot;ns&quot; : &quot;articledb.comment&quot;<br>&#125;,<br>&#123;<br>    &quot;v&quot; : 2,<br>    &quot;key&quot; : &#123;<br>    &quot;userid&quot; : 1<br>  &#125;,<br>    &quot;name&quot; : &quot;userid_1&quot;,<br>    &quot;ns&quot; : &quot;articledb.comment&quot;<br>  &#125;<br>]<br></code></pre></td></tr></table></figure><p>索引名字为 userid_1</p><p>（2）复合索引：对 userid 和 nickname 同时建立复合（Compound）索引：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell">db.comment.createIndex(&#123;userid:1,nickname:-1&#125;)<br>&#123;<br>  &quot;createdCollectionAutomatically&quot; : false,<br>  &quot;numIndexesBefore&quot; : 2,<br>  &quot;numIndexesAfter&quot; : 3,<br>  &quot;ok&quot; : 1<br>&#125;<br></code></pre></td></tr></table></figure><p>查看一下索引：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs shell">db.comment.getIndexes()<br>[<br>  &#123;<br>    &quot;v&quot; : 2,<br>    &quot;key&quot; : &#123;<br>    &quot;_id&quot; : 1<br>  &#125;,<br>    &quot;name&quot; : &quot;_id_&quot;,<br>    &quot;ns&quot; : &quot;articledb.comment&quot;<br>&#125;,<br>  &#123;<br>    &quot;v&quot; : 2,<br>    &quot;key&quot; : &#123;<br>    &quot;userid&quot; : 1<br>  &#125;,<br>    &quot;name&quot; : &quot;userid_1&quot;,<br>    &quot;ns&quot; : &quot;articledb.comment&quot;<br>  &#125;,<br>  &#123;<br>    &quot;v&quot; : 2,<br>    &quot;key&quot; : &#123;<br>    &quot;userid&quot; : 1,<br>    &quot;nickname&quot; : -1<br>  &#125;,<br>    &quot;name&quot; : &quot;userid_1_nickname_-1&quot;,<br>    &quot;ns&quot; : &quot;articledb.comment&quot;<br>&#125;<br>]<br></code></pre></td></tr></table></figure><h3 id="索引的移除"><a href="#索引的移除" class="headerlink" title="索引的移除"></a>索引的移除</h3><p>说明：可以移除指定的索引，或移除所有索引</p><p>一、指定索引的移除</p><p>语法：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">db.collection.dropIndex(index)<br></code></pre></td></tr></table></figure><p>参数：</p><table><thead><tr><th>Parameter</th><th>Type</th><th>Description</th></tr></thead><tbody><tr><td>index</td><td>string or document</td><td>指定要删除的索引。可以通过索引名称或索引规范文档指定索引。若要删除文本索引，请指定索引名称。</td></tr></tbody></table><p>【示例】</p><p>删除 comment 集合中 userid 字段上的升序索引：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">db.comment.dropIndex(&#123;userid:1&#125;)<br>&#123; &quot;nIndexesWas&quot; : 3, &quot;ok&quot; : 1 &#125;<br></code></pre></td></tr></table></figure><p>查看已经删除了。</p><p>二、所有索引的移除</p><p>语法：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">db.collection.dropIndexes()<br></code></pre></td></tr></table></figure><p>【示例】</p><p>删除 spit 集合中所有索引。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell">db.comment.dropIndexes()<br>&#123;<br>  &quot;nIndexesWas&quot; : 2,<br>  &quot;msg&quot; : &quot;non-_id indexes dropped for collection&quot;,<br>  &quot;ok&quot; : 1<br>&#125;<br></code></pre></td></tr></table></figure><p>提示： _id 的字段的索引是无法删除的，只能删除非 _id 字段的索引。</p><h2 id="3-4-索引的使用"><a href="#3-4-索引的使用" class="headerlink" title="3.4 索引的使用"></a>3.4 索引的使用</h2><h3 id="执行计划"><a href="#执行计划" class="headerlink" title="执行计划"></a>执行计划</h3><p>分析查询性能（Analyze Query Performance）通常使用执行计划（解释计划、Explain Plan）来查看查询的情况，如查询耗费的时间、是否基于索引查询等。</p><p>那么，通常，我们想知道，建立的索引是否有效，效果如何，都需要通过执行计划查看。</p><p>语法</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">db.collection.find(query,options).explain(options)<br></code></pre></td></tr></table></figure><p>【示例】</p><p>查看根据userid查询数据的情况：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs shell">db.comment.find(&#123;userid:&quot;1003&quot;&#125;).explain()<br>&#123;<br>    &quot;queryPlanner&quot; : &#123;<br>    &quot;plannerVersion&quot; : 1,<br>    &quot;namespace&quot; : &quot;articledb.comment&quot;,<br>    &quot;indexFilterSet&quot; : false,<br>    &quot;parsedQuery&quot; : &#123;<br>    &quot;userid&quot; : &#123;<br>    &quot;$eq&quot; : &quot;1003&quot;<br>  &#125;<br>  &#125;,<br>    &quot;winningPlan&quot; : &#123;<br>    &quot;stage&quot; : &quot;COLLSCAN&quot;,<br>    &quot;filter&quot; : &#123;<br>    &quot;userid&quot; : &#123;<br>    &quot;$eq&quot; : &quot;1003&quot;<br>  &#125;<br>  &#125;,<br>    &quot;direction&quot; : &quot;forward&quot;<br>  &#125;,<br>    &quot;rejectedPlans&quot; : [ ]<br>  &#125;,<br>    &quot;serverInfo&quot; : &#123;<br>    &quot;host&quot; : &quot;9ef3740277ad&quot;,<br>    &quot;port&quot; : 27017,<br>    &quot;version&quot; : &quot;4.0.10&quot;,<br>    &quot;gitVersion&quot; : &quot;c389e7f69f637f7a1ac3cc9fae843b635f20b766&quot;<br>  &#125;,<br>    &quot;ok&quot; : 1<br>&#125;<br></code></pre></td></tr></table></figure><p>关键点看： “stage” : “COLLSCAN”, 表示全集合扫描</p><p>下面对userid建立索引</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell">db.comment.createIndex(&#123;userid:1&#125;)<br>&#123;<br>  &quot;createdCollectionAutomatically&quot; : false,<br>  &quot;numIndexesBefore&quot; : 1,<br>  &quot;numIndexesAfter&quot; : 2,<br>  &quot;ok&quot; : 1<br>&#125;<br></code></pre></td></tr></table></figure><p>再次查看执行计划：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs shell">db.comment.find(&#123;userid:&quot;1013&quot;&#125;).explain()<br>&#123;<br>  &quot;queryPlanner&quot; : &#123;<br>  &quot;plannerVersion&quot; : 1,<br>  &quot;namespace&quot; : &quot;articledb.comment&quot;,<br>  &quot;indexFilterSet&quot; : false,<br>  &quot;parsedQuery&quot; : &#123;<br>    &quot;userid&quot; : &#123;<br>    &quot;$eq&quot; : &quot;1013&quot;<br>    &#125;<br>  &#125;,<br>  &quot;winningPlan&quot; : &#123;<br>    &quot;stage&quot; : &quot;FETCH&quot;,<br>    &quot;inputStage&quot; : &#123;<br>      &quot;stage&quot; : &quot;IXSCAN&quot;,<br>      &quot;keyPattern&quot; : &#123;<br>      &quot;userid&quot; : 1<br>  &#125;,<br>      &quot;indexName&quot; : &quot;userid_1&quot;,<br>      &quot;isMultiKey&quot; : false,<br>      &quot;multiKeyPaths&quot; : &#123;<br>      &quot;userid&quot; : [ ]<br>      &#125;,<br>      &quot;isUnique&quot; : false,<br>      &quot;isSparse&quot; : false,<br>      &quot;isPartial&quot; : false,<br>      &quot;indexVersion&quot; : 2,<br>      &quot;direction&quot; : &quot;forward&quot;,<br>      &quot;indexBounds&quot; : &#123;<br>        &quot;userid&quot; : [<br>        &quot;[\&quot;1013\&quot;, \&quot;1013\&quot;]&quot;<br>  ]<br>  &#125;<br>  &#125;<br>  &#125;,<br>  &quot;rejectedPlans&quot; : [ ]<br>  &#125;,<br>  &quot;serverInfo&quot; : &#123;<br>    &quot;host&quot; : &quot;9ef3740277ad&quot;,<br>    &quot;port&quot; : 27017,<br>    &quot;version&quot; : &quot;4.0.10&quot;,<br>    &quot;gitVersion&quot; : &quot;c389e7f69f637f7a1ac3cc9fae843b635f20b766&quot;<br>  &#125;,<br>  &quot;ok&quot; : 1<br>&#125;<br></code></pre></td></tr></table></figure><p>关键点看： “stage” : “IXSCAN” ,基于索引的扫描</p><h3 id="涵盖的查询"><a href="#涵盖的查询" class="headerlink" title="涵盖的查询"></a>涵盖的查询</h3><p>Covered Queries</p><p>当查询条件和查询的投影仅包含索引字段时，MongoDB直接从索引返回结果，而不扫描任何文档或将文档带入内存。 这些覆盖的查询可以非常有效。</p><p><a href="https://www.mongodb.com/docs/manual/core/query-optimization/#read-operations-covered-query">https://www.mongodb.com/docs/manual/core/query-optimization/#read-operations-covered-query</a></p>]]></content>
    
    
    <categories>
      
      <category>MongoDB</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据库</tag>
      
      <tag>MongoDB</tag>
      
      <tag>NoSQL</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
